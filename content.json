{"meta":{"title":"青史成灰","subtitle":"Every journey begins with the first step","description":null,"author":"xxxxxMiss","url":"https://xxxxxmiss.github.io"},"pages":[{"title":"","date":"2017-10-20T03:24:00.000Z","updated":"2017-09-22T09:32:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://xxxxxmiss.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-20T03:24:00.000Z","updated":"2017-09-22T09:31:28.000Z","comments":false,"path":"tags/index.html","permalink":"https://xxxxxmiss.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"centos7部署nodejs+mongodb工程","slug":"nodejs-deploy","date":"2017-10-14T06:13:20.000Z","updated":"2017-10-14T09:28:49.000Z","comments":true,"path":"2017/10/14/nodejs-deploy/","link":"","permalink":"https://xxxxxmiss.github.io/2017/10/14/nodejs-deploy/","excerpt":"","text":"通过ssh登录阿里云主机 ssh username@公网ip 1234567891011121314151617181920binbootdevetchomeliblib64lost+foundmediamntoptprocroot [使用ssh root@公网ip成功登录后进入的目录]runsbinsrvsystmpusrvar 当使用root用户登录以后，会进入root目录，当你切换到上一层目录后，会看到如上所示的目录结构。 安装nvm 通过上一步的登录阿里云主机之后，你可以直接在root目录下，也可以新建其他的目录，然后安装nvm。nvm是node版本管理工具，通过该工具可以很方便的管理Node版本。 具体的安装步骤参考官方文档：nvm 安装nodejs 一旦nvm成功安装以后，我们就可以通过nvm来安装nodejs。比如： 1nvm install node // 安装最新版的nodejs 安装mongodb 具体的安装细节可以参照mongodb官方文档。 注意： 下面以在64-bit systems安装最新版的mongdb3.4为例： 配置包管理系统(yum) 新建/etc/yum.repos.d/mongodb-org-3.4.repo文件，然后将以下代码拷贝到该文件中. 123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 安装mongodb包和相关的工具 sudo yum install -y mongodb-org 默认情况下，mongodb存储数据在/var/lib/mongo，日志文件在/var/log/mongodb。当然，这些配置都是可以在/etc/mongod.conf中修改。 启动mongodb sudo service mongod start 查看mongodb是否成功启动 在日志文件中查看是否有这样的一行：[initandlisten] waiting for connections on port port：默认端口27017，可以在/etc/mongod.conf中修改。 停止mongodb sudo service mongod stop 重启mongodb sudo service mongod restart 卸载mongodb 卸载mongodb，会将mongodb程序本身，他的配置文件，以及所有的数据删除，并且该过程是不可逆的。所以在卸载之前，确保已经备份。 停止mongodb sudo service mongod stop 移除包 sudo yum erase $(rpm -qa | grep mongodb-org) 移除数据 sudo rm -r /var/log/mongodbsudo rm -r /var/lib/mongo 安装nginx 可以直接从官网下载压缩包，也可以通过源码构建。因为nginx还依赖一些其他的包来扩展功能，所以还需要安装一些其他的依赖包。具体选择安装哪些依赖包，看你需要什么功能。 安装nginx所需的几个依赖包 yum install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 通过源码构建 build nginx from source 启动nginx service nginx start 重启nginx service nginx restart 安装git yum install git 更多git信息传送门 安装pm2 npm install pm2 -g 更多pm2信息传送门 开始部署项目 当上面的准备工作全部成功的完成以后，我们就可以部署我们的nodejs工程了。 克隆nodejs工程到阿里云主机 git clone … 安装工程依赖 npm install 启动工程 pm2 start app.js","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"},{"name":"mongodb","slug":"mongodb","permalink":"https://xxxxxmiss.github.io/tags/mongodb/"}]},{"title":"css动画常见案例","slug":"css-transition-1","date":"2017-10-10T12:28:18.000Z","updated":"2017-10-14T13:42:27.000Z","comments":true,"path":"2017/10/10/css-transition-1/","link":"","permalink":"https://xxxxxmiss.github.io/2017/10/10/css-transition-1/","excerpt":"","text":".container{ margin: 15px auto; } .btn{ position: relative; display: inline-block; box-sizing: border-box; outline: none; border: 1px solid #ebebeb; padding: 0 15px; height: 30px; line-height: 30px; border-radius: 4px; user-select: none; cursor: pointer; text-align: center; color: #fff; background-color: #00c1de; } .btn.btn-blink:after{ position: absolute; content: \"\"; top: -1px; left: -1px; bottom: -1px; right: -1px; border: 0 solid #00c1de; border-radius: 4px; box-shadow: 0 0 2px 0 #00c1de; animation: blink .3s cubic-bezier(.645,.045,.355,1); } @keyframes blink{ from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale3d(1.1, 1.2, 0); } } .btn-round-blink{ font-size: 30px; font-weight: 500; margin: 0 30px; height: 30px; width: 30px; border-radius: 50%; } .btn-round-blink:before, .btn-round-blink:after{ position: absolute; content: \"\"; top: 0; left: 0; right: 0; bottom: 0; border: 1px solid #00c1de; border-radius: 50%; } .btn-round-blink:before{ animation: round-blink 2s infinite; } .btn-round-blink:after{ animation: round-blink 1s infinite; } @keyframes round-blink{ from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(1.88); } } .progress{ position: absolute; left: -100%; top: 0; background-color: #00c1de; width: 100%; height: 3px; } .progress.fade-in{ animation: fade-in 1s ease-in; } @keyframes fade-in{ from { transform: translate3d(0, 0, 0); } to { transform: translate3d(200%, 0, 0); } } .progress-grow{ position: absolute; left: 0; top: 0; width: 0; height: 3px; background-color: #00c1de; animation: grow-in 1s infinite; } @keyframes grow-in{ from { width: 0; } to{ width: 100%; } } 显示进度条 var btn = document.getElementById('btn') , progress = document.getElementById('progress') btn.addEventListener('mouseup', function () { this.classList.add('btn-blink') }) btn.addEventListener('animationend', function () { this.classList.remove('btn-blink') }) btn.addEventListener('click', function () { progress.classList.add('fade-in') }) progress.addEventListener('animationend', function () { progress.classList.remove('fade-in') }) 本篇主要内容是如何自己实现各种网站，UI框架的一些过渡效果 按钮 之前看到ant design上按钮的那种点击效果，于是按照自己的思路来模拟下。 这种效果其实有多种实现方式，我们这里提供一种: 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 按钮的样式.btn&#123; position: relative; display: inline-block; box-sizing: border-box; outline: none; border: 1px solid #ebebeb; padding: 0 15px; height: 30px; line-height: 30px; border-radius: 4px; user-select: none; cursor: pointer; text-align: center; color: #fff; background-color: #00c1de;&#125;// 一闪而过的矩形.btn.btn-blink:after&#123; position: absolute; content: \"\"; top: -1px; left: -1px; bottom: -1px; right: -1px; border: 1px solid #00c1de; border-radius: inherit; box-shadow: 0 0 2px 0 #00c1de; // 合理执行时间和缓动函数可以使动画看起来更加的舒适。。。 // 所以需要自己慢慢的调试 animation: blink .3s cubic-bezier(.645,.045,.355,1);&#125;// 一闪而过的动画@keyframes blink&#123; from &#123; opacity: .5; transform: scale(1); &#125; to &#123; opacity: 0; // y轴的放大应该比x轴大一些，因为一般按钮情况下按钮的宽度都是大于高度的 // 如果不这样做，动画就不是很理想了 transform: scale3d(1.1, 1.2, 0); &#125;&#125; 闪烁效果 这种效果就跟水波一样，一层一层的像远处散开然后消失。最简单的用before和after伪类就可以实现，当然了这也只是一种实现。如果觉得不够逼真，那么就需要你慢慢的调试，改动缓动函数以及动画执行的事件。 12345678910111213141516171819202122232425262728.btn&#123; // 同上 &#125;.btn-round-blink&#123; font-size: 30px; font-weight: 500; margin: 0 30px; height: 30px; width: 30px; border-radius: 50%;&#125;.btn-round-blink:before,.btn-round-blink:after&#123; position: absolute; content: \"\"; top: 0; left: 0; right: 0; bottom: 0; border: 1px solid #00c1de; border-radius: 50%;&#125;.btn-round-blink:before&#123; animation: round-blink 2s infinite;&#125;.btn-round-blink:after&#123; animation: round-blink 1s infinite;&#125; 进度条 进入条一般用在异步请求中。 123456789101112131415161718192021222324252627282930313233343536373839// 可以用这种效果.progress&#123; position: fixed; left: -100%; top: 0; background-color: #00c1de; width: 100%; height: 3px;&#125;.progress.fade-in&#123; animation: fade-in 1s ease-in infinite;&#125;@keyframes fade-in&#123; from &#123; transform: translate3d(0, 0, 0); &#125; to &#123; transform: translate3d(200%, 0, 0); &#125;&#125;// 也可以用这种效果.progress-grow&#123; position: fixed; left: 0; top: 0; width: 0; height: 3px; background-color: #00c1de; animation: grow-in 1s infinite;&#125;@keyframes grow-in&#123; from &#123; width: 0; &#125; to&#123; width: 100%; &#125;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"https://xxxxxmiss.github.io/categories/frontend/"}],"tags":[{"name":"css","slug":"css","permalink":"https://xxxxxmiss.github.io/tags/css/"}]},{"title":"使用hexo搭建自己的博客","slug":"create-blog","date":"2017-09-28T15:17:08.000Z","updated":"2017-10-11T04:01:41.000Z","comments":true,"path":"2017/09/28/create-blog/","link":"","permalink":"https://xxxxxmiss.github.io/2017/09/28/create-blog/","excerpt":"","text":"环境 Node github git-pages git或者其他的版本控制工具 Hexo或者其他的SSG Hexo相关配置 Hexo 几个主要命令 hexo new post/draft &lt;file-name&gt; 会在source目录下的_posts或则_drafts下生成file-name.md。也就是说你在使用hexo new创建文件的时候，不需要带文件扩展名，默认生成markdown文件 hexo clean 清楚缓存，一般在使用hexo deploy命令时，先执行该命令。 hexo deploy 推送到仓库到远程 当然，你也可以加入自己的逻辑，用脚本将这些命令串起来，这样在发布以及提交源代码的时候就可以一步到位：比如像这样 markdown语法 github上常用markdown语法：Mastering Markdown简体中文版：markdown 注意： 在hexo中使用markdown时，引用外部资源的时候，需要按照hexo提供的语法来引用。比如引用图片：1&#123;% asset_img stacking-props.png 其他属性的元素 %&#125; 上面的是固定语法，stacking-props.png是对应的资源文件，其他属性的元素是鼠标hover时候显示的字符。当然了，你也可以不传该参数，那么hover的时候就显示stacking-props.png 按照上一步引用资源，需要在_config.yml中将post_asset_folder选项设置为true。一旦开启该选项，那么在每次使用hexo new创建文章的时候，都会在对于的目录下生成和文件名相同的目录，你的静态资源就放到该目录下。 比如：1$ hexo new post hexo-blog 那么在source/_posts下就会生成hexo-blog.md文件和hexo-blog文件夹。 markdown中的一些特殊字符需要转义比如：&lt;需要写成&amp;lt; 更多选项参考官方文档这里 yaml语法 yaml","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"},{"name":"frontend-framework","slug":"frontend-framework","permalink":"https://xxxxxmiss.github.io/tags/frontend-framework/"}]},{"title":"event-1","slug":"event-1","date":"2017-09-28T03:50:36.000Z","updated":"2017-10-11T04:04:33.000Z","comments":true,"path":"2017/09/28/event-1/","link":"","permalink":"https://xxxxxmiss.github.io/2017/09/28/event-1/","excerpt":"","text":"浏览器事件系统 [x] this is a completed item [ ] this is a incomplete item emoji! :sparkles: :camel: :boom:","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"awk内置函数","slug":"awk-build-in-functions","date":"2017-09-19T12:42:18.000Z","updated":"2017-09-20T02:48:09.000Z","comments":true,"path":"2017/09/19/awk-build-in-functions/","link":"","permalink":"https://xxxxxmiss.github.io/2017/09/19/awk-build-in-functions/","excerpt":"","text":"在awk中, 需要知道的点 数组，字符串等等，索引都是从1开始 变量的取值直接写变量名var，而不像shell中需要$var，除了内置的特殊变量$0，$1，$2，…等 FS：指定列分隔符，如：BEGIN{FS=&quot;:&quot;} 内置NF变量：以指定分隔符FS分割出来的列数 内置NR变量：当前处理的行数 split(str, arr, field separator) 使用指定的列分隔符将行分割到一个数组中。如果列分隔符没有传值，默认使用IFS的值。 123456789➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"echo $time | awk '&#123;split($0, arr, \":\"); print arr[1]\"--&gt;\"arr[2]\"--&gt;\"arr[3]&#125;'➜ shell ./test.sh12--&gt;ab--&gt;&amp;&amp; substr(str, start, length) 从str中start位置开始截取长度为length的字符串。如果没有截取长度length,那么默认截取到str的末尾。 1234567891011121314151617181920➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"echo $time | awk '&#123;s=substr($0, 3); print s&#125;'➜ shell ./test.sh:ab:&amp;&amp;➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"echo $time | awk '&#123;s=substr($0, 3, 4); print s&#125;'➜ shell ./test.sh:ab: index(str, target_str) 查找target_str在str中出现的位置，如果找到了，那么返回第一次找到的索引；如果没有找到，返回0 12345678910111213141516171819202122➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"echo $time | awk '&#123;i=index($0, \"a\"); print \"index: \"i&#125;'# 字符a在time中索引为4➜ shell ./test.shindex: 4➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"echo $time | awk '&#123;i=index($0, \"x\"); print \"index: \"i&#125;'# 没有找到，返回0➜ shell ./test.shindex: 0 gsub(regexp, sub_str, str) 将str中匹配regexp的子串全部替换为sub_str, 并返回成功匹配的次数。 12345678910➜ shell cat test.sh#!/bin/bashtime=\"12:ab:&amp;&amp;\"# count为当前行成功匹配的次数echo $time | awk '&#123;count=gsub(\"[[:digit:]]\", \"**\", $0); print $0\"\\nmatches count: \"count&#125;'➜ shell ./test.sh****:ab:&amp;&amp;matches count: 2 sub(regexp, sub_str, str) 将str中第一次匹配regexp的子串替换为sub_str, 并返回成功匹配的次数(0或者1)。和上面的gsub比较，就相当于一个是全局匹配，一个是单词匹配。 123456789101112➜ shell cat test.sh#!/bin/bashtime=\"c21:ab:&amp;&amp;\"# count为当前行成功匹配的次数# 因为只会匹配一次，所以成功匹配，那么返回1；没有找到一个匹配，返回0echo $time | awk '&#123;count=sub(\"[[:digit:]]\", \"**\", $0); print $0\"\\nmatches count: \"count&#125;'➜ shell ./test.shc**1:ab:&amp;&amp;matches count: 1 length(str) 返回指定字符串的长。当不指定str,那么返回当前行的字符串长度。 123456789101112131415➜ shell cat test.sh#!/bin/bashtime=\"c21:ab:&amp;&amp;\"echo $time | awk 'BEGIN&#123;FS=\":\"&#125; &#123; for(i = 1; i &lt;= NF; i++)&#123; print \"line&lt; \"i\" &gt; char count: \"length($i) &#125;&#125;'➜ shell ./test.shline&lt; 1 &gt; char count: 3line&lt; 2 &gt; char count: 2line&lt; 3 &gt; char count: 2 123456789➜ shell cat test.sh#!/bin/bashtime=\"c21:ab:&amp;&amp;\"echo $time | awk 'BEGIN&#123;FS=\":\"&#125; &#123;print length()&#125;'➜ shell ./test.sh9","categories":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"git进阶（二）","slug":"git-plumbing-2","date":"2017-09-18T17:23:39.000Z","updated":"2017-09-19T17:22:22.000Z","comments":true,"path":"2017/09/19/git-plumbing-2/","link":"","permalink":"https://xxxxxmiss.github.io/2017/09/19/git-plumbing-2/","excerpt":"","text":"git配置文件的位置 /etc/gitconfig ~/.gitconfig || $XDG_CONFIG_HOME/git/config $PWD/.git/config 查看git配置 对于配置选项的CURD操作，不指定–system,–global,–local选项，CUD默认都是–local选项, R操作查询所有的配置（相当于同时指定了三个选项）。 12345678910111213// 查看系统级别的所有配置git config --system -l// 查看全局的所有配置(默认查看global级别)git config --global -l// 查看当前仓库的配置git config --local -l// 查看具体某一项的配置git config [--system|--global|--local] --get core.editor// 默认查看local级别git config --get core.editor 设置git配置1git config [--system|--global|--local] user.name \"qsch\" 删除某个配置1234567// 删除global级别的commit.template配置git config --global --unset commit.template// 删除local级别git config --local --unset commit.template// 或则git config --unset commit.template commit.template 配置提交信息的模板。使用同一份模板，可以保持团队成员的提交信息风格保持一致。 比如你这样设置git config commit.template ~/.gitmessage.txt,那么当你git commit的时候，会进入你设置的提交信息的模板编辑页面，修改保存，那么修改后的提交信息就是本次的提交信息。 core.excludesfile global级别的.gitignore。一般每个项目下都会有.gitignore文件，如果配置了global级别的.gitignore,那么对于所有的git仓库都会生效。如：git config core.excludesfile ~/.gitignore_global core.autocrlf 用来处理各平台之间的换行符回车符之间的一致性问题 使用linux或者mac,一般设置为input,那么在检出的时候，自动将\\r\\n转化为\\n。 使用windows，可以设置为true,那么在检出的时候，自动将\\n转化为\\r\\n。 如果只在windows上开发，那么可以设置为false,关闭该功能。 使用npm安装你自己编写的脚本","categories":[{"name":"git","slug":"git","permalink":"https://xxxxxmiss.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xxxxxmiss.github.io/tags/git/"}]},{"title":"vue-base","slug":"vue-base","date":"2017-09-06T03:11:27.000Z","updated":"2017-09-07T17:37:02.000Z","comments":true,"path":"2017/09/06/vue-base/","link":"","permalink":"https://xxxxxmiss.github.io/2017/09/06/vue-base/","excerpt":"","text":"vm.$mount( [elementOrSelector] ) 该方法返回vue实例本身。.vue文件，基本写法都是export default {}, 这导出的是一个构造配置选项。Vue构造函数如下 1234567function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 所以我们.vue导出的就是构造函数需要的options。 如果options提供了el选项，那么vm实例会挂载到el对应的dom元素上（el所对应的元素被vm生成的html字符串替换掉）。如果options选项为提供el选项，那么生成的vm实例处于未挂载的状态。 但是我们.vue文件中，并未提供el选项，但是vm生成的html字符串依然可以正常的渲染在文档流中，为什么？ 因为我们在搭配路由使用的时候，需要指定&lt;router-view&gt;组件，其实该组件就是一个挂载点。 TODO：经常看到new Vue(options).$mount().$el, 其实new Vue(options).$el返回同样的结果，有什么区别？ 响应式 Vue.util Vue.util上挂载了一些有用的工具方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var util = Object.freeze(&#123; defineReactive: defineReactive$$1, _toString: _toString, toNumber: toNumber, makeMap: makeMap, isBuiltInTag: isBuiltInTag, remove: remove$1, hasOwn: hasOwn, isPrimitive: isPrimitive, cached: cached, camelize: camelize, capitalize: capitalize, hyphenate: hyphenate, bind: bind$1, toArray: toArray, extend: extend, isObject: isObject, isPlainObject: isPlainObject, toObject: toObject, noop: noop, no: no, identity: identity, genStaticKeys: genStaticKeys, looseEqual: looseEqual, looseIndexOf: looseIndexOf, isReserved: isReserved, def: def, parsePath: parsePath, hasProto: hasProto, inBrowser: inBrowser, UA: UA, isIE: isIE, isIE9: isIE9, isEdge: isEdge, isAndroid: isAndroid, isIOS: isIOS, isServerRendering: isServerRendering, devtools: devtools, nextTick: nextTick, get _Set () &#123; return _Set; &#125;, mergeOptions: mergeOptions, resolveAsset: resolveAsset, get warn () &#123; return warn; &#125;, get formatComponentName () &#123; return formatComponentName; &#125;, validateProp: validateProp&#125;); isServerRendering的实现：12345678910111213141516171819var _isServer;var isServerRendering = function () &#123; if (_isServer === undefined) &#123; /* istanbul ignore if */ if (!inBrowser &amp;&amp; typeof global !== 'undefined') &#123; // detect presence of vue-server-renderer and avoid // Webpack shimming the process _isServer = global['process'].env.VUE_ENV === 'server'; &#125; else &#123; _isServer = false; &#125; &#125; return _isServer&#125;;// vm.$isServer，调用getter，执行isServerRendering函数Object.defineProperty(Vue$3.prototype, '$isServer', &#123; get: isServerRendering&#125;); camelize实现： 将连字符变量名转化为驼峰命名 1234var camelizeRE = /-(\\w)/g;var camelize = cached(function (str) &#123; return str.replace(camelizeRE, function (_, c) &#123; return c ? c.toUpperCase() : ''; &#125;)&#125;); capitalize实现： 将一个单词（变量名）的首字母转化为大写 123var capitalize = cached(function (str) &#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;); extend实现： 将第二个对象的属性全部拷贝到第一个对象上并返回该对象.to上的同名属性会被_from覆盖 123456function extend (to, _from) &#123; for (var key in _from) &#123; to[key] = _from[key]; &#125; return to&#125; Vue中props的校验12345678910/** * Use function string name to check built-in types, * because a simple equality check will fail when running * across different vms / iframes. */// 直接利用正则匹配出函数名function getType (fn) &#123; var match = fn &amp;&amp; fn.toString().match(/^\\s*function (\\w+)/); return match &amp;&amp; match[1]&#125;","categories":[],"tags":[]},{"title":"git进阶（一）","slug":"git-plumbing","date":"2017-08-20T06:56:16.000Z","updated":"2017-08-25T11:45:14.000Z","comments":true,"path":"2017/08/20/git-plumbing/","link":"","permalink":"https://xxxxxmiss.github.io/2017/08/20/git-plumbing/","excerpt":"","text":".git文件一览1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162├── COMMIT_EDITMSG├── FETCH_HEAD├── HEAD // 保存了当前分支的引用, 该引用指向refs/heads下对应的文件├── ORIG_HEAD├── branches├── config // 当前选项的配置文件├── description├── hooks // git相关钩子│ ├── applypatch-msg.sample│ ├── commit-msg.sample│ ├── post-update.sample│ ├── pre-applypatch.sample│ ├── pre-commit.sample│ ├── pre-push.sample│ ├── pre-rebase.sample│ ├── prepare-commit-msg.sample│ └── update.sample├── index // index区（暂存区）├── info│ └── exclude // 配置.gitignore相关├── logs // 日志│ ├── HEAD│ └── refs│ ├── heads│ │ ├── dev│ │ ├── feat│ │ ├── master│ │ ├── revert│ │ └── test│ └── remotes│ └── origin│ ├── HEAD│ ├── dev│ ├── master│ ├── severfix│ └── test├── objects // 每个提交的记录│ ├── 00│ │ └── 0c30b7f4429c3d4c3ad782cc051798724b66f7│ ├── 01│ │ ├── 143716b369d9720651644bf6ad8543d3c9ff64│ │ └── 2c1fbd55bee496631593d14814c2370f61e64a│ ├── info│ └── pack│ ├── pack-edc94ec3aa0349b77e3e1b8264644068e4118389.idx│ └── pack-edc94ec3aa0349b77e3e1b8264644068e4118389.pack├── packed-refs└── refs ├── heads // 本地各个分支最新提交 │ ├── dev │ ├── feat │ ├── master │ ├── revert │ └── test ├── remotes │ └── origin //保存了远程分支最新提交 │ ├── HEAD │ ├── dev │ ├── master │ ├── severfix │ └── test └── tags 远程分支远程引用 远程引用（指针）是对远程仓库的引用git remote show origin 远程分支 远程跟踪分支是远程分支状态的引用, 他们是你不能移动的本地引用。已(remote)/(branch) git branch -a 跟踪分支（上游分支） 本地分支关联远程分支。做了关联之后，就可以简化很多命令，比如git pull, git能自动的识别去哪个服务器上抓取，合并到哪个分支。 123git checkout -b [branch] [remotename]/[branch]git checkout --track origin/master(快捷方式) 为已有的分支设置上游分支 12git branch -u origin/mastergit branch --set-upstream-to=origin/master 查看本地分支是否设置了上游分支，与上游分支领先落后以及最后一次提交等信息 1git branch -vv 取消上游分支 1git branch --unset-upstream 重写历史修改最近一次的提交信息1git commit --amend 如果你已经使用上述命令完成了最近一次提交信息的修改，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 12git add || git rmgit commit --amend 修改多个提交信息。 如果要修改多个提交信息，可以通过交互式变基来实现。这是一个变基命令: 在 HEAD~3..HEAD 范围内的每一个提交都会被重写，无论你是否修改信息。 1git rebase -i HEAD~3 Note: 需要注意的是，rebase命令会将你带入文本编辑模式，这个文本编辑模式中所列出来的提交列表和使用git log列出来的提交是相反的。rebase:从旧到新，log:从新到旧 假设我们进入编辑模式是这样的：123456789101112131415161718192021pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file# Rebase 710f0f8..a5f4a0d onto 710f0f8## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 假设我们只修改第一次的提交信息（也就是最上面的那一条），那么我们可以将最上面的那一条信息前面的pick改为edit或者e,保存退出。 退出保存，终端会显示如下的信息: 12345678Stopped at 3d8f8dbe792fb8ec971d697470ec8bfd0ce0f8d6... delete 4 5 7 rowsYou can amend the commit now, with git commit --amendOnce you are satisfied with your changes, run git rebase --continue 注意：此次HEAD指针已经移动到了3d8f8db这一次的提交，那么我们可以继续运行12345git commit --amend // 修改第一次的提交git rebase --continue // 将HEAD指针在移动回最近的那次提交// 上述2个命令执行完成后，终端会显示如下信息Successfully rebased and updated refs/heads/test. 压缩提交 如果多个提交都是完成一个功能的，我们可以将这些提交压缩成一个提交，使用的命令也是rebase。我们从上面的例子可以知道，一旦进入文本编辑模式，会有’pick’, ‘edit’, ‘squash’, ‘fixup’选项。如果我们要压缩多个提交，只需要将每条提交前面的’pick’改为’squash’(后面再讲解squash与fixup的区别)。 加入进入文本编辑模式如下123456789101112131415161718192021pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file# Rebase 710f0f8..a5f4a0d onto 710f0f8## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out squash就是下面的提交记录压缩到前面的提交记录中（将几条提交记录整合到一起），但是需要注意的是，不能讲最上面的那一条提交记录前面的pick改为squash, 那样就没有前一条记录了。如果你真的将最上面的那一天提交记录也改为squash，那么在退出文本编辑模式的时候，会提示Cannot &#39;squash&#39; without a previous commit。 那么squash后的log如下12345678910111213commit 8406738ce7740d8800890b58bf3b6ee6aab23f3dAuthor: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 10:44:34 2017 +0800 changed my name a bit updated README formatting and added blame added cat-filecommit 20559c2e26d7c8183c4ad73761d3e26c81de6af2Author: chenxianlong &lt;794465731@qq.com&gt;Date: Sat Aug 19 16:56:24 2017 +0800 test rebase configs 查看log信息可以squash将三条提交记录压缩为一条，但是如果你使用fixup选项，那么rebase后会丢掉每条被你标记为fixup的提交记录，这是他和squash的唯一区别。 使用fixup的log会看起来如下12345678910commit 8406738ce7740d8800890b58bf3b6ee6aab23f3dAuthor: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 10:44:34 2017 +0800 changed my name a bitcommit 20559c2e26d7c8183c4ad73761d3e26c81de6af2Author: chenxianlong &lt;794465731@qq.com&gt;Date: Sat Aug 19 16:56:24 2017 +0800 test rebase configs git中的三棵树（三个区） 平时我们使用git add,git commit, git checkout, git reset等这些命令来做git的一些操作，其实内部就是在操作这三个区域： working: 工作区，平时文件的增删改都是在working区index: 暂存区，使用git add将工作区的内容保存在暂存区，暂存区中的内容是即将要提交的内容HEAD: 提交区，保存了当前分支最近的一次提交 reset压缩提交历史 有了上面三棵树的基础，那么了解reset工作的机理就比较清晰了。 reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 –soft，则到此停止） 使索引看起来像 HEAD （若未指定 –hard，则到此停止） 使工作目录看起来像索引 再来解析下上面1,2中括号中说明的含义 加入我们要修改前3次的提交1234567891011// 移动HEAD中的指针指向倒数第四次提交，此时修改的文件处于暂存区// 也就是说加了--soft，会回退到git commit之前git reset --soft HEAD~3// 移动HEAD中的指针指向倒数第四次提交，此时修改的文件处于暂存区// 更新暂存区，使工作区和暂存区看起来是一样的// 也就是说不加--soft选项，回会退到git add之前git reset HEAD~3// --hard是个危险选项，会让你撤销所有的修改git reset --hard HEAD~3 reset重置路径 上面说的reset是针对提交历史的，我们也可以使用reset针对某个具体路径。比如我们在使用git add .添加了所有的东西到暂存区，但是在提交的时候，发送有个文件或者文件夹中的东西不是当前功能的，那么可以通过reset来让文件或者文件集合回到工作区，只提交本次要提交的功能。实际上，git add和git reset所做的事情是相反的，git reset本质是将HEAD区的中的文件拷贝到暂存区，并且不会移动HEAD中的分支指针。 1234567891011121314On branch testYour branch and 'origin/test' have diverged,and have 4 and 15 different commits each, respectively. (use \"git pull\" to merge the remote branch into yours)Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: test.txtChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: test.txt 撤销合并之reset修改引用，revert还原假设现在在一个特性分支上工作，不小心将其合并到 master 中，现在提交历史看起来是这样： 对于上面的问题，有2种修复方法： 修改引用 如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 git merge 后运行 git reset --hard HEAD~，这会重置分支指向所以它们看起来像这样： 这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 reset。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。 还原提交 如果上面的修改引用的方法不适合你，那么你还可以使用还原操作。123// 1,表示需要保留下来的父节点，如下图，我们此处的父节点是C6或则C4，// 因为我们此时在master分支上，所有保留下来的父节点是C6git revert -m 1 HEAD 调用了上述命令之后，提交历史看起来是这样的： 12345678910111213141516171819202122232425262728commit e5a5ab537309c2006676392d4fb5dc1ae2dae78eAuthor: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 17:14:20 2017 +0800 Revert \"Merge branch 'test revert in test branch'\" This reverts commit 606de1d0d3d7313ca3c0914c65eb5f77ca97a48e, reversing changes made to 2ece042de65c693c709b3f9d34d7b598697984ff.commit 606de1d0d3d7313ca3c0914c65eb5f77ca97a48eMerge: 2ece042 d9a757bAuthor: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 17:10:16 2017 +0800 Merge branch 'test revert in test branch'commit d9a757b76f1e95c26bd116d18f03338c0e5920c0Author: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 17:10:10 2017 +0800 revert 提交 in test branchcommit 2ece042de65c693c709b3f9d34d7b598697984ffMerge: c7434ae 44ee440Author: chenxianlong &lt;794465731@qq.com&gt;Date: Wed Aug 23 17:08:25 2017 +0800 Merge branch 'feat add 9999 in feat branch' 该命令会生成一条新的提交，我们如果查看上面的log,可以看出第一天提交信息，其中明确的写明了e5a5ab5是在606de1d的基础上生成的新提交，并且将2ece042的提交还原了。 再来看看git revert -m 1 HEAD之后的历史 新的提交 ^M 与 C6 有完全一样的内容，所以从这儿开始就像合并从未发生过，但是如果你尝试再次合并 topic 到 master Git 会感到困惑：12$ git merge topicAlready up-to-date. 因为我们调用git revert -m 1 HEAD之后，已经将topic中提交剔除出去了，但是现在再来合并却发现并没有不一样的内容，也就是说我们无法再次将topic分支的提交合并到master.更糟的是，如果你在 topic 中增加工作然后再次合并，会产生冲突。 解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，然后 创建一个新的合并提交：123456// revert ^M之后，又会产生一次新的提交^^M，这次新的提交包含了开始剔除出去的内容（C3,C4）$ git revert ^M[master 09f0126] Revert \"Revert \"Merge branch 'topic'\"\"$ git merge topic// merge topic时，会将^^M，C7，C2做一个三方合并 在重新合并一个还原合并后的历史在本例中，M 与 ^M 抵消了。 ^^M 事实上合并入了 C3 与 C4 的修改，C8 合并了 C7 的修改，所以现在 topic 已经完全被合并了。 所有遇到以上情况，我们需要做三步：123git revert -m -1 HEADgit revert ^Mgit merge topic reset与checkout的区别 因为checkout也是操纵这三棵树，所以有必要了解下他们之间的区别 快速合并与三方合并策略快速合并我们在合并2个分支的时候，经常看到如下信息1234Updating 44bc42f..a65dae0Fast-forward test.txt | 13 ------------- 1 file changed, 13 deletions(-) 如果一个分支和它的源分支没有存在支路，如上图。就是说iss53分支从master分支上切出来之后，并且在iss53上做了几次提交，但是在这期间master分支并未有新的提交合并，那么此时将iss53分支合并到master分支采用的就是Fast-forward策略。 三方合并策略 将几个分支的共同祖先节点和每个分支最后提交的节点进行一个合并。 我们在合并2个分支的时候，也会经常看到如下信息123Merge made by the 'recursive' strategy. test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 如上图，topic分支从master分支C2切出来，然后做了C3,C4的提交，在此期间，master分支也有C5，C6的提交合并，那么此时将topic分支合并到master分支就会采用三方合并的策略。 ours和theirs冲突合并策略 合并分支，偶有遇到冲突在所难免，git通常让你自己手动解决冲突后再进行一个合并。但是也提供了一些其他快速解决冲突的方案。 比如，2个人同时修改了某一个文件，那么在合并的时候就会遇到冲突，但是我只想保留某一方的提交。那么此时我们就可以使用ours和theirs策略。 如：将topic分支合并到master分支存在冲突12345// 保留master分支上的代码git merge -Xours topic// 保留topic分支上的代码git merge -Xtheirs topic git grep搜索 从提交历史或者工作目录中查找一个字符串或者正则表达式git grep -n fmtDate 几个常用的底层命令 git hash-object 将数据写入到git数据库中 git cat-file 从git数据库中取出数据 git update-index 将文件加入到暂存区或更新暂存区的文件 git write-tree 将暂存区内容写入到一个树对象 git read-tree 把树对象读入暂存区 git commit-tree 创建一个提交对象 git update-ref 更新某个引用 git symbolic-ref HEAD 查看 HEAD 引用对应的值 git symbolic-ref HEAD refs/heads/test 设置HEAD引用的值 几种常见的对象 blob object: 数据对象 tree object: 树对象 commit object: 提交对象 tag object: 标签对象，类似于提交对象，但是标签对象通常指向一个提交对象，而不是一个树对象 几个git文件的合法模式 100644: 普通文件 100755: 可执行文件 120000: 符号链接","categories":[{"name":"git","slug":"git","permalink":"https://xxxxxmiss.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xxxxxmiss.github.io/tags/git/"}]},{"title":"web-components","slug":"web-components","date":"2017-08-12T16:07:36.000Z","updated":"2017-08-13T17:49:04.000Z","comments":true,"path":"2017/08/13/web-components/","link":"","permalink":"https://xxxxxmiss.github.io/2017/08/13/web-components/","excerpt":"","text":"Web Components(web组件) web组件是一种可以复用的html单元，他是浏览器的一部分，所以不需要引入额外的库来使用他。Web Components技术主要由以下4部分组成，但是每一部分都可以单独使用 Custom Elments(自定义元素) HTML Templates(html模板) Shadow DOM HTML Imports1&lt;link rel=\"import\" href=\"myfile.html\"&gt; Custom Elements 自定义元素提供了一种可以让你创建自定义html元素的能力。它也是web componnets技术的组成部分，但是你也可以独立使用它们。自定义元素有着自己的生命周期，这就意味着你可以在不同的生命周期阶段通过脚本绑定不同的行为。例如，当它们被插入到dom中（connected），当它们从dom中移除时（disconnected），又或者它们的特性发生改变的时候（attributeChanged），你都可以在相应的时期做你想做的事情。 自定义元素的方法constructor() 当元素被创建或者更新的时候调用 connectedCallback() 当元素被插入到文档流中或者被插入到shadow dom中的时候调用 disconnectedCallback() 当元素从文档流中移除的时候调用 attributeChangedCallback(attributeName, oldValue, newValue, namespace) 当元素被观察的特性被改变，被追加，被移除，被取代的时候调用 adoptedCallback(oldDocument, newDocument) 当元素被插入到一个新的文档流中的时候调用 自定义元素更多的时候我们采用es6类语法来进行创建：123456&lt;template id=\"custom\"&gt; &lt;div&gt;第一行&lt;/div&gt; &lt;div&gt;第二行&lt;/div&gt;&lt;/template&gt;&lt;my-element name=\"test\" id=\"test\"&gt;&lt;/my-element&gt; 1234567891011121314151617class MyElement extends HTMLElement&#123; constructor()&#123; // 一定要记得先调用父类构造器,因为我们在子类的构造器中使用了this // 否则就报错 super() var tplContent = document.getElementById('custom').content var shadowRoot = this.attachShadow(&#123; mode: 'open' &#125;) shadowRoot.appendChild(tplContent) &#125; connectedCallback()&#123; console.log('自定义元素被插入到shadow dom中') &#125;&#125;customElements.define('my-element', MyElement) Observed attributes 如果要使用自定义元素的attributeChangedCallback来观察自定义元素特性的变化，那么必须在初始化自定义元素的构造器中列出需要观察的特性–在类中使用静态的get存取器列出需要观察的特性。 改造上面的例子：1234567891011121314151617181920212223242526272829303132class MyElement extends HTMLElement&#123; constructor()&#123; // 一定要记得先调用父类构造器,因为我们在子类的构造器中使用了this // 否则就报错 super() var tplContent = document.getElementById('custom').content var shadowRoot = this.attachShadow(&#123; mode: 'open' &#125;) shadowRoot.appendChild(tplContent) &#125; static get observedAttributes()&#123; return ['name'] &#125; attributeChangedCallback(attr, oldValue, newValue)&#123; console.log('oldValue: ', oldValue) console.log('newValue: ', newValue) if('name' === attr)&#123; this.textContent = `Hello, $&#123;newValue&#125;` &#125; &#125; connectedCallback()&#123; console.log('自定义元素被插入到shadow dom中') &#125;&#125;customElements.define('my-element', MyElement)setTimeout(function()&#123; document.getElementById('test').setAttribute('name', 'ggsmd')&#125;, 5000) 控制台输出如下：1234567// 初始化的时候输出oldValue: testnewValue: null// 5s之后输出oldValue: testnewValue: ggsmd HTML Templates 元素中的内容在页面加载的时候并不会渲染，但是你可以通过js来操作其中的内容。你可以认为元素中保存了你接下来要使用的内容片段，在页面加载的时候，解析引擎并不处理中内容，也不做任何渲染，引擎只确保中的内容是否有效。 123456789101112131415161718&lt;table id=\"producttable\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;UPC_Code&lt;/td&gt; &lt;td&gt;Product_Name&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- existing data could optionally be included here --&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;template id=\"productrow\"&gt; &lt;tr&gt; &lt;td class=\"record\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/template&gt; 12345678910111213141516171819// 检查浏览器是否支持template元素if('content' in document.createElement('template'))&#123; var t = document.querySelector('#productrow') , td = t.content.querySelectorAll('td') td[0].textContent = 'AAAA' td[1].textContent = 'BBBB' var tbody = document.querySelector('tbody') , clone = document.importNode(t.content, true) tbody.appendChild(clone) // 复用template元素中的内容 td[0].textContent = '1111' td[1].textContent = '2222' var clone2 = document.importNode(t.content, true) tbody.appendChild(clone2)&#125;else&#123; // 不支持的浏览器可以引入polyfill&#125; HTMLTemplateElement接口 通过HTMLTemplateElement接口，我们可以操作元素中的内容 上图是HTMLTemplateElement接口的继承图，也就是说HTMLTemplateElement继承了HTMLElement上所有的属性和方法。 HTMLTemplateElement特有的一个属性HTMLTemplateElement.content：只读的属性返回值：返回元素中的内容，是一个DocumentFragment 123&lt;template id=\"test\"&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt; 12document.querySelector('#test').content.nodeType === 11// true Shadow DOM Shadow DOM为Web Components中的DOM, CSS提供了一个包装。Shadow DOM将Web Components中的DOM, CSS和文档流中的dom进行了一个隔离。因为一个大型网页，如果前期css组织的不合理，就会导致css各种覆盖，从而使网页样式变得难以把控。通过shadow dom，可以进行一个隔离。它是Web Components技术的一部分，但是你也可以单独使用它们。 基本的使用 shadow dom必须被绑定到某一个存在的元素上，这个元素可以是html文档流中已经存在的元素，也可以是通过js创建的元素(包括自定义元素)。 12345678910&lt;body&gt; &lt;p id=\"hostElement\"&gt;&lt;/p&gt; &lt;script&gt; // 此时shadow dom还是空的，没有内容 var shadow = document.querySelector('#hostElement') .attachShadow(&#123; mode: 'open' &#125;) // 往shadow dom中添加内容 shadow.innerHTML = '&lt;span&gt;Here is some new text&lt;/span&gt;' &lt;/script&gt;&lt;/body&gt; shadow dom的样式 继续接着上面的例子，如果我们需要给shadow dom添加样式。就跟我们平时使用内联样式一样，只不过将style标签极其里面的样式全部作为shadow dom的innerHTML。如下： 1shadow.innerHTML = '&lt;style&gt;span &#123; color: red; &#125;&lt;/style&gt;' shadow dom相关API1var shadowRoot = element.attachShadow(shadowRootInit) 绑定一个shadow dom树到一个指定的元素上，并且返回ShadowRoot的引用。shadowRoot也是一个文档片段。 shadowRoot.nodeType === 11 shadowRootInit是一个如下的对象：1234&#123; mode: 'open' // mode: 'closed'&#125; open: 指定开放的包裹模式，这就意味着在外面可以使用element.shadowRoot来访问shadow dom中的内容。 12element.shadowRoot === shadowRoot(通过attachShadow返回的shadowRoot的引用)// true closed: 指定为闭合的包裹模式，这就意味着在外面无法使用任何方法来访问shadow dom中的内容。 1234element.shadowRoot === shadowRoot(通过attachShadow返回的shadowRoot的引用)// falseelement.shadowRoot === null// true ShadowRoot接口ShadowRoot.mode 只读，返回值为’open’或者’closed’ ShadowRoot.host 只读，返回shadow dom的宿主元素 ShadowRoot.innerHTML 返回ShadowRoot内部的dom树 slot元素 slot, 翻译为“插槽”。slot元素也是web components技术的一个组成单元：他是web components内的一个占位符，通过这个占位符，你可以在接下来使用的web组件内插入自己想要的标签。slot元素一般情况下和template元素组合使用。 Attributes（特性） slot元素和其他的html元素一样，有着一些通用的属性，比如style,class等，具体有哪些，可以参看这里 Attributes之name特性 给slot元素添加一个名字，因为一个web组件内部可能有多个slot,可以用name特性加以区分。没有添加name特性的slot元素，可以理解为name=&quot;&quot;。在Vue框架中，也有内置的slot组件，它实现的功能和标准web components中的slot元素是一样的。但在Vue中，没有添加name特性的slot组件，相当于name=&quot;default&quot;。 1234&lt;template id=\"slot-template\"&gt; &lt;div&gt;这是一段文本&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;p&gt;&lt;slot name=\"another\"&gt;&lt;/slot&gt;这是另外一段文本&lt;/p&gt;&lt;/template&gt; 12345var slots = document.querySelector('#slot-template') .content.querySelectorAll('slot')Array.from(slots).forEach(s =&gt; console.log(s.name))// \"\"// another","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"share-vue","slug":"share-vue","date":"2017-08-12T04:30:54.000Z","updated":"2017-08-13T17:49:01.000Z","comments":true,"path":"2017/08/12/share-vue/","link":"","permalink":"https://xxxxxmiss.github.io/2017/08/12/share-vue/","excerpt":"","text":"目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100├── README.md├── build│ ├── build.js│ ├── check-versions.js│ ├── dev-client.js│ ├── dev-server.js│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ ├── webpack.prod.conf.js│ └── webpack.test.conf.js├── config│ ├── dev.env.js│ ├── index.js│ ├── prod.env.js│ └── test.env.js├── deploy.sh├── dist│ ├── email_tpl│ │ ├── template.html│ │ ├── template_h5.html│ │ └── template_h5_2.html│ ├── index.html│ └── static│ ├── css│ ├── fonts│ ├── img│ └── js├── index.html├── npm-debug.log├── package-lock.json├── package.json├── src│ ├── App.vue│ ├── assets│ │ └── js│ ├── components│ │ └── modal│ ├── config.js│ ├── filters│ │ └── index.js│ ├── main.js│ ├── router│ │ └── index.js│ ├── views│ │ ├── Edm-Item.styl│ │ ├── Edm-Item.vue│ │ ├── EdmProgress-Item.styl│ │ ├── EdmProgress-Item.vue│ │ ├── EdmProgress.styl│ │ ├── EdmProgress.vue│ │ ├── H5Progress-Item.styl│ │ ├── H5Progress-Item.vue│ │ ├── Index.styl│ │ ├── Index.vue│ │ ├── Share-Item.styl│ │ ├── Share-Item.vue│ │ ├── Signin.styl│ │ ├── Signin.vue│ │ ├── Tags-Item.styl│ │ ├── Tags-Item.vue│ │ ├── Task-H5.styl│ │ ├── Task-H5.vue│ │ ├── Task-Send.styl│ │ ├── Task-Send.vue│ │ ├── Task.styl│ │ ├── Task.vue│ │ ├── Tpl-H5.styl│ │ ├── Tpl-H5.vue│ │ ├── Uploadlogo-Item.styl│ │ └── Uploadlogo-Item.vue│ └── vuex│ ├── getters.js│ ├── mutations.js│ └── store.js├── static│ ├── css│ │ └── base.css│ ├── email_tpl│ │ ├── template.html│ │ ├── template_h5.css│ │ ├── template_h5.html│ │ ├── template_h5_2.css│ │ └── template_h5_2.html│ └── img│ ├── test│ ├── e2e│ │ ├── custom-assertions│ │ ├── nightwatch.conf.js│ │ ├── runner.js│ │ └── specs│ └── unit│ ├── index.js│ ├── karma.conf.js│ └── specs├── test.txt├── yarn-error.log└── yarn.lock 一个快速查看文档的npm命令1npm docs &lt;package-name&gt; 环境配置 开发环境 1process.env.NODE_ENV === 'development' 测试环境 1process.env.NODE_ENV === 'test' 生产环境 1process.env.NODE_ENV === 'production' 跨域处理 浏览器同源策略：同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 一个源的定义：如果协议，端口（如果指定了一个）和域名对于两个页面是相同的，则两个页面具有相同的源 一个URL的组成部分 使用jsonp跨域 只能发送GET请求，但是支持老的浏览器 使用html5 CORS跨域 Access-Control-Allow-Origin: ‘*’(required) 可设置为origin或者origin下具体的某一个path Access-Control-Allow-Credentials: true(optional) 表示是否允许发送cookie Access-Control-Expose-Headers: X-Field(optional) CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘X-Field’)可以返回X-Field字段的值。 client:1234567891011var myRequest = new Request('http:127.0.0.1:8080/get-list', &#123; method: 'GET', // no-cors, cors, same-origin, navigate mode: 'same-origin' // 默认值，所以不是同源策略就会出现跨域&#125;)fetch(myRequest).then(res =&gt; &#123; return res.json()&#125;).then(json =&gt; &#123; console.log(json)&#125;) server:1234567891011const http = require('http')const server = http.createServer((req, res) =&gt; &#123; // res.setHeader('Access-Control-Allow-Origin', '*') res.end(JSON.stringify(&#123; name: 'javascript', price: 50 &#125;))&#125;)server.listen(8080, _ =&gt; &#123; console.log('server has setup, listening at port: 8080') &#125;) 代理123proxyTable: &#123; '/api': 'http://edmserver.cheng95.com'&#125; js设计模式之publish/subscribe 解耦具体的业务代码和组件/插件内部的代码。一个弹出层，有确定，取消2个按钮，组件内部帮我们实现好的效果是：点击确定，取消2个按钮，弹出层都会消失，但是点击确定按钮的时候，我们要实现一些自己的业务逻辑。比如点击确定的时候，发送一个请求到后台。通过publish/subscribe就可以很好的实现这种组件/插件内部的代码和我们自己具体的业务代码相分离。 vue源码位置：src/core/instance/events.js vue组件通信父子组件通信 因为vue使用的单向数据流（数据只能从父组件流向子组件），所以子组件不能直接修改从父组件传递过来的props，如果要修改，必须通过事件的形式。 vm.$on vm.$once vm.$emit vm.$off 兄弟组件通信 组件之间没有父子关系，常用解决方案：Event Bus(事件总线)，就是通过一座桥梁将没有关系的组件联系起来。其实根组件就是他们之间的这座桥梁，但是根组件上默认已经挂载了很多东西，所以一般情况下会使用一个空的Vue实例来充当这个事件总线。 例如2个兄弟组件，一个按钮，一个段落，通过点击按钮来修改段落中的文字1234&lt;div id=\"app\"&gt; &lt;x-button&gt;&lt;/x-button&gt; &lt;c&gt;&lt;/c&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132const vm = new Vue()Vue.component('x-button', &#123; data()&#123; return &#123; count: 1 &#125; &#125;, template: '&lt;button @click=\"setMsg\"&gt;测试按钮&lt;/button&gt;', methods: &#123; setMsg()&#123; vm.$emit('set-msg', `count is: $&#123;this.count++&#125;`) &#125; &#125;&#125;)Vue.component('c', &#123; data()&#123; return &#123; msg: '这是默认值' &#125; &#125;, template: '&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;', created()&#123; vm.$on('set-msg', msg =&gt; &#123; this.msg = msg &#125;) &#125;&#125;)const app = new Vue(&#123; el: '#app'&#125;) 使用vuex来管理app数据 vuex是用来管理整个应用的数据，vuex中的数据可以被任何组件访问。所以vuex也是组件之间通讯的一种方案，至于到底用不用vuex，哪些数据要放到vuex中管理，取决于具体情况。 .native修饰符 vue组件之间的通信，可以通过事件系统，但这些事件并不是原生的事件。dom操作离不开原生事件，vue提供了.native修饰符来绑定原生事件（内部使用addEventListener）。对于刚刚接触vue的人来说，可能思想难以转变，喜欢直接操作dom。通过.native修饰符，我们可以像vm.$on一样来绑定原生事件。 假如在登录的时候，既可以通过点击登录按钮进行登录，也可以通过敲击enter键进行登录, html代码如下：12345678910&lt;el-form-item&gt; &lt;el-input type=\"password\" ref=\"password\" v-model=\"password\" placeholder=\"请输入密码\"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item&gt; &lt;el-button type=\"primary\" size=\"large\" @click.prevent=\"signin\" :disabled=\"!signinBtnActive\"&gt;登录&lt;/el-button&gt;&lt;/el-form-item&gt; 很多时候，你可能会这样来绑定事件12345this.$refs.password.$el.addEventListener('keyup', e =&gt; &#123; if(e.keyCode === 13)&#123; this.signin() // 登录操作 &#125;&#125;) 其实vue提供了.native修饰符来绑定原生事件，提供了.enter修饰符来表示按的键是enter键，所以我们可以用更加优雅的方式来书写：12&lt;el-input type=\"passowd\" v-model=\"password\" @keyup.native.enter=\"signin\"&gt;&lt;/el-input&gt; ES6代码风格npm推荐的代码风格 documents vue vue-router vuex stylus axios webpack2 ElementUI http-proxy-middleware CORS跨域","categories":[{"name":"vue","slug":"vue","permalink":"https://xxxxxmiss.github.io/categories/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"},{"name":"frontend-framework","slug":"frontend-framework","permalink":"https://xxxxxmiss.github.io/tags/frontend-framework/"}]},{"title":"zeroclipboard","slug":"zeroclipboard","date":"2017-07-30T05:57:51.000Z","updated":"2017-07-30T08:06:26.000Z","comments":true,"path":"2017/07/30/zeroclipboard/","link":"","permalink":"https://xxxxxmiss.github.io/2017/07/30/zeroclipboard/","excerpt":"","text":".main-view{ display: flex; } .label{ border-bottom: 1px solid #AECDE9; } .one-half{ flex: 1; display: inline-block; padding-left: 10px; padding-right: 10px; } textarea{ width: 100%; border-radius: 8px; color: #4A4A4A; padding: 10px; border: 1px solid #979797; outline: none; box-sizing: border-box; } textarea:hover, textarea:focus{ border: 1px solid #20a0ff; } .btn-clipboard{ background-color: #fff; color: #5D9CD4; border: 1px solid #979797; border-radius: 8px; padding: 8px 20px; font-weight: 400; outline: none; cursor: pointer; } .btn-clipboard.zeroclipboard-is-hover { background: #3077B5; border: 1px solid #3077B5; color: #fff; text-decoration: none; } .btn-container{ text-align: right; } ZeroClipboard.js简介 是一个非常好用的用于复制文本到剪切板的，它的工作原理就是在你要点击的按钮上覆盖一个透明的flash。所以你点击复制按钮，其实点击的是透明的flash，先将要拷贝的文本复制到flash，在将flash中的文本复制到剪切板。 注意： 由于考虑到安全性问题，ZeroClipboard需要工作在服务器上，也就是说你必须启动一个服务器（不管是本地服务，还是远程服务）。 引入ZeroClipboard.js的同时，需要在相同的文件夹下放置ZeroClipboard.swf。如果ZeroClipboard.swf没有放在和ZeroClipboard.js相同的文件夹下，需要手动配置。 当你hover要点击的按钮时，ZeroClipboard默认会在按钮上添加zeroclipboard-is-hover样式 当你激活按钮时，ZeroClipboard默认会在按钮上添加zeroclipboard-is-active样 所以当你需要为按钮添加hover或者active样式时，可以重写这两个样式。 123ZeroClipboard.config(&#123; swfPath: \"../path/new/\" &#125;) 要拷贝的文本 copy me 拷贝文本 黏贴到这里 清空 var client = new ZeroClipboard(document.getElementById('btn-clipboard')) client.on('ready', function(readyEvent){ alert('ZeroClipboard SWF is ready!') }) document.getElementById('btn-clear').addEventListener('click', function(){ document.getElementById('textarea').value = '' }) 详细用法参考这里","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"nodejs-cluster","slug":"nodejs-cluster","date":"2017-07-15T16:44:48.000Z","updated":"2017-07-16T03:28:00.000Z","comments":true,"path":"2017/07/16/nodejs-cluster/","link":"","permalink":"https://xxxxxmiss.github.io/2017/07/16/nodejs-cluster/","excerpt":"","text":"Cluster 一个Node实例运行在一个单线程中。为了高效的利用多核系统，用户有时候需要启动一个Node进程的集群去处理负载。通过cluster模块很容易的创建一些共享服务端口的子进程。 How It Works(它是如何工作的) work进程通过child_process.fork()方法复制而来，因此它可以和父进程之间通过IPC信道交流，并且在他们之间来来回回的传递服务句柄。cluster模块支持2种方法分发到来的连接。第一种方法（默认的方法，支持所有的平台，除了windows平台），轮询法，由master进程监听一个端口，接受新的连接，然后将这些连接分发到work进程。在分发中使用了一些内置的技巧防止work进程人任务过载。第二种方法就是master进程创建监听的socket，然后发送到感兴趣的work进程，work进程直接接收到来的连接。理论上，第二种方法有着更好的性能。但是在实践中，由于操作系统的调度机制的变化莫测，分发极度的不平衡。 由于已经发布了官方的中文文档，接下来的文档不在翻译了…","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"}]},{"title":"event-loop(事件循环)","slug":"event-loop","date":"2017-07-14T02:58:29.000Z","updated":"2017-07-16T12:17:55.000Z","comments":true,"path":"2017/07/14/event-loop/","link":"","permalink":"https://xxxxxmiss.github.io/2017/07/14/event-loop/","excerpt":"","text":".list li{ list-style-type: decimal; } 2个名词 microtask: 称之为小型任务 macrotask（task queue）: 称之为大型任务 事件循环模型 当执行栈（call stack）为空时，一个事件循环会按照下面的步骤进行： 从macrotask队列中选择最老一个任务taskA 如果taskA不存在，即macrotask队列是空的，那么进行步骤6 设置当前运行的任务为taskA 运行taskA(即执行taskA它的回调函数) 设置当前运行的任务为空，并从macrotask中移除taskA 开始处理microtask (a)从microtask中选择最老的任务taskX (b)如果taskX不存在，即microtask是空的，那么跳到步骤(g) (c)设置当前运行的任务为taskX (d)运行taskX(即执行taskX的回调函数) (e)设置当前运行的任务为空，并从microtask中移除taskX (f)从microtask选择下一个最老的任务，步骤(b) (g)重复以上步骤，直到microtask中的任务全部执行完毕 继续回到步骤1 精简的概括就是： 先从macrotask队列中选择最老的一个任务开始执行，然后移除这个最老的任务 再执行microtask队列中所有的任务，然后移除他们 继续下一轮，重复以上2步 需要知道的一些事情： 当一个macrotask任务正在运行的时候，新的事件可以被注册，也即创建新的任务。例如： promiseA.then()的回调是一个任务 promiseA如果处于resolve/reject状态时，那么该任务被推到事件循环的当前轮次的microtask中 promiseA处于pending状态时，那么该任务将会被推到事件循环的下一个轮次的microtask中。 setTimeout(callback, n)的回调是一个任务，将会被推到macrotask中，及时n=0。 如果事件循环正在执行microtask中的任务，那么你可以继续往microtask中添加任务，这些任务都会在本轮次的循环中执行。 只有等到本轮次的microtask中的所有任务执行完毕，才会执行下一轮的macrotask任务。 常见的microtask任务：process.nextTick,Promise, Object.observe, MutationObserver 常见的macrotask任务：setTimeout,setInterval, setImmediate,Dom事件（click, scroll, mouseup等）， ajax，I/O, UI rendering等。还需要注意的是，整个的脚本也是一个macrotask任务。 经过上面的分析，可以看如下例子输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546console.log('script start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout1') Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;).then(() =&gt; &#123; console.log('promise4') &#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout2') Promise.resolve().then(() =&gt; &#123; console.log('promise5') &#125;).then(() =&gt; &#123; console.log('promise6') &#125;).then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;) &#125;)&#125;)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;).then(() =&gt; &#123; console.log('promise2')&#125;)// script start// promise1// promise2// setInterval// setTimeout1// promise3// promise4// interval// setTimout2// promise5// pormise6 call stack(执行栈)与event loop(事件循环)之间的关系 为了形象的表示，可以参看下图： 关于他们之间的关系的说明，此处就不在叙述了，具体可以参看这里 参考文章如下：microtask and macrotaskevent looptask-queue speccall stack","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"},{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"nodejs-process","slug":"nodejs-process","date":"2017-07-12T15:00:05.000Z","updated":"2017-07-16T12:19:25.000Z","comments":true,"path":"2017/07/12/nodejs-process/","link":"","permalink":"https://xxxxxmiss.github.io/2017/07/12/nodejs-process/","excerpt":"","text":"Process Events(进程事件) process对象是EventEmitter的一个实例 beforeExit 当Node清空事件队列并且没有额外的任务加入到事件队列中，触发该事件。通常情况下，当没有额外的任务加入到事件队列中时，Node进程会自动退出。但是如果’beforeExit’事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。 process.exitCode 作为唯一的参数值传递给’beforeExit’事件监听器的回调函数。 如果进程由于显式的原因而将要终止，例如直接调用process.exit()或抛出未捕获的异常，’beforeExit’事件不会被触发。 除非本意就是需要添加额外的工作(比如通过监听器进行异步调用)到事件循环数组，否则不应该用’beforeExit’事件替代’exit’事件。 disconnect 如果一个进程是通过IPC信道的方式spawned出来的，那么当IPC信道关闭的时候触发该事件。 exit 当Node进程是由于以下2中情况之一导致退出的时候，会触发该事件： 显示的调用process.exit() 事件循环队列中不再有额外的任务去做的时候 一旦到达Node进程即将退出这个点的时候，是没有办法去阻止进程退出的。当exit事件上所有的监听器都执行完毕的时候，进程就会自动退出。该事件的监听器会接受唯一的一个参数, 该参数来自process.exitCode或者来自传入到process.exit()中的code 123process.on('exit', code =&gt; &#123; console.log(`About to exit with code: $&#123;code&#125;`) &#125;) 因为一旦到达Node进程即将退出这个点，是没有办法阻止进程退出的。所有该事件的监听器中所做的操作都应该是同步的操作，任何在事件循环中排队的工作都会被强制丢弃。例如在下例中，timeout操作永远不会被执行(因为不是同步操作)。 123456process.on('exit', code =&gt; &#123; // 异步任务是不会被执行的 setTimeout(() =&gt; &#123; console.log('This will not run') &#125;)&#125;) message 当一个Node进程是通过IPC信道的方式spawned出来的，那么当父进程通过childprocess.send()方法发送信息到该子进程的时候，就会触发该事件。 1process.on('message', (message, sendHandle) =&gt; &#123;&#125;) 回调会接受2个参数： message：一个解析过的JSON对象或者一个原始值 sendHandle： net.Socket或者net.Server或者undefined uncaughtException 当事件队列在循环的过程中，遇到一个未能捕获的JS异常的时候，沿着代码调用路径反向传递回event loop，就会触发该事件。默认情况下，Node处理这样的异常是将追踪栈中的信息打印到标准的错误流中，然后退出。如果给该事件添加了自己的监听器，那么会改写默认行为。 1234567891011// 回调接受唯一的一个Error对象process.on('uncaughtException', err =&gt; &#123; fs.writeSync(1, `Caught Exception: $&#123;err&#125;\\n`) &#125;)setTimeout(() =&gt; &#123; console.log('This will still run')&#125;, 500)nonexistentFun()console.log('This will not run') Warning: 正确的使用uncaughtException事件 该事件一般仅用着处理异常的最后的手段，因为它处理异常的机制是非常粗糙的。 此事件不应该当作出了错误就恢复让它继续的等价机制。 未处理异常本身就意味着应用已经处于了未定义的状态。如果基于这种状态，尝试恢复应用正常进行，可能会造成未知或不可预测的问题。此事件的监听器回调函数中抛出的异常，不会被捕获。为了避免出现无限循环的情况，进程会以非0的状态码结束，并打印堆栈信息。正确的使用uncaughtException应该是在进程关闭之前做一些相关的资源清理工作（比如文件描述符，句柄等），而不应该是出现了uncaughtException异常之后做一些让应用恢复工作的事情，因为这样是不安全的。 想让一个已经崩溃的应用正常运行，更可靠的方式应该是启动另外一个进程来监测/探测应用是否出错， 无论uncaughtException事件是否被触发，如果监测到应用出错，则恢复或重启应用。 Signal Events（信号事件） 当Node进程接受到信号时，就会触发相应的信号事件。每个事件名称，以信号名称的大写表示 (比如事件’SIGINT’ 对应信号 SIGINT). 12345process.stdin.resume()process.on('SIGINT', () =&gt; &#123; console.log('Received SIGINT. Press Control-D to exit.')&#125;) 在大多数的终端上发出SIGINT信号最简单的方式就是按下Ctrl+C键。所以上面的例子中，当你按下Ctrl+C后，就会触发SIGINT事件，输出’Received SIGINT. Press Control-D to exit.’，当你在按下Ctrl+D时，进程退出。 以下有很重要的几点需要牢记： SIGUSR1是Node用来启动debugger程序的。可以为此事件绑定一个监听器，但是即使这样做也不会阻止调试器的启动。 SIGTERM和SIGINT在非windows平台上，有默认的监听器，这样进程在携带128 + signal number退出码退出之前，可以重置终端模式。如果给他们添加了自己的监听器，那么默认行为就会被移除。（Node进程不会退出） SIGPIPE默认是被忽略的，但是你也可以给它添加监听程序。 SIGHUP,在windows平台上，当console窗口被关闭时，触发该事件。在其他平台上有着不同的行为，可以参看这里。可以对该信号添加监听器，及时添加了监听器，在windows平台上，大约10秒之后Node会无条件的终止。在非windows平台上个，SIGHUP信号默认行为是终止Node,如果添加了自己的监听器，那么默认行为就会被移除。 SIGTERM,windows平台不支持，可以给其添加监听器。 SIGINT,所有的平台都支持。一般情况下按下Ctrl+C（当然你可以配置成其他快捷方式是）就会发出该信号。但是如果终端的raw模式被激活，那么就不会发出该信号。 SIGBREAK,在windows平台上按下Ctrl+Break就会传递该信号。在非windows平台上，可以对其添加监听器，但是没有方式触发或发送此事件。 SIGWINCH,当console窗口大小发生改变的时候，就会触发该信号。在windows平台上，仅仅发生在当在console有写入并且光标发生移动的时候才会触发该信号，或者一个可读tty被用在raw模式。 SIGKILL，无法对其添加监听器，在所有的平台上，他都会无条件终止Node。 SIGTOP，无法对其添加监听器。 Note:windows平台不支持发射信号，但是Node通过process.kill(),ChildProcess.kill()提供了某些模拟机制。 发射信号0可以用来测试一个进程的存在与否。 发射SIGINT,SIGTERM,SIGKILL可以无条件的终止目标进程。 process.abort() 该方法可以迅速的终止Node进程，并且产生一个core file prcess.arch(architecture)return: &lt;string&gt; 该属性返回当前正在运行的Node进程的处理器结构标识，如arm,ia32,x64 process.argvreturn: &lt;Array&gt; 返回当Node进程启动的时候在命令行传入的参数的数组。数组的第一个元素就是process.execPath的值。数组的第二个元素是被执行的文件的绝对路径。余下的参数就是传入命令的其他的参数。 process-args.js123process.argv.forEach((val, index) =&gt; &#123; console.log(`$&#123;index&#125;: $&#123;val&#125;`) &#125;) 这样启动：1$ node process-args.js one two=three four 输出结果如下：123450: /usr/local/bin/node1: /Users/qsch/workspace/tools/process-args.js2: one3: two=three4: four process.execPath 返回启动Node进程的可执行程序的绝对路径, &#39;/usr/local/bin/node&#39; process.argv0return: &lt;string&gt; process.channel 如果一个进程是通过IPCspawned出来的，那么process.channel属性返回IPC信道的引用。如果没有IPC信道存在，那么返回undefined。 process.chdir(directory)directory: &lt;string&gt; process.chdir()方法改变当前Node进程所在的工作目录。如果操作失败（如指定的directory不存在），那么抛出一个异常。 1234567console.log(`Starting directory: $&#123;process.cwd()&#125;`);try &#123; process.chdir('/tmp'); console.log(`New directory: $&#123;process.cwd()&#125;`);&#125; catch (err) &#123; console.error(`chdir: $&#123;err&#125;`);&#125; process.connectedreturn: &lt;boolean&gt; 如果一个Node进程是通过IPC信道spawned出来的，那么只要主进程和spawned出来的进程的IPC信道是链接的，那么返回true。如果调用process.disconnect()那么该属性就返回false.一旦process.connected返回false，那么就不能再通过process.send()基于IPC信道发送消息。 process.cpuUsage([previousValue])previousValue: 上一次调用此方法process.cpuUsage()的返回值return: &lt;Object&gt; user: &lt;integer&gt; system: &lt;integer&gt; process.cpuUsage()方法返回包含当前进程的用户CPU时间和系统CPU时间的对象。此对象包含user和system属性，属性值的单位都是微秒(百万分之一秒)。 user和system属性值分别计算了执行用户程序和系统程序的时间，如果此进程在执行任务时是基于多核CPU，值可能比实际花费的时间要大。 上一次调用process.cpuUsage()方法的结果，可以作为参数值传递给此方法，得到的结果是与上一次的差值。 123456789const startUsage = process.cpuUsage();// &#123; user: 38579, system: 6986 &#125;// spin the CPU for 500 millisecondsconst now = Date.now();while (Date.now() - now &lt; 500);console.log(process.cpuUsage(startUsage));// &#123; user: 514883, system: 11226 &#125; process.cwd() 返回当前Node进程所在的工作目录。 prcess.disconnect() 如果一个Node进程是通过IPC信道spawned出来的，那么该方法会关闭该进程和父进程之间的IPC信道。当没有更多的链接时，当前子进程就会优雅的退出。调用当前进程的process.disconnect()方法和调用父进程的ChildProcess.disconnect()起到的想过是一样的。如果某个进程不是通过IPC信道spawned出来的，那么process.disconnect属性是undefined。 process.envreturn: &lt;Object&gt; 返回一个包含当前用户环境的对象 这个对象的形式看起来可能如下：123456789101112&#123; TERM: 'xterm-256color', SHELL: '/usr/local/bin/bash', USER: 'maciej', PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin', PWD: '/Users/maciej', EDITOR: 'vim', SHLVL: '1', HOME: '/Users/maciej', LOGNAME: 'maciej', _: '/usr/local/bin/node'&#125; Note:分配到process.env上的任何属性都会隐式的转化为字符串。 12345process.env.test = nullconsole.log(process.env.test) // 'null'process.env.test = undefinedconsole.log(typeof process.env.test) // 'string' 可以通过delete操作符来删除process.env上的属性：123process.env.TEST = 1delete process.env.TESTconsole.log(process.env.TEST) // undefined 在windows平台上，环境变量大小写不敏感：12process.env.TEST = 1console.log(process.env.test) // '1' process.execArgvreturn: &lt;Object&gt; 返回当Node进程启动的时候传入到命令行中的Node.js特定的命令行选项。这些特定选项不会出现在process.argv属性返回的数组中。process.execArgv返回的数组不包括Node可执行程序，执行当前脚本的名称和跟随在脚本名称后面的选项。这些选项非常的有用，当spawned一个进程的时候，可以通过它保证spawned出来的子进程和父进程保持一致的环境。 1$ node --harmony script.js --version 那么process.execArgv返回：1['--harmony'] 而process.argv返回：1['/usr/local/bin/node', 'script.js', '--version'] process.exit([code])code: &lt;integer&gt; ,退出码，默认为0 该方法告诉Node同步的终止进程并且携带一个退出码。如果没有传入code参数，那么默认使用代表成功的code0，或者使用process.exitCode(如果你曾经设置过)。当exit上的监听器全部执行完毕后，Node终止。 Note: 调用process.exit()强制进程尽可能快的退出，即使有一些异步的工作还没有完全执行完毕，包括process.stdout, process.stderr的I/O操作。 在大多数的时候，，没有必要显示的调用process.exit()。Node进程会自动退出，当事件循环中没有更多的工作加入。可以通过设置process.exitCode来告诉进程当优雅的退出时使用什么样的状态码。 如下面的process.exit()错误用法演示了可能导致输出到标准输出的数据被切断和丢失：1234if (someConditionNotMet()) &#123; printUsageToStdout(); process.exit(1);&#125; 上面的用法有问题的原因就是：写入数据到process.stdout中的操作有可能是异步的操作，调用process.exit()会强制进程在这些异步完成之前就退出了。 不应该直接调用process.exit()方法，正确的做法应该是设置process.exitCode,这样就可以进程自然的退出，避免在安排一些额外的工作进入到事件循环中。 正确的做法：1234if (someConditionNotMet()) &#123; printUsageToStdout(); process.exitCode = 1&#125; 如果因为发生了错误，抛出一个未捕获的错误，需要退出进程，通过设置process.exitCode要比直接调用process.exit()安全的多。 process.exitCodereturn: &lt;integer&gt; 进程退出的时携带的状态码。调用process.exit()时指定了退出码，那么该退出码会覆盖之前通过process.exitCode设置的值。那么此时通过process.exitCode获取到的值就是process.exit(code)中指定的code。 process.kill(pid[,signal])pid: &lt;number&gt;,进程IDsignal: &lt;string&gt;|&lt;number&gt;,发射的信号，既可以是字符串，也可以是数字值，默认值是SIGTERM。 该方法发送一个为signal的信号到pid的进程。 如果pid不存在，那么该方法抛出一个错误。作为一种特殊情况，信号0可以被用来测试进程的存在性与否。在windows平台，如果pid被用来杀死一个进程组，那么会抛出一个错误。 Note: 尽管该方法的名字叫kill,但事实上它仅仅是一个信号发射器。发射信号的目的是去做一些事情，而不是杀死目标进程。 12345678910process.on('SIGHUP', () =&gt; &#123; console.log('Got SIGHUP signal') &#125;)setTimeout(() =&gt; &#123; console.log('Exiting') process.exit(0)&#125;, 100)process.kill(process.pid, 'SIGHUP') Note: 当Node进程接收到一个SIGUSR1信号时，Node就会启动调试程序。 process.memoryUsage()return: &lt;Object&gt; rss: &lt;integer&gt; heapTotal: &lt;integer&gt; heapUsed: &lt;integer&gt; external: &lt;integer&gt; 方法返回一个对象，描述了Node使用内存的情况。 如：1console.log(process.memoryUsage()) 输出如下：123456&#123; rss: 4935680, heapTotal: 1826816, heapUsed: 650472, external: 49879&#125; heapTotal,heapUsed指向V8的内存的使用情况。external指向被V8管理的绑定到JS对象上的C++对象的内存使用情况。 process.nextTick(callback[,…args])callback: &lt;Function&gt;..args: 当调用callback时传入的额外参数。 该方法将callback添加到当前microtask循环的下一个轮次，一旦本轮的microtask循环结束，立马执行下一轮microtask中所有callback。process.nextTick不是setTimeout(fn, 0)的别名，它更加的高效，他在一下轮macrotask之前执行。 关于microtask和macrotask，请参看这里 12345678910111213141516console.log('start')setTimeout(() =&gt; &#123; console.log('setTimeout') &#125;, 0)process.nextTick(() =&gt; &#123; console.log('nextTick callback') &#125;)console.log('scheduled')// start// scheduled// nextTick callback// setTimeout 当你在开发API时，你想给用户一个机会去添加事件处理器在对象被构造以后，在任何的I/O发生以前，这个方法就显得尤为重要。如下： 12345678910111213function MyThing(options)&#123; this.setupOptions(options) process.nextTick(() =&gt;f &#123; this.startDoingStuff() &#125;)&#125;const thing = new MyThing()thing.getReadyForStuff()// thing.startDoingStuff() gets called now, not before.// thing.startDoingStuff()在thing.getReadyForStuff()之后才执行。 当不确定一个方法时100%同步还是100%异步的时候，process.nextTick可以起到很重要的流程控制。如：123456789// WARNING! DO NOT USE! BAD UNSAFE HAZARD!function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat('file', cb);&#125; 上面的maybeSync是一个非常不靠谱的API，因为可能出现如下情况： 1234567const maybeTrue = Math.random() &gt; 0.5;maybeSync(maybeTrue, () =&gt; &#123; foo();&#125;);bar(); 此次你并不清楚foo(),bar()那个先执行，如果maybeTrue为true,那么foo()先执行，否则bar()先执行。 如果改写为如下写法，那么就可以明确知道谁先执行了： 12345678function definitelyAsync(arg, cb) &#123; if (arg) &#123; process.nextTick(cb); return; &#125; fs.stat('file', cb);&#125; 此时，一定是bar()先执行，因为process.nextTick会将cb放到当前microtask的下一个轮次。 process.pidreturn: &lt;integer&gt; 返回当前进程的pid process.platformreturn: &lt;string&gt; 返回当前Node进程运行在那个操作系统的平台上。如： &#39;darwin&#39;, &#39;freebsd&#39;, &#39;linux&#39;, &#39;sunos&#39; or &#39;win32&#39; prcess.send(message[, sendHandle[, options]][,callback])message: &lt;Object&gt;sendHandle: &lt;Handle object&gt;options: &lt;Object&gt;callback: &lt;Function&gt;return: &lt;boolean&gt; 如果一个进程是通过IPC信道spawned出来的，那么该进程可以通过prcess.send()方法发送信息到父进程。父进程可以通过ChildProcess来监听message事从而接收来自子进程的消息。如果某个进程不是通过IPC信道spawned出来的，那么process.send属性为undefined。 Note: 该方法内部使用JSON.stringify()来序列化message。 process.stderrreturn: &lg;Stream&gt; 该方法返回一个连接到标准错误stderr(文件描述符为2)的流对象。该流是一个net.Socket（这是一个双工流），当文件描述符2指向一个文件时，此时他是一个可写流。 process.stdinreturn: &lg;Stream&gt; 该方法返回一个连接到标注输入stdin(文件描述符为0)的流对象。该流是一个net.Socket（这是一个双工流），当文件描述符0指向一个文件时，此时他是一个可读流。 12345678910111213process.stdin.setEncoding('utf8')process.stdin.on('readable', () =&gt; &#123; const chunk = process.stdin.read() if(chunk !== null)&#123; process.stdout.write(`data: $&#123;chunk&#125;`) &#125;&#125;)process.stdin.on('end', () =&gt; &#123; process.stdout.write('end')&#125;) process.stdoutreturn: &lt;Stream&gt; 该方法返回一个连接到标注输出stdout(文件描述符为1)的流对象。该流是一个net.Socket（这是一个双工流），当文件描述符1指向一个文件时，此时他是一个可写流。 如：拷贝process.stdin到process.stdout1process.stdin.pipe(process.stdout) 关于process I/O需要注意以下几点： process.stdout和process.stderr区别于Node中其他的流有以下几点： 1, 他们分别被用于console.log()和console.error()内部2, 他们不能被关闭3, 他们不会触发finish事件4, 写入有可能是同步的，取决于他们连接到哪里以及在哪个平台上： Files: 在windows和Linux平台上都是同步的 TTYs(Terminals): 在windows上异步，在Unix上同步 Pipes以及sockets: 在windows上同步，在Unix上异步 之所以有这些因为，都是因为一些历史原因，但是又不能轻易的改变他们。 同步的写入可以避免一些问题，比如console.log(),console.error(), 我们知道当使用process.exit()会立马终止进程，如果是异步写入，那么就可能导致还没写完进程就终止了，导致数据写入不全。 Warning: …. process.uptime()return: &lt;number&gt; 返回当前Node进程运行的秒数。需要注意的是，这个秒数包括小数部分。 process.versionreturn: &lt;string&gt; 返回当前Node的版本 12process.version// v7.5.0 Exit Codes(退出码)具体参看这里","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"}]},{"title":"RegExp","slug":"RegExp","date":"2017-06-05T03:35:04.000Z","updated":"2017-06-15T04:00:49.000Z","comments":true,"path":"2017/06/05/RegExp/","link":"","permalink":"https://xxxxxmiss.github.io/2017/06/05/RegExp/","excerpt":"","text":"Character Classes or Character Sets (字符类, 字符集合) 在正则表达式中，字符类就是用一对方括号[]包裹你要匹配的字符。需要注意以下几点： 一个字符类仅仅匹配一个单字符。如/gr[ae]/y, 只会匹配gray, grey, 不会匹配graey。 在字符类中，可以使用连接符-来表示一个范围。当然了，你可以使用多个连字符来表示多个范围。如/[0-9a-fA-F]/,并且字符的顺序是无关紧要的。也就是说，你可以用/[0-9a-fA-F]/, /[a-f0-9A-F]/等都可以用来表示一个16进制的单字符。 在字符类中除了 \\, ^, -外，所有的元字符都是普通的字符，不需要转义。当然了，你非要对这些元字符转义，也是没问题的，只是减少了可读性。就是说，原本一些有特殊意义的字符，用方括号包裹之后，就失去了它原本特殊的含义而变成了一个普通的字符。 还有一个比较特别的就是闭合方括号]。如[]x], [^]x]等这些含有未转义的]正则，在不同的语言中可能会有不同的情况。以上列举的这2种情况，在javascript中是不能正常工作的。例如在ruby中，空的字符类[]被视为一个错误。 还有就是方括号中嵌套方括号，这时也需要注意的,如/[-.*+?^${}()|[\\]\\/\\\\]/g。 所以综上所述，对于字符类中的], \\, ^, -，如果要把他们当做普通字符使用，最好都转义。 123/[.*?+]/.test('.') // true/[.*?+]/.test('a') // false Negated Character Classes （否定的字符类） 表示的意思就是匹配任何不包含在这个字符类中的字符。需要注意以下几点： 我们知道，/./表示的是除换行符以外的任何字符（当然这里有范围的限制，此处暂不讨论），否定字符类恰好能匹配换行符，所以/[^]/表示的就是匹配任何字符（包括换行符）。所以如果你不想否定字符类匹配换行符，你需要在否定字符类中显示的包含换行符，如/[^0-9\\r\\n]/,匹配任何不是数字或者换行符的字符。 举例验证1234// \\u000A 为换行符所对应的unicode/./.test('\\u000A') // fasle/[^]/.test('\\u000A') // true Repeating Character Classes（重复字符类） 当你在字符类上使用*, ?, +进行重复时，需要知道的是，你重复的是这些字符类，而不是重复字符类匹配的字符。 1/[0-9]+/ // match 837 as well as 222 如果你想重复字符类匹配的字符，可以使用反向引用 1/([0-9])\\1+/ // match 222 but not 837 Shorthand Character Classes(字符类简写) 因为一些特定的字符类经常被使用，所以就制定了一些特定的字符代表字符类。在不同的语言中，这些特定的字符所代表的字符不一定是完全一样的。 \\w: [0-9a-zA-Z_] \\s: [ \\t\\r\\n\\f],在某些语言中还包括垂直制表符\\v \\d: [0-9] Dot or Period(点) 元字符.匹配除了换行符以外的任意一个单字符。至于为什么不包含换行符是由于历史原因造成的：第一代工具使用正则表达式是基于行的。他们一行一行的读取文件，使用正则表达式分割行。由于这些工具的影响，导致了.元字符不包括换行符。 NOTE: 虽然元字符.不包括换行符，但是在不同的语言中，实现并不相同，有些语言是可以通过一些选项来控制是否包含换行符的。但是在javascript和vbscript中，是没有任何选项来控制的。 12// 在js中，可以使用[\\s\\S]来匹配任何字符/[\\s\\S]/ // match any character, include line breaks Line Breaks Character(换行符) 换行符在不同的操作系统以及不同的语言中实现也有所不同，尽管如此，但是我们依然可以认为\\n就是我们所说的换行符。因为在我们熟悉的脚本语言中，都只会将\\n作为换行符，而不会将其他字符作为换行符。尽管window系统中的换行符是\\r\\n,但是我们说换行符就是\\n依然没有问题。这是因为这些脚本语言默认是处于文本模式下读写文件的。当脚本运行在window系统中，在读取文件时，\\r\\n自动转换为\\n;写文件时，\\n自动转换为\\r\\n。 Word Boundaries（单词边界） 元字符\\b和^,$都属于锚点字符，用来匹配叫做单词边界的位置。他匹配的长度为0。有3种不同的位置可以作为单词的边界： 字符串中的第一个字符的前面（第一个字符必须是单词） 字符串中的最后一个字符的后面（最后一个字符必须是单词） 字符串中两个字符之间的位置，这个两个字符必须一个是单词，一个非单词 Alternation（选择） 正则表达式中使用管道符（pipe character）|来对匹配模式进行选择匹配。需要注意的是选择操作在正则表达式中的优先级是最低的。 如：假设我们要匹配的是一个单词及其左右边界，正则如下1/\\bcat|dog\\b/ // 能匹配catxx或者xxdog等 解释：按照上面的写法只会匹配cat及其左边界或者dog及其右边界，如果要匹配cat或则dog及其左右边界，必须使用分组来改变其优先级。如下1/\\b(cat|dog)\\b/ 关于正则表达式中的“选择”，下面我们来通过例子详细的说明他们是如何工作的。12345var animalCount = /\\b\\d+ (pig|cow|chicken)s?\\b/console.log(animalCount.test(\"15 pigs\"))// → trueconsole.log(animalCount.test(\"15 pigchickens\"))// → false 假设我们的正则表达式已经实例化成上面的图表，图表中的每个正则token看成一个盒子。要匹配的字符串为the 3 pigs。那么匹配的流程会像下面的步骤进行： 在第4个位置（从0开始），有一个单词边界，因此通过了第一个盒子。 此次仍然在第4个位置（因为单词边界是不占据长度的），找到了一个数字，因此通过了第二个盒子。 在进入第5个位置时，有2个条路径，一条回到第二个盒子形成一个环路，一条直接进入第5个位置。我们要匹配的字符串的第5个位置是一个空白字符，因此直接进入第5个位置。 在进入第6个位置时(pigs的第一个字符)，有三条路径。但我们要匹配的字符串中并没有cow或者chicken, 有的是pig，因此进入pig这条路径。 在进入第9个位置时，又出现了2条路径，一条跳过了s这个盒子直接进入最终的单词边界的盒子，一条进入s这个盒子。要匹配的字符中含有字符s，因此进入到s这个盒子。 在第10个位置（末尾单词边界的位置），要匹配的字符串已经到达末尾（字符串的末尾算着一个单词边界）。因此通过了最后单词边界这个盒子，完成了整个的匹配。 综上所述, 在一个字符串中搜寻匹配的字符时，正则表达式引擎会进行如下的查找了流程：从一个字符串的起始位置，一个一个字符进行匹配，直到找到了一个匹配或者达到字符串的末尾才能决定最终的匹配情况。 Backtracking(回溯) 在正则表达式中，有一种叫做回溯查找，就是沿着某一条路径匹配多次。回溯通常出现在数量匹配中，如*, +, {m, n}。下面以具体的图表和例子来说明匹配情况。 1/\\b([01]+b|\\d+|[\\da-f]+h)\\b/.test('103') 上面的例子中，匹配器会一直在最上面的那条路径进行匹配，只有达到字符3，才知道进错了路径。 此时匹配器进行回溯。其实在选择匹配的时候，匹配器首先会记录当前的位置（也就是每条路径中第一个字符的位置）以便于当进入到错误的路径时可以快速返回到这个位置。 此时进入到第二条路径（从上往下），发现可以完整匹配，匹配结束。 NOTE: 一旦找到一个完整匹配，匹配器会立马停止匹配。这就意味着如果多个分支可以匹配这个正则，那么返回的匹配是第一个（每个分支按在正则表达式中出现的先后顺序来排序）举例如下：1/^(h|hello)(.*)$/.exec(\"hello\") // ['hello', 'h', 'ello'] 下面来看一个正则表达式中类似于多次循环的例子：1/([01]+)+b/ 关于上面的例子中的正则表达式有什么问题，此处先不做说明。 Greedy and non-greedy(贪婪匹配和非贪婪匹配) 正则引擎默认是贪婪匹配的，就是尽可能多的匹配。除非尽可能多的导致整个匹配失败，那么才会回溯到重复的位置重新开始匹配。贪婪匹配一般出现在量词中，如下： ? &lt;=&gt; {0,1} * &lt;=&gt; {0,} + &lt;=&gt; {1,} {m, n} 下面以一个具体的例子来说明贪婪匹配，假设我们要匹配一个字符串中不带任何属性的html标签，你的正则可能会像下面这样：12/&lt;.+&gt;/.exec('This is a &lt;EM&gt;first&lt;/EM&gt; test')// prints: ['&lt;EM&gt;first&lt;/EM&gt;'] 你会看到匹配的结果和我们所期盼的&lt;EM&gt;,&lt;/EM&gt;并不一样。究其原因就是因为量词+是贪婪的，它会让正则引擎尽可能多的匹配。其实这个匹配过程可以用上面的图表来解释更加的清楚：匹配完第一个.所代表的字符后，进入到下一个字符会有2条路径：一条是.形成的环路，一条直接进入&gt;, 但是+是贪婪的，那么正则引擎会一直进入这条环路，直接匹配失败了才会退出这条路径。下面是更加详细的关于正则引擎是如何匹配&lt;EM&gt;first&lt;/EM&gt;的： The first token in the regex is &lt;. As we already know, the first place where it will match is the first &lt; in the string. The next token is dot, which matches any character except newlines. The dot is repeated by the plus. The plus is greedy. Therefore, the engine will repeat the dot as many times as it can. The dot matches E, so the regex continues to try to match the dot with the next character. M is matched, and the dot is repeated once more. The next character is &gt;. You should see the problem by now. The dot matches the &gt;, and the engine continues repeating the dot. The dot will match all characters in the string. The dot fails when the engine has reached the void after the end of the string. Only at this point does the regex engine continue with next token &gt;.So far, &lt;.+ has matched &lt;EM&gt;first&lt;/EM&gt; test and the regex engine has arrived at the end of the string. &gt; cannot match here. The engine remembers that the plus has repeated the dot more often than is required. (Remember that the plus requires the dot to match only once.) Rather than admitting failure, the engine will backtrack. It will reduce the repetition of the plus by one, and then continue trying the remainder of the regex.So the match of .+ is reduced to EM&gt;first&lt;/EM&gt; tes. The next token in the regex is still &gt;. But now the next character in the string is the last t. Again, these cannot match, causing the engine to backtrack further. The total match so far is reduced to &lt;EM&gt;first&lt;/EM&gt; te. But &gt; still cannot match. So the engine continues backtracking until the match of .+ is reduced to EM&gt;first&lt;/EM. Now, &gt; can match the next character in the string. The last token in the regex has been matched. The engine reports that &lt;EM&gt;first&lt;/EM&gt; has been successfully matched. 1/^(.+) ((?:BBB )?CCC)$/.exec('AAA BBB CCC') 正则相关方法 操作字符串的一些常用方法，如replace, split, match, search等，这些方法的第一个参数都可以是一个正则表达式对象，也可以是一个子字符串，此处主要讲解第一个参数是正则表达式的情况。RegExp的一些实例方法，如test, exec等 str.replace(regexp|substr, newSubstr|function)先来看一个例子：假设我们要匹配动态的匹配一个人的姓名，在匹配到姓名前后插入下划线，但是这个人的姓名很特殊（含有一些特殊的符号）。所以我们可以按照下面的做法来处理：12345678var name = 'dea+hl[]rd'var text = 'This dea+hl[]rd guy is super annoying.'// 匹配除了单词和空白以外的任何字符// 不能对任何字符进行转义，以为\\n,\\b这些字符也是有特殊意义的var escaped = name.replace(/[^\\w\\s]/g, \"\\\\$&amp;\")var regexp = new RegExp(\"\\\\b(\" + escaped + \")\\\\b\", \"gi\");console.log(text.replace(regexp, \"_$1_\"));// → This _dea+hl[]rd_ guy is super annoying. 第二个参数newSubstr可以使用下面的这些特殊的变量名。 变量名 代表的值 $$ 插入一个$ $&amp; 插入匹配的子串 $` 插入当前匹配的子串的左边的内容 $’ 插入当前匹配的子串的右边的内容 $n 假如repalce方法的第一个参数是一个RegExp对象，并且n是小于100的从1开始的整数，那么插入第n个捕获性分组 例子：12\"dea+hl[]rd\".replace(/[^\\w\\s]/g, \"\\\\$`\")// prints: \"dea\\deahl\\dea+hl\\dea+hl[rd\" 第二个参数可以是一个函数，在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1, p2, … 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串时“bc”，那么这个参数将是1） string 被匹配的原字符串 NOTE: 精确的参数个数依赖于replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ')&#125;var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer)// prints: 'abc - 12345 - #$*%' 该方法的详细用法可以参考这里 str.search(regexp) 我们知道，字符串有个indexOf方法，但是它不能使用正则表达式作为参数，而search方法就需要一个正则表达式作为参数。和indexOf方法一样，它返回第一个匹配字符串的索引；没有找到任何匹配，返回-1。 NOTE: indexOf方法可以传入第二个参数作为搜索的起始偏移量，而search却不能。 1234console.log(\" word\".search(/\\S/));// → 2console.log(\" \".search(/\\S/));// → -1 str.split([separator, [limit]]) 分割一个字符串，返回分割后的字符串组成的数组。 如果忽略了separator或者在str中没有找到separator, 那么返回的是整个字符串组成的一个元素的数组。 如果separator是长度为0的字符串，那么返回的是str中每个字符组成的数组。 只有在str长度为0, separator长度也为0的时候，才会返回一个空数组。 支持第二个参数limit, 代表切割后返回的数组的长度。如limit=3，表示需要切割3次（形成4个子串），返回前3个元素组成的数组。 当separator是一个正则时，需要注意： 123'abc2d3f'.split(/\\d/) // [\"abc\", \"d\", \"f\"]'abc2d3f'.split(/(\\d)/) // [\"abc\", \"2\", \"d\", \"3\", \"f\"] 由上面的例子可以看出，当split方法第一个参数为正则时，如果这个正则包含捕获性分组时，这个分组匹配的子串是不会被移除的，而是会被包含到返回的数组中。 str.match(regexp) 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array ：[“”] NOTE:如果使用的正则不包含全局修饰符g, 那么返回的数组会有额外的2个属性, 并且包好捕获性分组： input: 包含被解析的原始字符串 index: 该属性表示匹配结果在原字符串中的索引（以0开始） 12'bac12d3'.match(/[a-z]+(\\d)*/)// prints: [\"bac12\", \"2\", index: 0, input: \"bac12d3\"] 此时它和正则对象的exec方法返回值是一样的:12/[a-z]+(\\d)*/.exec('bac12d3')// prints: [\"bac12\", \"2\", index: 0, input: \"bac12d3\"] 如果使用的正则包含修饰符g, 那么返回的数组只包含所有的子匹配，并不包含额外的属性以及捕获性分组： 12'bac12d3'.match(/[a-z]+(\\d)*/g)// prints: [\"bac12\", \"d3\"] 不管是哪种情况，没有找到任何匹配，那么返回null。 该方法的详细用法可以参考这里 regex.exec 我们知道，字符串的indexOf方法提供了起始搜索偏移量这个参数，可以更加高效的执行字符串查找。但是字符串的一些有关正则方法并没有直接提供这样的方式。正则对象虽然也没有直接提供这样的快捷方式，但是正则对象的exec方法提供了一种”不是很方便”的方式来让我们做这样一个操作, 那就是通过lastIndex这个正则属性。 123var re = /quick\\s(brown).+?(jumps)/igvar result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog')// prints: [\"Quick Brown Fox Jumps\", \"Brown\", \"Jumps\", index: 4, input: \"The Quick Brown Fox Jumps Over The Lazy Dog\"] 关于上面的脚本中的re,result对象相关属性说明如下： 对象 属性/索引 描述 例子 result [0] 完全匹配 Quick Brown Fox Jumps [1], …[n] 捕获性分组 [1] = Brown[2] = Jumps index 完整的匹配在整个字符串中的索引 4 input 要匹配的原始字符串 The Quick Brown Fox Jumps Over The Lazy Dog re lastIndex 执行下一次搜索时起始的位置 25 ignoreCase 表示是否使用了i标记 true global 表示是否使用了g标记 true multiline 表示是否使用了m标记 false source 匹配模式的字符串文本 quick\\s(brown).+?(jumps) 下面就关于上表中的相关注意事项做下说明： 我们知道，正则引擎是eager(急切的，渴望的)的，也就是说当从整个字符串中找到一个匹配时，会立马停止继续查找，并返回找到的子串。像字符串的match, replace方法，当第一个参数为正则对象时，可以传入修饰符g来进行全局的查找，也就说找到从一行字符中找到所有的匹配，直到查找到这行字符串的尽头。但是正则对象的exec方法却并不是这样的，即使你传入全局标记g,依然只是返回第一个匹配。我们测试下： 12/(\\d)/g.exec('ab12c45')// prints: [\"1\", \"1\", index: 2, input: \"ab12c45\"] 经过上面例子的验证，我们看到确实如我们所言：尽管是全局匹配，但是依然只是返回了第一个匹配。还有就是需要注意exec方法和match方法的对比： exec方法使用了全局标记g,它虽然只返回了第一个匹配，但是它返回的信息非常全面，包含index,innput属性以及捕获性分组。 match方法不使用全局标记g时，返回的信心包含index,input属性以及捕获性分组。 match方法使用了全局标记g, 返回的信息只包含所有匹配的子串。既然exec方法有没有全局标记g，返回的信息都一样，那么全局g有什么用？ 正则对象的lastIndex属性 一当一个正则对象或者正则字面量开启了全局标记g，那么配合正则对象的lastIndex属性，我们就可以指定下次搜索时，从什么位置开始搜索。并且通过循环判断exec方法来的返回值对字符串进行一个全局的匹配。 1234var reg = /\\d+/gconsole.log(reg.lastIndex) // 0console.log(reg.exec('abc12d3bb4')) // [\"12\", index: 3, input: \"abc12d3bb4\"]console.log(reg.lastIndex) // 5 默认情况下正则对象的lastIndex值是0，表示起始偏移量。一旦成功的找到一个匹配后，正则引擎会自动更新lastIndex的值，表示下一次匹配时默认从这个地方开始。什么从一开始就没有找到任何匹配，那么lastIndex的值还是0。 当然了，你可以设置lastIndex的值，表示一开始就从你设置的这个位置开始查找： 1234var reg = /\\d+/greg.lastIndex = 5console.log(reg.exec('abc12d3bb4')) // [\"3\", index: 6, input: \"abc12d3bb4\"]console.log(reg.lastIndex) // 7 使用exec方法找到所有匹配，一般这样做：1234567891011121314var reg = /\\d+/gvar match = nullvar str = 'abc12d3bb4'while(match = reg.exec(str))&#123; console.log('$&amp;: ', match[0]) console.log('lastIndex: ', reg.lastIndex)&#125;// prints: // $&amp;: 12// lastIndex: 5// $&amp;: 3// lastIndex: 7// $&amp;: 4// lastIndex: 10 字符串相关方法 VS 正则对象的相关方法 // TODO …","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"词法作用域VS动态作用","slug":"js-scope","date":"2017-05-28T15:54:27.000Z","updated":"2017-07-16T05:38:08.000Z","comments":true,"path":"2017/05/28/js-scope/","link":"","permalink":"https://xxxxxmiss.github.io/2017/05/28/js-scope/","excerpt":"","text":"词法作用域(lexical scoping) js中有2种作用域，词法作用域和动态作用域。下面用例子来解释这2种作用域的概念。 1234567891011121314151617181920212223var outerFunction = function()&#123; if(true)&#123; var x = 5; //console.log(y); //line 1, ReferenceError: y not defined &#125; var nestedFunction = function() &#123; if(true)&#123; var y = 7; console.log(x); //line 2, x will still be known prints 5 &#125; if(true)&#123; console.log(y); //line 3, prints 7 &#125; &#125; return nestedFunction;&#125;var myFunction = outerFunction();myFunction(); 在上面的例子中，变量x可以在outerFunction中各个地方访问，变量y可以在nestedFunction中各个地方访问，但是变量x,y不能在他们所在的函数的外部访问。这种行为可以通过词法作用域来解释： 词法作用域：变量的作用域是由他们被定义时处在源代码中的位置决定。为了去解析这些变量，js从最内层作用域向外层作用域查找，直到查找到该变量为止。 再来看一个典型的例子：12345678910function foo()&#123; console.log(a) // 2&#125;function bar()&#123; var a = 3 foo()&#125;var a = 2bar() 这个例子中，会输出2。我们按照词法作用来分析下：首先foo在自己的作用域中寻找变量a, 没有找到，那么到父级作用域中查找，本例子中foo的父级作用域就是全局作用域。因为foo函数定义时处在全局环境中有个变量a，所以在bar函数中调用foo时，会输出2。如果寻找到顶级作用域都没有找到变量a, 那么就抛出一个Uncaught ReferenceError: a is not defined如果按照动态作用域来分析：foo执行时所在的作用域是bar函数的作用域，那么此时输出的就是3了。 词法作用域很清晰明了，但是动态作用域就不是这么清晰明了了，动态作用域是由运行时的环境决定的。为了说明说明什么叫动态作用域，先来看什么叫闭包。 闭包(closures)我们看上面的例子，事实上对于为什么在nestedFunction中可以访问变量x依然是模糊的。因为我们知道：通常一个函数中的本地变量，会随着函数的执行完毕而销毁。那么我们调用函数outerFunction并将它的返回值赋值给myFunction, 为什么outerFunction函数已经执行完毕而变量x依然存在？ MDN上对闭包的定义如下: A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time that the closure was created.意思就是：闭包是一种特殊的函数，该函数可以记住当时创建时的环境。 那上面的例子来解释就是：nestedFunction被创建时，是在outerFunction作用域中，该作用域中有变量x, 那么当outerFunction函数执行完毕时，返回的nestedFunction是可以记住变量x的。换句话说，就是原本随函数执行完毕而销毁的变量，因为有别人对他的引用，因此当函数执行完毕时该变量并不会被销毁。 函数的执行上下文(this，动态作用域) 上面对于闭包的解释，一种可以记住当时被创建时的环境，这个环境主要是指各种本地变量。但是一种特殊的变量this，他的行为和普通变量完全不同，看下面的例子： 1234567891011121314151617var cat = &#123; name: \"Gus\", color: \"gray\", age: 15, printInfo: function() &#123; console.log(\"Name:\", this.name, \"Color:\", this.color, \"Age:\", this.age); //line 1, prints correctly nestedFunction = function() &#123; console.log(\"Name:\", this.name, \"Color:\", this.color, \"Age:\", this.age); //line 2, loses cat scope &#125; nestedFunction(); &#125;&#125;cat.printInfo(); //prints Name: '' Color: undefined Age: undefined 上面的例子，第一处的console语句能正常的输出,但是对于nestedFunction中的输出语句，却未能按照预期输出。 对于第二个console输出，当一个函数处在另一个函数的内部时，js会丢失this作用域，一旦丢失，默认情况下this会指向全局的window对象。所以上面的例子，nestedFunction中的this.color和this.age输出undefined, 而this.name会输出空字符串, 是因为window对象默认有个name属性，默认值就是空。 关于window对象的name属性，可以参看这里 控制上下文(context) 我们无法改变词法作用域在js中的工作机制，但是我们可以改变一个函数的执行问下文。js中的上下文是由函数运行时决定的，并且他总是被绑定到调用该函数的对象上,但是唯一不适用这条规则的就是上面出现的函数嵌套的情况。 换句话说，改变上下文就是改变this的指向。看个简单的例子：123456789var obj1 = &#123; printThis: function() &#123; console.log(this); &#125;&#125;; var func1 = obj1.printThis;obj1.printThis(); //line 1func1(); //line 2 line1会输出ojb1, line2会输出window。 Call, Bind, Apply 我们可以有多种方式来控制this的指向，常见的有以下几种： 存储this的引用到另外一个变量 call() apply() bind() 存储this的引用到另外一个变量:12345678910111213141516var cat = &#123; name: \"Gus\", color: \"gray\", age: 15, printInfo: function() &#123; var that = this; console.log(\"Name:\", this.name, \"Color:\", this.color, \"Age:\", this.age); //prints correctly nestedFunction = function() &#123; console.log(\"Name:\", that.name, \"Color:\", that.color, \"Age:\", that.age); //prints correctly &#125; nestedFunction(); &#125;&#125;cat.printInfo(); 123456789101112131415161718var cat = &#123; name: \"Gus\", color: \"gray\", age: 15, printInfo: function() &#123; console.log(\"Name:\", this.name, \"Color:\", this.color, \"Age:\", this.age); nestedFunction = function() &#123; console.log(\"Name:\", this.name, \"Color:\", this.color, \"Age:\", this.age); &#125; nestedFunction.call(this); nestedFunction.apply(this); var storeFunction = nestedFunction.bind(this); storeFunction(); &#125;&#125;cat.printInfo(); 关于call, apply, bind详细使用方法，这里不讲解了。这里说下他们三者的区别： call, apply, 主要的不同就是传递额外参数的方式不同。call传递一个以逗号分割的列表，bind也是用这样的方式传递额外参数。apply需要传递的是一个数组。 相对于call, apply，bind的使用要更加的灵巧一些：因为bind不但可以改变this的指向，而且他会返回一个新的函数，那么我们可以将这个新函数保存到另外一个变量中，在需要使用的地方再调用。但是call和apply会立即调用函数，返回函数的结果。 关于setTimeout中的this 我们知道，可以使用call, apply, 来改变函数的执行上下文，那么他们是否也适用于setTimeout呢？ 看例子：12345678910111213myArray = [\"zero\", \"one\", \"two\"];myArray.myMethod = function (sProperty) &#123; alert(arguments.length &gt; 0 ? this[sProperty] : this);&#125;;myArray.myMethod(); // prints \"zero,one,two\"myArray.myMethod(1); // prints \"one\"setTimeout(myArray.myMethod, 1000); // prints \"[object Window]\" after 1 secondsetTimeout(myArray.myMethod, 1500, \"1\"); // prints \"undefined\" after 1,5 seconds// let's try to pass the 'this' objectsetTimeout.call(myArray, myArray.myMethod, 2000); // Uncaught TypeError: Illegal invocationsetTimeout.call(myArray, myArray.myMethod, 2500, 2); // same error 我们知道，正常情况下setTimeout/setInterval中的this是指向window对象的，我们还知道call方法可以改变this的指向，但是上面的例子中，使用setTimeout.call抛出错误。至于为什么这样，目前还不知道。。。？ 一种解决setTimeout中this指向不正确的方案就是重写原生的setTimeout,如下1234567var __nativeST__ = window.setTimeoutwindow.setTimeout = function(callback, delay)&#123; var self = this, args = [].slice.call(arguments, 2) return __nativeST__(callback instanceof Function ? function()&#123; callback.apply(self, args) &#125; : callback, delay)&#125; 经过上面的处理之后，此时再来调用发现就正确了：12345678myArray = [\"zero\", \"one\", \"two\"];myArray.myMethod = function (sProperty) &#123; alert(arguments.length &gt; 0 ? this[sProperty] : this);&#125;;setTimeout(alert, 1500, \"Hello world!\"); // the standard use of setTimeout and setInterval is preserved, but...setTimeout.call(myArray, myArray.myMethod, 2000); // prints \"zero,one,two\" after 2 secondssetTimeout.call(myArray, myArray.myMethod, 2500, 2); // prints \"two\" after 2,5 seconds 参考文章链接参考文章链接","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"vue-src-overview","slug":"vue-src-overview","date":"2017-05-28T11:12:10.000Z","updated":"2017-08-15T08:36:57.000Z","comments":true,"path":"2017/05/28/vue-src-overview/","link":"","permalink":"https://xxxxxmiss.github.io/2017/05/28/vue-src-overview/","excerpt":"","text":"源码目录总览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184├── src│ ├── compiler│ │ ├── codegen│ │ │ ├── events.js│ │ │ └── index.js│ │ ├── directives│ │ │ ├── bind.js│ │ │ ├── index.js│ │ │ └── model.js│ │ ├── error-detector.js│ │ ├── helpers.js│ │ ├── index.js│ │ ├── optimizer.js│ │ └── parser│ │ ├── entity-decoder.js│ │ ├── filter-parser.js│ │ ├── html-parser.js│ │ ├── index.js│ │ └── text-parser.js│ ├── core│ │ ├── components│ │ │ ├── index.js│ │ │ └── keep-alive.js│ │ ├── config.js│ │ ├── global-api│ │ │ ├── assets.js│ │ │ ├── extend.js│ │ │ ├── index.js│ │ │ ├── mixin.js│ │ │ └── use.js│ │ ├── index.js│ │ ├── instance│ │ │ ├── events.js│ │ │ ├── index.js│ │ │ ├── init.js│ │ │ ├── inject.js│ │ │ ├── lifecycle.js│ │ │ ├── proxy.js│ │ │ ├── render-helpers│ │ │ │ ├── bind-object-props.js│ │ │ │ ├── check-keycodes.js│ │ │ │ ├── render-list.js│ │ │ │ ├── render-slot.js│ │ │ │ ├── render-static.js│ │ │ │ ├── resolve-filter.js│ │ │ │ └── resolve-slots.js│ │ │ ├── render.js│ │ │ └── state.js│ │ ├── observer│ │ │ ├── array.js│ │ │ ├── dep.js│ │ │ ├── index.js│ │ │ ├── scheduler.js│ │ │ └── watcher.js│ │ ├── util│ │ │ ├── debug.js│ │ │ ├── env.js│ │ │ ├── error.js│ │ │ ├── index.js│ │ │ ├── lang.js│ │ │ ├── options.js│ │ │ ├── perf.js│ │ │ └── props.js│ │ └── vdom│ │ ├── create-component.js│ │ ├── create-element.js│ │ ├── helpers│ │ │ ├── index.js│ │ │ ├── merge-hook.js│ │ │ ├── normalize-children.js│ │ │ └── update-listeners.js│ │ ├── modules│ │ │ ├── directives.js│ │ │ ├── index.js│ │ │ └── ref.js│ │ ├── patch.js│ │ └── vnode.js│ ├── entries│ │ ├── web-compiler.js│ │ ├── web-runtime-with-compiler.js│ │ ├── web-runtime.js│ │ ├── web-server-renderer.js│ │ ├── weex-compiler.js│ │ ├── weex-factory.js│ │ └── weex-framework.js│ ├── platforms│ │ ├── web│ │ │ ├── compiler│ │ │ │ ├── directives│ │ │ │ │ ├── html.js│ │ │ │ │ ├── index.js│ │ │ │ │ ├── model.js│ │ │ │ │ └── text.js│ │ │ │ ├── index.js│ │ │ │ ├── modules│ │ │ │ │ ├── class.js│ │ │ │ │ ├── index.js│ │ │ │ │ └── style.js│ │ │ │ └── util.js│ │ │ ├── runtime│ │ │ │ ├── class-util.js│ │ │ │ ├── components│ │ │ │ │ ├── index.js│ │ │ │ │ ├── transition-group.js│ │ │ │ │ └── transition.js│ │ │ │ ├── directives│ │ │ │ │ ├── index.js│ │ │ │ │ ├── model.js│ │ │ │ │ └── show.js│ │ │ │ ├── modules│ │ │ │ │ ├── attrs.js│ │ │ │ │ ├── class.js│ │ │ │ │ ├── dom-props.js│ │ │ │ │ ├── events.js│ │ │ │ │ ├── index.js│ │ │ │ │ ├── style.js│ │ │ │ │ └── transition.js│ │ │ │ ├── node-ops.js│ │ │ │ ├── patch.js│ │ │ │ └── transition-util.js│ │ │ ├── server│ │ │ │ ├── directives│ │ │ │ │ ├── index.js│ │ │ │ │ └── show.js│ │ │ │ ├── modules│ │ │ │ │ ├── attrs.js│ │ │ │ │ ├── class.js│ │ │ │ │ ├── dom-props.js│ │ │ │ │ ├── index.js│ │ │ │ │ └── style.js│ │ │ │ └── util.js│ │ │ └── util│ │ │ ├── attrs.js│ │ │ ├── class.js│ │ │ ├── compat.js│ │ │ ├── element.js│ │ │ ├── index.js│ │ │ └── style.js│ │ └── weex│ │ ├── compiler│ │ │ ├── directives│ │ │ │ ├── index.js│ │ │ │ └── model.js│ │ │ ├── index.js│ │ │ └── modules│ │ │ ├── append.js│ │ │ ├── class.js│ │ │ ├── index.js│ │ │ ├── props.js│ │ │ └── style.js│ │ ├── framework.js│ │ ├── runtime│ │ │ ├── components│ │ │ │ ├── index.js│ │ │ │ ├── transition-group.js│ │ │ │ └── transition.js│ │ │ ├── directives│ │ │ │ └── index.js│ │ │ ├── index.js│ │ │ ├── modules│ │ │ │ ├── attrs.js│ │ │ │ ├── class.js│ │ │ │ ├── events.js│ │ │ │ ├── index.js│ │ │ │ ├── style.js│ │ │ │ └── transition.js│ │ │ ├── node-ops.js│ │ │ ├── patch.js│ │ │ └── text-node.js│ │ └── util│ │ └── index.js│ ├── server│ │ ├── create-bundle-renderer.js│ │ ├── create-bundle-runner.js│ │ ├── create-renderer.js│ │ ├── render-context.js│ │ ├── render-stream.js│ │ ├── render.js│ │ ├── source-map-support.js│ │ └── write.js│ ├── sfc│ │ └── parser.js│ └── shared│ └── util.js 生命周期 src/core/instance/lifecycle.js 12345678910111213141516export function callHook (vm: Component, hook: string) &#123; const handlers = vm.$options[hook] if (handlers) &#123; // 从此处可以看出一个钩子，可以对应多个处理器 for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; try &#123; handlers[i].call(vm) &#125; catch (e) &#123; handleError(e, vm, `$&#123;hook&#125; hook`) &#125; &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125;&#125; 就是说你可以这样：123456new Vue(&#123; created: [ function()&#123; console.log('hook-created-1') &#125;, function()&#123; console.log('hook-created-2') &#125; ] &#125;) data, props, computed, methods, watch相关 src/core/instance/state.js 123456789101112131415161718function initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) for (const key in computed) &#123; const userDef = computed[key] // 如果计算属性不是函数，那么应该是一个对象，并且应该提供一个get方法 const getter = typeof userDef === 'function' ? userDef : userDef.get // create internal watcher for the computed property. watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions) // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; &#125;&#125; 在通过下面定义的defineComputed, 可以知道我们还可以这样定义计算属性： 12345678910111213new Vue(&#123; computed: &#123; name: &#123; cache: true, get()&#123; return 'xxx' &#125;, set()&#123; &#125; &#125; &#125; &#125;)","categories":[],"tags":[]},{"title":"Object类方法之keys()","slug":"Object-keys","date":"2017-05-20T11:55:45.000Z","updated":"2017-06-17T16:36:56.000Z","comments":true,"path":"2017/05/20/Object-keys/","link":"","permalink":"https://xxxxxmiss.github.io/2017/05/20/Object-keys/","excerpt":"","text":"Object.keys() 返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 通过例子来看下什么叫“和for…in”顺序一致：123456789// 注意，这并不是类数组var obj = &#123; 100: 'a', 2: 'b', 7: 'c'&#125;for(var key in obj) console.log(key) // '2' '7' '100'Object.keys(obj) // ['2', '7', '100'] 在通过例子看看什么叫Object.keys()不会列出原型上的属性:123456789101112131415var target = &#123; name: 'js', price: 100&#125;target.__proto__ = &#123; ISBN: 2017, publish: 'construction house'&#125;for(var key in target)&#123; console.log(key) // 会输出'name', 'price', 'ISBN', 'publish'&#125;console.log(Object.keys(target)) // 会输出 ['name', 'price'] 在通过例子看看什么叫Object.keys()只会列出对象自身可枚举的属性：1234567891011121314151617var target = &#123; name: 'js', price: 100&#125;Object.defineProperty(target, 'ISBN', &#123; value: 2017&#125;)console.log(target.propertyIsEnumerable('ISBN')) // false// for...in循环也只会列出自身和原型上的可枚举属性for(var key in target)&#123; console.log(key) // 'name', 'price'&#125;// 因为'ISBN'通过Object.defineProperty()添加的，默认是不可枚举的console.log(Object.keys(target)) // ['name', 'price'] 关于Object.defineProperty()和obj.propertyIsEnumerable()的详细说明可要参看这里。Object.defineProperty()obj.propertyIsEnumerable() 类数组 通过上面的例子，我们看出for...in迭代这个对象的属性和我们平常迭代一个通过对象的属性不一样，造成这个原因就是因为这个对象的属性是数字。我们知道，js迭代一个对象的顺序是无法保证按我们书写先后顺序一样，如果要保证顺序我们可以使用类数组。类数组的定义：就是一个普通的对象，但是该对象必须保证2点：①每个属性的值必须是一个数字②必须有lenth属性。 NOTE: 将一个类数组转化为正真的数组，如果类数组的length属性的值和数字属性的个数不一致，那么会出现以下几种情况: length的值和数字属性的个数一致： 1234567var arrlike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;console.log([].slice.call(arrlike)) // [ 'a', 'b', 'c' ] length的值大于数字属性的个数，会出现稀疏数组 1234567var arrlike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 5&#125;console.log([].slice.call(arrlike)) // [ 'a', 'b', 'c', , ] length的值小于数字属性的个数，会截断数组 1234567var arrlike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 2&#125;console.log([].slice.call(arrlike)) // [ 'a', 'b' ] 兼容性 在es5中，如果该方法的参数不是一个对象，那么会造成TypeError。在es2015中，非对象的参数将会被强制转换为一个对象。如果转化失败，则会抛出转化类型错误。 123456789101112131415// ES5Object.keys('foo')// TypeError: 'foo' is not an object// ES2015Object.keys('foo')// ['0', '1', '2']Object.keys(null)Object.keys(undefined)// Uncaught TypeError: Cannot convert undefined or null to objectObject.keys(3) // []Object.keys(new Date()) // []Object.keys(function()&#123;&#125;) // [] 所以可以简单做如下总结(在es2015中) 参数为null,undefined，抛出转换失败错误 原始类型返回空数组 引用类型返回空的数组 symbol类型返回空数组 数组，类数组, 非空的字符串，都返回他们的索引组成的数组 只有纯对象才返回属性名组成的字符串数组 什么叫纯对象1Object.prototype.toString.call(obj) === '[object Object]' 满足这个条件的对象就叫纯对象。 Object.keys简单的polyfill1234567if(!Object.keys) Object.keys = function(o)&#123; if(o !== Object(o)) throw new TypeError('Object.keys called on a non-object') var k = [], p for(p in o) if(Object.prototype.hasOwnProperty.call(o, p)) k.push(p) return k&#125; Object的使用之一 在上面的polyfill中，判断类型时，使用了o !== Object(o), 直接调用Object构造函数，可以将一个原始类型转化为引用类型。还有其他的类似的构造函数Number, String, Boolean等也是将对应的原始类型转化为引用类型。也就是说可以利用Object构造函数来判断一个变量引用类型还是原始类型 通过例子看下是不是这么回事：123var n = 1console.log(typeof n) // 'number'console.log(typeof Object(n)) // 'object' 需要注意的是：使用Object构造函数来判断是原始类型还是引用类型的时候，一定要使用===全等判断符号 再来看例子12var str = 'hello'console.log(Object(str)) // &#123;0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\", length: 5, [[PrimitiveValue]]: \"hello\"&#125; 通过Object(str)将一个字符串转化为类数组对象了，其实这也就是为什么平时我们可以对一个原始类型的字符串使用length属性，其实真正的是将该字符串转化为对应的引用类型，再去使用该引用类型上的length属性。 一般情况下，我们取字符串某个位置上的字符，可能会这样str.charAt(index)。通过上面的例子可以看出还可以按照数组取值的方式来。比如hello[0]。 symbol作为对象的属性 js中对象的定义就是：一些属性的集合。这个属性，包括2种，一种是普通的字符串（包括空字符串），另一种就是symbol。这里需要注意的就是：当使用symbol作为对象的属性时，那么for in循环和Object.keys是不会列出这些symbol属性的。如果要获取symbol属性的值，那么可以通过以下2种方法： Object.getOwnPropertySymbols() Reflect.ownKeys() Object.getOwnPropertySymbols 返回一个对象自有的symbol属性组成的数组。因为所有的对象都没有初始化的symbol属性，所以默认情况下它会返回一个空数组。 123456var obj = &#123;&#125;console.log(Object.getOwnPropertySymbols(obj)) // []var symbol = Symbol('s')obj[symbol] = 'ss'console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(s)] Reflect.ownKeys 返回一个对象所有的自有属性组成的数组。其实就相当于Object.getOwnPropertyNames(target).cancat(Object.getOwnPropertySymbols()) 123456789101112Reflect.ownKeys(&#123;z: 3, y: 2, x: 1&#125;); // [ \"z\", \"y\", \"x\" ]Reflect.ownKeys([]); // [\"length\"]var sym = Symbol.for('comet');var sym2 = Symbol.for('meteor');var obj = &#123;[sym]: 0, 'str': 0, '773': 0, '0': 0, [sym2]: 0, '-1': 0, '8': 0, 'second str': 0&#125;;Reflect.ownKeys(obj);// [ \"0\", \"8\", \"773\", \"str\", \"-1\", \"second str\", Symbol(comet), Symbol(meteor) ]// Indexes in numeric order, // strings in insertion order, // symbols in insertion order 观察上面的例子，需要注意的是：当一个对象的属性由各种类型的字符串和symbol组成时，返回的数组元素按照这样的顺序来排列：索引字符串（从0开始，-1被列入字符串属性）属性按照从小到大，其次是字符串属性按照最初插入的顺序，最后才是symbol属性按照最初插入的顺序。 Object.getOwnPropertyNames(obj) 该方法会返回obj自身（不包括原型链上的属性）所有的属性（包括不可枚举的属性）组成的字符串数组。返回的数组的元素的顺序和for…in遍历时的顺序一致。 包括不可枚举的属性1234567891011var obj = Object.create(null, &#123; getFoo: &#123; value: function()&#123; return this.foo &#125;, enumerable: false &#125;&#125;)obj.foo = 1console.log(Object.getOwnPropertyNames(obj))// prints: [\"getFoo\", \"foo\"] 不包括原型链上的属性12345678function Foo()&#123; this.foo = 'foo'&#125;Foo.prototype.getFoo = function()&#123; return this.foo&#125;console.log(Object.getOwnPropertyNames(new Foo()))// prints: ['foo']","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"encodeURIComponent","slug":"encodeURIComponent","date":"2017-05-20T06:36:29.000Z","updated":"2017-06-07T01:52:15.000Z","comments":true,"path":"2017/05/20/encodeURIComponent/","link":"","permalink":"https://xxxxxmiss.github.io/2017/05/20/encodeURIComponent/","excerpt":"","text":"encodeURIComponent概述 是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码） 语法1encodeURIComponent(str) NOTE: encodeURIComponent不转义以下字符： 字符 编码 字母 — 数字 — ( %28 ) %29 . %2e ! %21 ~ %7e * %2a ‘ %27 - %2d _ %5f 手动转义encodeURIComponent未转义的字符 因为encodeURIComponent并不对!, ~, *, (, ), &#39;等这些字符转义，而已这些字符也没有被正式划定URI的用途，所以当你需要对这些字符转义的时候，可以按照下面的方法： 123456function fixedEncodeURIComponent(str)&#123; return encodeURIComponent(str) .replace(/[!\\(\\)\\*~']/g, function(c)&#123; return '%' + c.charCodeAt(0).toString(16) &#125;)&#125; 手动解码encodeURIComponent编码的字符 URI中常见的一些字符，如?, &amp;, ‘#’等，如果使用encodeURIComponent转义，那么uri就变得不是那么直观了，为了使uri直观易读，我们可以手动反转这些字符： 1234function fixedEncodeURIComponent(str)&#123; return encodeURIComponent(str) .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent)&#125; 常见字符在encodeURIComponent中编码的字符对照表 字符 编码 # %23 $ %24 &amp; %26 + %2B : %3A &lt; %3C = %3D / %2F ? %3F @ %40 [ %5B ] %5D ^ %5E ` %60 { %7B } %7D &#124; %7C 关于charCodeAt()方法 charCodeAt() 方法返回0到65535(0xffff)之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。Unicode 编码单元（code points）的范围从 0 到 1,114,111（0x10FFFF）。开头的 128(0-127) 个 Unicode 编码单元和 ASCII 字符编码一样。 语法1str.charCodeAt(index) 参数index解释： index: &gt;=0 &amp;&amp; &lt; st.length 如果不是一个数值，则默认为0。 如果是一个超出范围的数值，那么返回NaN。 返回值：给定索引处字符的 UTF-16 代码单元值的数字 关于字符编码的相关问题 这是一个很大的话题，可以参考以下几个链接。 为什么 UTF-8 编码比 UTF-16 编码应用更广泛?字符编码笔记：ASCII，Unicode和UTF-8","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"flex布局","slug":"flex","date":"2017-05-14T03:59:30.000Z","updated":"2017-10-11T07:52:32.000Z","comments":true,"path":"2017/05/14/flex/","link":"","permalink":"https://xxxxxmiss.github.io/2017/05/14/flex/","excerpt":"","text":"伸缩性flex 用来控制伸缩容器额外空间如何沿着伸缩容器的布局轴成比例的分配给各个伸缩项目。 123456789101112131415flex: none;等价于flex-grow: 0;flex-shrink: 0;flex-basis: auto;flex: 0 auto;或者flex: 0 1 auto;或者flex: initail;等价于(也就是说他们单属性的默认值值分别是)flex-grow: 0;flex-shrink: 1;flex-basis: auto; 12345flex: auto;等价于flex-grow: 1;flex-shrink: 1;flex-basis: auto; 12345flex: 1;等价于flex-grow: 1;flex-shrink: 1;flex-basis: 0%; 123456flex: 2 100px;等价于flex-grow: 2;flex-shrink: 1;flex-basis: 100px;`","categories":[{"name":"css","slug":"css","permalink":"https://xxxxxmiss.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://xxxxxmiss.github.io/tags/css/"}]},{"title":"Framework7","slug":"framework7","date":"2017-04-29T08:31:38.000Z","updated":"2017-05-02T03:53:22.000Z","comments":true,"path":"2017/04/29/framework7/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/29/framework7/","excerpt":"","text":"启动 由于所有的页面都是通过ajax的形式拉取到主页面中显示，所以必须将启动一个服务器将工程部署到服务器上。framework7默认使用gulp构建项目的，所以可以如下进行本地开发： 12345// 在工程的根路径下安装依赖npm/yarn install // 启动服务gulp server 视图布局单视图布局 使用最广泛的布局，使用单一视图 + 路由 + 头部导航(navbar) + 底部导航(toolbar) + 侧边栏(panel) tabbar切换 这种方式的视图布局，每个tabbar都有自己独立的“单视图布局” 分屏布局 这种方式一般使用在屏幕比较大的时候，比如ipad，最大优点是可以同时显示多个视图（一般左右两边） 内联页面 这种方式下，页面不需要通过ajax加载过来，其他页面直接写在dom中 内建的模板引擎加载视图 使用f7内置的模板引擎来加载指定的视图 View &lt;div class=&quot;view&quot;&gt;, 视图是app独立的可视化部分，每个view都可以有自己的设置,导航，不同的样式，布局等。这种功能可以让你很容易的在app中插入各种各样的视图。 Views &lt;div class=&quot;views&quot;&gt;&lt;/div&gt;, 是所有view的容器，也就是app容器，在任何时候该容器都是可见的。一个app当然只能有一个容器，即只允许有一个views。 page &lt;div class=&quot;page&quot;&gt;&lt;/div&gt;, page跟view不同，page没有navbar,tabbar等导航，它主要用来显示页面的内容部分。 Pages &lt;div class=&quot;pages&quot;&gt;, 是page的容器，一个pages可以包含多个page,就相当于一个页面中的内容可以被分成多个部分的内容来显示。所有page的过渡动画都是在pages上实现的。Note: 在主views中，总是应该包含一个view，在这个view中总是应该包含一个pages。 data-page 在每个page上，你都应该指定一个data-page属性，虽然这不是必须的，但是极其推荐都加上他。因为在page events和page callbacks中非常有用，他帮助我们操作去加载指定的页面和操作指定的页面。 page-content 所有可见的内容都应该放在&lt;div class=&quot;page-content&quot;&gt;中，并且将该元素作为&lt;div class=&quot;page&quot; data-page=&quot;index&quot;&gt;的子元素。列表的滚动就是在改元素上实现的。 一个基本的视图骨架12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; ... //这些面板可以理解为全局性的，不管你如何切换视图，他们都是保持不变的 // 被覆盖的面板 &lt;div class=\"panel panel-lef panel-reveal\"&gt; &lt;div class=\"view view-panel\"&gt;...&lt;/div&gt; &lt;/div&gt; // 覆盖别人的面板 &lt;div class=\"panel panel-right panel-cover\"&gt; &lt;div class=\"view view-panel\"&gt;...&lt;/div&gt; &lt;/div&gt; &lt;!-- views --&gt; &lt;div class=\"views\"&gt; &lt;!-- main view --&gt; &lt;div class=\"view view-main\"&gt; &lt;!-- Navbar --&gt; &lt;!-- Pages --&gt; &lt;div class=\"pages\"&gt; &lt;div class=\"page\" data-page=\"home\"&gt; ... page contents goes here ... &lt;/div&gt; &lt;/div&gt; &lt;!-- Toolbar --&gt; &lt;/div&gt; &lt;!-- other view --&gt; &lt;div class=\"view another-view\"&gt; &lt;!-- Navbar --&gt; &lt;!-- Pages --&gt; &lt;div class=\"pages\"&gt; &lt;div class=\"page\" data-page=\"home-another\"&gt; ... page contents goes here ... &lt;/div&gt; &lt;/div&gt; &lt;!-- Toolbar --&gt; &lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; 初始化View views已经在html中准备完毕，那么接下来就需要在js中对其初始化。需要注意的是，并不是所有的views都是需要初始化的，我们应该只初始化那些需要导航的视图。像这些panel,popup等,我们并不需要初始化的，只需要保证一个正确的布局就可以了。 初始化app和view123var myApp = new Framework7(&#123; //....&#125;) 这个myApp实例上有一系列的方法让我们来操作app的各个视图，其中初始化视图的方法为：1var view = myApp.addView(selector, params) selecotr: css选择器或者Dom节点 params: 一个控制视图参数的对象 return: 返回初始化的视图实例 对params中的2个选项进行下分析: preroute: function(view, options),该选项类似于Vue中路由钩子函数beforeRouteEnter, 允许在进入某个路由的前做一些操作。 preprocess: function(content, url, next), 该选项类似于Vue中的生命周期函数beforeMount, 允许在视图渲染到dom前做最后的一些操作。 关于params中的其他的选项，可参看官方文档 默认视图url 可以在view元素上设置data-url或则在初始化视图的时候指定url选项来指定默认的视图。 1&lt;div class=\"view\" data-url=\"index.html\"&gt;&lt;/div&gt; 访问视图实例 myApp.views[name] | myApp[nameView] 12345678var myApp = new Framework7()myApp.addView('.left-view', &#123;&#125;)// 访问视图实例myApp.views.left// 或者myApp.leftView 需要注意的是，主视图的实例的访问一定是这样的myApp.mainView或者myApp.views.main。即使你初始化视图的时候，指定了其他的名字也是无效的。 通过dom元素来得到指定的视图实例 在视图初始化之后，F7会在&lt;div class=&quot;view&quot;&gt;的元素上增加一个特殊的链接属性，所以我们在js中任何时候都可以这样来获取视图实例： 12var viewEl = $$('.main-view')[0]var viewInstance = viewEl.f7View 同时，所有视图的实例都会挂载到app实例的views属性上，而对于主视图又是很特殊，所有我们也可以通过下面的方式来后去主视图： 12345var views = myApp.viewsfor(var i = 0; i &lt; views.length; i++)&#123; var view = views[i] if(view.main) myApp.alert('I found the main view')&#125; 页面事件 关于页面最重要的部分就是页面事件，通过执行js代码来操作指定的页面。 示例:123456789// 方式一$$(document).on('page:init', function(e)&#123; // do something here when page loaded and initialized&#125;)// 方式二$$(document).on('page:init', '.page[data-page=\"about\"]', function(e)&#123; // do something here when page with data-page=about attribute loaded and initialized&#125;) page data 上面的关于页面事件的使用很简单，但是使用一个事件处理函数来处理页面的加载，那么如何处理页面加载的优先级？这就是page data排上用场的时候了。。。 实例:12345678910// in page callbacks:myApp.onPageInit('about', function(page)&#123; // \"page\" variable contains all required information about loaded and initialized page&#125;)// in page events$$(document).on('page:init', function(e)&#123; // \"page\" variable contains all required information about loaded and initialized page var page = e.details.page&#125;) page是一个对象，关于该对象包含了页面的哪些信息，参看官方文档 page callbacks 为指定的页面执行指定的代码，使用page callbacks更加的方便友好，他比page events有以下几点好处： page callbacks不是事件，这就意味着更少的内存利用和更少出现内存溢出 因为不是事件，所以你无需担心需要解绑他们 使用page callbacks可以更好的组织代码结构 关于一些page callbacks的说明： myApp.onPageBeforeInit(pageName, callback(page)) 仅仅当F7将含有data-page=pageName的页面插入到DOM中时触发回调，此时仅能保证page元素已经插入到DOM，并不能保证该page中的其他组件插入到DOM中。 myApp.onPageInit(pageName, callback(page)) 和onPageBeforeInit的区别是page和page中的其他组件也都插入到DOM中了。 myApp.onPageReInit(pageName, callback(page)) 该回调只适用于开启缓存的内联的模板页面。 Note: 我们可以为page callbacks传入多个以空格分割的pageName和多个callback，还可以为pageName传入通配符.1234567891011121314151617// 因为某些页面可能有一些相同的逻辑myApp.onPageInit('about services', function(page)&#123;&#125;)// 为同一个页面增加多个回调myApp.onPageInit('about', function(page)&#123; console.log('a') &#125;)myApp.onPageInit('about', function(page)&#123; console.log('b') &#125;)// 通过通配符为所有页面添加相同的回调myApp.onPageInit('*', function(page)&#123; console.log('all pages')&#125;) page callbacks具体api可以参看官方文档 路由API F7中常见的4中路由方式: ajax加载页面（默认使用的方式）：从其他文件中加载页面 使用js api创建动态的页面 使用内联页面，就是这些页面已经存在在DOM中，不需要通过额外的加载。就相当于是静态的页面，只需要控制显示隐藏而已 使用Template7模板加载页面 在一个app中，你可以灵活的组合使用这些方式。因为视图view是一个app中独立的可视化部分，所以当你使用路由之前，一定要先初始化视图，初始化视图之后，就可以使用视图提供的方法导航到app中的各个部分（pages, popup, panels）等。 具体的路由方法，参看官方文档 F7中使用ajax加载页面 在F7中，默认情况下所有的链接都使用ajax加载，除了指定了external的链接或则没有正确的href属性的链接（href=”#”或则为空）。这种行为当然是可以改变的，可以通过在初始化app的时候指定ajaxLinks选项来改变这种行为。例子： 1234new Framework7(&#123; // 这个属性的值是一个css选择器 ajaxLinks: 'a.ajax' //含有ajax类名的a链接才会使用ajax加载&#125;) 返回上一步 在F7中，返回上一步只要在指定的a链接上增加一个back类名就可以了。但是关于返回链接有几点需要注意的： 1&lt;a href=\"index.html\" class=\"back\"&gt;&lt;/a&gt; 当导航历史中已经有了记录的时候，href属性的值是被忽略掉的。当导航历史中没有记录的时候，才会使用href属性的值，比如首页的时候。这种行为是不可改变的，因为通常情况下，用户点击返回就是返回上一步，并不需要做一些额外额操作。也就是说，对于回退链接而言，href属性并不是必须的。 IOS主题下的swipeback 在iOS主题下，你可以配置swipeback选项来滑动切换页面，但是有时候你可能需要禁用这种行为，那么可以这样： 1234// 在page上增加一个no-swipeback即可&lt;div class=\"page no-swipeback\"&gt; &lt;/div&gt; 加载、回退时禁用过渡效果 取消加载，回退时的过渡效果，可以设置全局的noAnimate或者配置animatePages选项。当你想局部禁用或者开启某些页面的过渡效果时，可以这样： 12&lt;a href=\"about.html\" class=\"no-animation\"&gt;&lt;/a&gt;&lt;a href=\"about.html\" class=\"back no-animation\"&gt;&lt;/a&gt; 当开启全局禁用，但是想局部开启过渡时：12&lt;a href=\"about.html\" class=\"with-animation\"&gt;&lt;/a&gt;&lt;a href=\"about.html\" class=\"back with-animation\"&gt;&lt;/a&gt; 关于导航还有一些其他的选项，可以通过配置data-前缀来控制，具体参看官方文档 动态加载页面 动态加载的页面url遵循如下规则: #content-,这个占位符会被导航历史中的索引替换。当然在app初始化的选项中通过dynamicPageUrl来改变默认的规则。 示例：123456789101112131415// 可以将字符串提取到单独的模板中，方便书写// &lt;script type=\"text/template\" id=\"contentTpl\"&gt;&lt;div&gt;...&lt;/div&gt;&lt;/script&gt;var newContent = ` &lt;div&gt; &lt;div&gt; //... &lt;/div&gt; &lt;/div&gt;`mainView.router.loadContent(newContent)或者mainView.router.load(&#123; content: newContent, // $$('#contentTpl').html() animatePages: false&#125;) 内联页面 使用这一特征，你可以将所有的页面都放在DOM中，这样app一次性加载全部页面。默认情况下，内联页面的行为是禁止的，你可以在初始化view的时候使用domCache: true来激活。 内联页面结构一般如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=\"views\"&gt; &lt;div class=\"view view-main\"&gt; &lt;div class=\"navbar\"&gt; &lt;!-- 当需要动态的navbar时，这样布局 --&gt; &lt;!-- home-navbar --&gt; &lt;!-- data-page属性需要和对应的page一致 --&gt; &lt;div class=\"navbar-inner\" data-page=\"index\"&gt; &lt;div class=\"center\"&gt;home&lt;/div&gt; &lt;/div&gt; &lt;!-- about-navbar --&gt; &lt;div class=\"navbar-inner cached\" data-page=\"about\"&gt; &lt;div class=\"center\"&gt;about&lt;/div&gt; &lt;/div&gt; &lt;!-- services-navar --&gt; &lt;div class=\"navbar-inner cached\" data-page=\"services\"&gt; &lt;div class=\"center\"&gt;services&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 动态navbar的时候，需要navbar-through --&gt; &lt;div class=\"pages navbar-through\"&gt; &lt;!-- home page --&gt; &lt;div class=\"page\" data-page=\"index\"&gt; &lt;div class=\"page-content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- about page --&gt; &lt;div class=\"page cached\" data-page=\"about\"&gt; &lt;div class=\"page-content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- services page --&gt; &lt;div class=\"page cached\" data-page=\"services\"&gt; &lt;div class=\"page-content\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 由上面的结构可以看出，内联页面布局和一般的页面布局没有什么太大的差异，唯一的不同点就是所有需要的页面已经存在于DOM中，非激活页面含有一个cached类名。 关于内联页面的其他配置 ajax加载页面中的选项如返回导航，data-配置等，都可以在内联页面中使用。同时，内联页面也可以通过ajax来加载，内联页面的其他配置不需要做改动，唯一需要改变的就是增加js代码： 123mainView.router.load(&#123; pageName: 'test'&#125;) 通过js来控制内联页面的返回1mainView.router.back() Template7模板引擎 F7已经内置了Template7模板引擎，所以你需要额外安装，当然你可以单独的安装Template7。Template7模板引擎的语法类似handlebars模板引擎的语法。Template7模板引擎轻量高效，最慢的地方就是使用Template7.compile()将字符串模板解析为原生的js函数，所以一定要记得缓存编译后的js函数，不要对一个相同的模板多次编译。 F7自动编译Template7模板 在F7中，可以自动编译Template7模板，只需要做如下4件事：1,将模板字符串放在script标签中2,设置type=&quot;text/template7&quot;3,给script标签一个唯一的id4,初始化app的时候配置选项precompileTemplates: true 编译后的模板函数都会挂载到Template7.templates和myApp.templates对象上，所以你可以将所需数据传入编译后的函数，调用函数获取html字符串。 实例：12345678910111213141516// 模板&lt;script type=\"text/template7\" id=\"personTemplate\"&gt; &lt;div&gt;hello, my name is &#123;&#123;name&#125;&#125;, i am &#123;&#123;age&#125;&#125; years old&lt;/div&gt;&lt;/script&gt;// 初始化appvar myApp = new Framework7(&#123; precompileTemplates: true&#125;)// 获取编译函数并调用// Template7.templates[id], id为script标签中指定的idvar personHtml = Tempate7.templates.personTemplate(&#123; name: 'f7', age: 10&#125;) Template7 pages F7提供了一系列方式允许我们渲染ajax页面和动态页面作为Template7模板。激活这一功能，必须在初始化app的时候配置template7Pages: true。 F7和Template7的使用 在F7中使用Template7，常用的几种方式如下： index.html12345678910111213141516171819202122232425&lt;div class=\"pages\"&gt; &lt;!-- 首页 --&gt; &lt;div class=\"page\" data-page=\"index\"&gt; &lt;!-- about页面 --&gt; &lt;a href=\"#\" data-template=\"about\" data-context-name=\"about\"&gt;&lt;/a&gt; &lt;!-- services页面 --&gt; &lt;a href=\"services.html\" data-context-name=\"services\"&gt;&lt;/a&gt; &lt;!-- cars页面 --&gt; &lt;a href=\"cars.html\"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/template7\" id=\"about\"&gt; &lt;div class=\"navbar\"&gt; &lt;div class=\"navbar-inner\"&gt; &lt;div class=\"left\"&gt; &lt;/div&gt; &lt;div class=\"center\"&gt; about page &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pages\"&gt; &lt;div class=\"page\" data-page=\"about\"&gt; &lt;span&gt;My name is &#123;&#123;name&#125;&#125;, i am &#123;&#123;age&#125;&#125; years old!&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; cars.html(services.html结构一样，不再列出)12345678910111213141516171819&lt;div class=\"navbar\"&gt; &lt;div class=\"navbar-inner\"&gt; &lt;div class=\"left\"&gt; &lt;a href=\"#\" class=\"back link\"&gt; &lt;i class=\"icon icon-back\"&gt;&lt;/i&gt;&lt;span&gt;返回&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"center\"&gt;services page&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"pages\"&gt; &lt;div class=\"page\" data-page=\"services\"&gt; &lt;ul&gt; &#123;&#123;#each this&#125;&#125; &lt;li&gt;&#123;&#123;this&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; JS代码：12345678910111213141516var myApp = new Framework7(&#123; animateNavBackIcon: true, // 开启返回按钮的icon动画效果 precompileTemplates: true, // 开启自动编译模板 template7Pages: true, // 开启使用ajax，动态页面作为template7模板 template7Data: &#123; // 模板数据 'url: services.html': &#123; // 通过url匹配页面 &#125;, 'page:cars': ['', '', ''], // 通过data-page匹配页面 about: &#123; // 简单的数据，页面中需提供data-context-name来指定模板的上下文 name: 'F7', age: 2 &#125; &#125;, //.... 其他的配置项&#125;)","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://xxxxxmiss.github.io/categories/前端框架/"}],"tags":[{"name":"framework7","slug":"framework7","permalink":"https://xxxxxmiss.github.io/tags/framework7/"},{"name":"hybrid","slug":"hybrid","permalink":"https://xxxxxmiss.github.io/tags/hybrid/"}]},{"title":"webpack性能优化","slug":"webpack-optimize","date":"2017-04-29T04:25:21.000Z","updated":"2017-04-29T04:26:36.000Z","comments":true,"path":"2017/04/29/webpack-optimize/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/29/webpack-optimize/","excerpt":"","text":"","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-entry-context","slug":"webpack2-entry-context","date":"2017-04-24T08:32:33.000Z","updated":"2017-04-24T09:24:54.000Z","comments":true,"path":"2017/04/24/webpack2-entry-context/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/24/webpack2-entry-context/","excerpt":"","text":"Entry anc Context 告诉webpack哪个文件作为打包的入口点。 context 一个绝对路径字符串，告诉webpack要打包的文件都是基于该路径的，就相当于是一个基础路径。如果不提供该选项，那么相对于当前工作目录（项目的跟路径）。推荐提供该选项，这样可以将你的配置文件和当前的工作路径独立开来。 1context: path.resove(__dirname, 'app') entry 指定打包的入口点, 最简单的规则就是：单页应用一个入口点，多页应用多个入口点。可以提供多种类型，如下 string [string] object () =&gt; string | [string] | object 生成的chunk名称 如果entry提供的是一个字符串或者字符串数组，那么生成的chunk名称是main。如果entry提供的是一个对象，那么对象的key作为chunk名称，value作为chunk的打包入口。 1234567module.exports = &#123; entry: './index.js', // entry: ['./index.js', 'scroller.js'] output: &#123; filename: '[name].js' // [name]会被替换为main &#125;&#125; 123456789module.exports = &#123; entry: &#123; index: './index.js', contact: './contact.js' &#125;, output: &#123; filename: '[name].js' // [name]会被替换为index, contact &#125;&#125; 动态入口 // TODO updating…","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"linux进程","slug":"linux-process","date":"2017-04-23T05:39:13.000Z","updated":"2017-04-23T17:10:00.000Z","comments":true,"path":"2017/04/23/linux-process/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/23/linux-process/","excerpt":"","text":"进程简介 在unix或者linux系统中，每当运行一个程序，系统都会为这个程序创建一个特殊的环境，这个特殊的环境包含了运行该程序所依赖的一切东西。不论什么时候，你触发一个unix或者linux命令，都会创建或者启动一个新的进程。所以可以这样理解，一个进程，就是一个运行中的程序的实例，它包含了该程序执行所需要的一切依赖。 进程追踪 操作系统给每个进程分配一个5位数字的pid来标示每个进程，每个进程都有唯一的pid。最终这5位数字组成的pid会被穷尽，那么到时候又会重头开始分配，不管怎样，同一时间不会出现pid相同的进程。 前台进程 默认情况下，每个进程运行在前台，接受用户的键盘输入然后将结果显示在屏幕上。 后台进程 一个后台进程的运行无需接受键盘的输入。后台进程的最大的好处就是无需等待当前进程处理完毕就可以执行其他的命令。如果某个后台进程需要接受一个输入，那么它会处于一个暂停状态直到它被切换到前后进程并且接受到从键盘输入的数据。 启动后台进程启动一个后台进程最简单的方式就是在一个命令的末尾加上&amp;符号。 比如在终端下输入ls -l &amp;1234$ ls -l &amp;[2] 30721 // 第一行[1] Done ls -l // 第二行$ // 第三行 其中的第一行的[2]表示job number,它是用来操作前后台进程切换的。第二行表示ls -l命令后台进程成功的执行完成第三行是等待下一个命令的输入 列出运行中的进程 通过ps(process status)命令很容易就可以列出运行中的进程。ps命令有一些常用选项，最常用的是-f具体选项如下 选项 描述 -f full, 列出详细的信息 -a all, 显示所有用户的信息 -x —- -u —- -e —- 以上的这些选项，-x, -e列出了一大堆信息，包括系统进程的，具体什么东西目前不是很清楚（TODO）。-u在mac下测试不支持，或许是打开方式不对。。。 通过ps -f会在终端下显示如下信息1234567UID PID PPID C STIME TTY TIME CMD501 26649 26648 0 四12上午 ttys000 0:00.68 -bash501 11212 11210 0 15 417 ttys001 0:00.31 -bash501 11267 11266 0 15 417 ttys002 0:00.11 -bash501 11545 11544 0 15 417 ttys003 0:00.19 -bash501 24268 24267 0 三12下午 ttys004 0:00.39 -bash501 16770 16766 0 一11上午 ttys007 0:00.92 -bash 关于以上每列所代表的含义如下: 标识符 描述 UID 该进程属于哪个用户的，也就是说该进程是哪个用户启动的，用户ID PID 进程ID（process id） PPID 该进程的父进程ID（parent process id） C 进程利用的CPU STIME 进程启动的时间 TTY 进程所使用的终端类型 TIME 进程占用的CPU时间 CMD 启动该进程所使用的命令 终止进程 终止一个进程有很多种方式，常用的如下 直接通过按键CTRL + C 通过kill pid 举例如下12345// ①$ps -f501 16770 16766 0 一11上午 ttys007 0:00.92 -bash// ②$kill 16770 但是有时候通过kill pid并不能终止一个进程，那么此时可以加个参数-9:1$kill -9 16770 父进程和子进程 在unix或者linux系统中, 每个进程会被分配2个id，pid(process id), ppid(parent process id), 每个用户进程都会有一个父进程。 常驻进程(Daemon Processes) 常驻进程作为系统级别的进程，以root权限运行，为其他的进程服务。常驻进程是无法通过终端来控制的。你通过ps -ef来查看进程信息，可以看到所有的常驻进程的tty列显示的都是? 123$ps -efUID PID PPID C STIME TTY TIME CMD0 1 0 0 18 217 ?? 92:25.03 /sbin/launchd 其他的一些进程 ….(不列了) top命令 top命令是一个非常有用的工具命令，它列出了进程相关的一切信息，它将进程，CPU等相关的信息实时的显示在终端。","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/tags/linux/"}]},{"title":"ASI(auto semicolon insertion)自动分号补齐","slug":"js-ASI","date":"2017-04-20T15:32:09.000Z","updated":"2017-06-11T12:17:42.000Z","comments":true,"path":"2017/04/20/js-ASI/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/20/js-ASI/","excerpt":"","text":"ASI 在ASI的机制中有一类语句叫做restricted productions（不知道中文叫啥）。简单来说，就是组成这类语句的两个token当中不允许出现换行符 \\n。如果在第一个token后面遇到了换行符，则判断语句结束，插入分号。restricted productions包括： return xxx(xxx是要返回的对象) throw xxx(xxx是要抛出的错误对象) break / continue xxx(xxx是循环的标签) 关于ASI最需要注意的坑 ASI真正需要注意的坑只有两个，restricted productions是其一，另一个就是当下一行开头是 (, [ , / 这三个字符之一的时候： 12a = b(function()&#123;...&#125;()) 会被解析成1a = b(function()&#123;...&#125;()) 就是说()会被看着是在调用函数b。同理，[]会被看着实在获取b的属性。斜杠/则会被当成除号： 12a = b/Error/i.test(str) &amp;&amp; doSomething() 会被解析成1a = b / Error / i.test(str) &amp;&amp; doSomething() 要躲开这个坑，其实真的挺简单，只要尽量别用这三个字符作为一行开头就行了。事实上遇到比较多的也只有括号开头。真的避不开的话，可以在行头手动加个分号： 12a = b;(function()&#123;...&#125;()) 额外的一点是在for循环声明里面的分号是永远不能省的，ASI不会在for循环声明中插分号，但一般正常人不会把for的声明分三行写吧… 原文链接参考文章ECMA规范文档","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"linux系统中常用的配置文件","slug":"linux-config","date":"2017-04-19T17:23:39.000Z","updated":"2017-04-23T05:39:50.000Z","comments":true,"path":"2017/04/20/linux-config/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/20/linux-config/","excerpt":"","text":"~, / 以下讲解的都是针对用户级别的~, 不讲解系统级别的/。一些用户级别的配置，在系统级别也有相同的配置，就类似于全局变量和局部变量的关系。 ~/.bash_profile 每个用户都可使用该文件配置自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,并且执行用户的~/.bashrc文件。 ~/.bash_logout 每次退出bash shell时，执行该文件。(测试并未生效，难道是测试姿势不对？？) ~/.bashrc 可以在其中配置一些别名等信息，但是配置不会立即生效，必须登录后才会生效。如果要使其立即生效，那么可以执行以下命令： 123source ~/.bashrc或者. ~/.bashrc source x.sh, . x.sh 和 sh x.sh, ./x.sh的区别 用source执行脚本文件，执行过程不另开进程，脚本文件中设定的变量在当前shell中可以看到；用sh执行脚本文件，是在当前进程另开子进程来执行脚本命令，脚本文件中设定的变量在当前shell中不能看到。source也经常用.来代替，所以以上四种执行脚本的关系就是:前面两种是相同的效果用脚本文件名本身执行(如果shell脚本具有可执行权限)和用sh命令执行脚本的作用完全相同(后面2种是相同的效果) /etc/profile 类似于~/.bash_profile, 不过是系统级别的。 /etc/hosts 配置host相关信息","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/tags/linux/"}]},{"title":"linux常用命令","slug":"linux-command","date":"2017-04-19T17:21:30.000Z","updated":"2017-04-23T05:40:04.000Z","comments":true,"path":"2017/04/20/linux-command/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/20/linux-command/","excerpt":"","text":"创建软链接 为某一个文件或目录在另外一个位置建立一个同步的链接，类似Windows下的快捷方式。-s选项表示创建的是软链接（符号链接）, 不加-s表示创建的是硬链接,我们常用的都是软链接。 1ln -s 源文件 目标文件 删除软连接 Note: 目标文件或目录后面不能带/, 否则就是删除该目录下的所有文件了。 1rm -rf 目标文件或目录","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/tags/linux/"}]},{"title":"shell重定向","slug":"shell-redirect","date":"2017-04-15T03:10:47.000Z","updated":"2017-04-19T17:31:14.000Z","comments":true,"path":"2017/04/15/shell-redirect/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/15/shell-redirect/","excerpt":"","text":"重定向列表 命令 说明 command &gt;&gt; file 将输出以追加的方式重定向到file n &gt;&gt; file 将文件描述符为n的文件已追加的方式重定向到file n &lt;&amp; m 将输入文件m 和 n 合并 &lt;&lt; tag 将开始标记tag和结束标记tag之间的内容作为输入 3个特殊文件 文件类型 文件描述符 简介 标准输入(stdin) 0 程序默认从stdin读取数据 标准输出(stdout) 1 程序默认向stdout输出数据 标准错误(stderr) 2 程序会向stderr流中写入错误信息 /dev/null 文件 如果希望执行某个命令，但是又不希望在屏幕上输出结果，那么可以将输出重定向到/dev/null。/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 12屏蔽stdout和stderr //？？？？？？未测试成功command &gt; /dev/null 2&gt;&amp;1","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"sails","slug":"sails","date":"2017-04-14T16:42:53.000Z","updated":"2017-04-19T17:31:55.000Z","comments":true,"path":"2017/04/15/sails/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/15/sails/","excerpt":"","text":"sails(v0.12) 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748├── Gruntfile.js├── README.md├── api // 核心│ ├── controllers // 充当model和view的桥梁│ ├── models│ ├── policies│ ├── responses│ └── services├── app.js├── assets│ ├── favicon.ico│ ├── images│ ├── js│ ├── robots.txt│ ├── styles│ └── templates├── config│ ├── blueprints.js│ ├── bootstrap.js│ ├── connections.js│ ├── cors.js│ ├── csrf.js│ ├── env│ ├── globals.js│ ├── http.js│ ├── i18n.js│ ├── local.js│ ├── locales│ ├── log.js│ ├── models.js│ ├── policies.js│ ├── routes.js│ ├── session.js│ ├── sockets.js│ └── views.js├── config.yaml├── package.json├── tasks // 不启用grunt,可以直接删除tasks文件夹│ ├── README.md│ ├── config│ ├── pipeline.js│ └── register└── views // 不需要服务端渲染,可以直接删除views文件夹 ├── 403.ejs ├── 404.ejs ├── 500.ejs ├── homepage.ejs └── layout.ejs controller 由一系列被称为action的方法构成,action和routes绑定在一起，所以当请求某一个路由时，触发对应的对应的路由方法，并返回一个响应(这里的响应主要指路由的分发) controller的定义 在sails中controller定义在controller文件夹下，按照约定，全部采用pascal-case写法（及每个单词的首字母都是大写），并且必须必须以Controller.js结尾。 NOTE: 可以将controller分文件夹定义，那么此时子文件夹也会成为路由标示的一部分。 代码演示SayController.js1234567891011// 一个controller就是一个纯对象，对象的属性为action的名字，值为对应的action的处理函数module.exports = &#123; // req, res跟express中的一样，不过没有第三个参数next // 如果有next的需求，那么应该见该逻辑写到policies中 hi: function (req, res) &#123; return res.send('Hi there!'); &#125;, bye: function (req, res) &#123; return res.redirect('http://www.sayonara.com'); &#125;&#125; 隐式路由（sails自动绑定）12/:controllerIdentity/:nameOfAction/controller标识符/action的名字 拿上面的SayController.js来说，那么当程序启动时，就会自动绑定到这样的路由/say/hi, /say/bye。如果上面的controller在一个子文件夹中/we中，那么就会绑定到这样的路由/we/say/hi, /we/say/bye 显式路由（自定义路由） 手动绑定路由，可以在config/routes.js中按照如下规则进行路由的配置:http请求方法（POST,GET等）+ 路由地址 : controller的名字+.+action的名字 1234'POST /make/a/sandwith': 'SandwichController.makeIt'// 当controller在子文件夹中定义时，子文件夹是controller的一部分'/do/homework': 'stuff/things/HomeworkController.do' 显式路由常见定义方式12345678module.exports.routes = &#123; 'get /signup': &#123; view: 'conversion/signup' &#125;, 'post /signup': 'AuthController.processSignup', 'get /login': &#123; view: 'portal/login' &#125;, 'post /login': 'AuthController.processLogin', '/logout': 'AuthController.logout', 'get /me': 'UserController.profile'&#125; 自定义响应和responses文件夹 一般情况下，controller中的响应都会定义在responses文件夹中.任何定义在/api/responses.js中方法都是通过res.[responsesName]这种形式在controller中调用的。在responses函数中，可以使用this.req, this.res来获取Request和Response对象。 数据库适配器Adapters 可以连接不同的数据库，主要用来和数据库之间的通信。在adapter中，我们主要关注的是CRUD操作。在sails中，主要指这个几个方法create(), find(), update(), destroy() 可选的Adapter 官方支持的数据库器 数据库名称 简介 sails-disk sails默认捆绑的，不需要做任何的配置。直接将数据写入磁盘，不适合用在生成环境，一般用在开发环境或者一些小的项目中 sails-memory 将数据写入内存中，不会正在的持久化，所以一般适合用在开发环境或者磁盘空间不足的时候 sails-mysql 链接mysql（关系型数据库） sails-postgres 链接postgres(关系型数据库) sails-mongo 链接mongo(非关系型数据库) sails-redis 链接redis 社区支持的数据库 全局变量 全局变量可以在sails加载完毕之后全局访问，这些全局变量都可以在config/globals.js中禁用。 models(文件名作为全局变量名) services(文件名作为全局变量名) sails _(Lodash实例，默认提供，无需安装) async(Async实例，默认提供，无需安装) NOTE: 必须等到sails加载完成之后，才可以访问这些全局变量。也就是说，不能再导出的函数外部使用（此时sails尚未加载完毕）,必须导出的函数内部使用 1234567// 禁用所有module.exports.globals = falsemodule.exports.globals = &#123; _: false, // 禁用具体的 async: true&#125; 日志（Logging） sails内建一个日志输出，可以在/config/logs.js中配置日志输出等级。详情参看sails内建日志 原则（Policies） 该文件夹中定义的脚本主要用来处理一些权限认证，第三方单点登录等具有一些通用逻辑，有点类似于spring中的AOP。policies只应该在controller的actions中使用，不应该在views中使用。如果是在config/routes.js中直接定义的视图，那么就无法使用policies了。如果想要继续使用使用policies,因该使用controller+.+action的方式。如下: 123456789// routes.jsmodule.exports.routes = &#123; // 这种形式无法使用policies '/': 'homepage', // 可以这种方式 'POST /article/comment': 'ArticleController.comment'&#125; Policies的定义 定义在api/policies目录下，每个policy应该对应一个文件，只处理一件事情，导出为单一的函数。事实上，每个policies都是作为Connect/Express中间件的函数，在controller之前执行。 1234// 只处理一件事情，导出为单一函数module.exports = function canWrite(req, res, next)&#123;&#125; api/policies和config/policies.js的关系 在config/policies.js中配置controller和policies之间的映射关系。就是说哪些controller使用哪些policies来做权限控制。 1234567module.exports.policies = &#123; CommentController: &#123; // controller名称 \"*\": 'isLoggedIn', // 对controller中所有的action生效 create: 'isLoggedIn', // key: action名称， value: policies tag: ['isLoggedIn', 'isAdmin'] &#125;&#125; 1234567module.exports.policies = &#123; \"*\": 'isLoggedIn', // 映射到所有的controller中的actions CommentController: &#123; // 如果某一个action显式的声明了policy, 那么全局的`isLoggedIn`不会映射到该action上 create: 'isAdmin' &#125;&#125; Services 一个导出各种函数的纯对象，对象中的每个方法被称为helper。因为是全局的，所以可以在各个地方使用：controller的actions, 其他的services, 自定义的model方法中，甚至在命令行脚本中。 Service的创建 在api/services文件夹中创建，文件名必须以Service.js结尾。 Service函数参数说明12345678910111213var Mailgun = require('machinepack-mailgun');module.exports = &#123; sendWelcomeEmail: function (options, done) &#123; Mailgun.sendHtmlEmail(&#123; toEmail: options.emailAddress, toName: options.firstName &#125;).exec(function (err) &#123; if (err) &#123; return done(err); &#125; return done(); &#125;); &#125;&#125; sendWelcomeEmail方法中option,done参数说明： option: 一个自定义属性的对象。 done: 一个函数。这个一个可选的参数，当helper为一个异步方法时，那么当helper被调用时，必须传入done回调函数作为第二个参数。 按照nodejs的约定，done中第一个参数为一个error对象，第二个参数为需要的数据结果。 Session在sails中，session主要由一下3部分要素组成： session store: 保存信息 管理session的中间件 每次请求都会携带cookie,并且session id（默认的sails.sid）都会被存储到cookie中 session store既可以是内存（sails中默认使用内存存储）,也可以是数据库。sails在Connect中间件的最顶层管理session，包括将session id保存到cookie中。 Viewsviews的使用,一般有2种方法： res.view(), 由于可以在各个都可以使用res对象，所以可以用这种方式方式将view编译成功html返回给客户端 在/config/routes.js中对路由进行配置 locals 在模板引擎中使用的变量称为locals, sails默认传入一些变量作为locals,比如lodash。如果某些数据是通过硬编码的方式填充到模板中，那么可以在config/routes.js中配置： 12345678910111213141516module.exports.routes = &#123; 'get /profile': &#123; view: 'backOffice/profile', locals: &#123; // 硬编码的数据，可以直接通过locals配置 user: &#123; name: 'Frank', emailAddress: 'frank@enfurter.com' &#125;, corndogs: [ &#123; name: 'beef corndog' &#125;, &#123; name: 'chicken corndog' &#125;, &#123; name: 'soy corndog' &#125; ] &#125; &#125;&#125; 在模板中使用动态数据 大多数时候，数据都是动态获取到的（通过action从model中获取），所以大多时候是按照如下方式进行渲染数据的： 12345678910// in api/controllers/UserController.js... profile: function (req, res) &#123; // ... return res.view('backOffice/profile', &#123; user: theUser, corndogs: theUser.corndogCollection &#125;); &#125;, // ... Partials(模板包含) 支持模板包含，及在一些模板中，将另外一些模板包含进来，达到模板的复用。在sails中使用模板包含，需要注意的就是路径都是相对于view文件夹的。如 1234// views/partials/widget.ejs// views/pages/dashboard/user-profile.ejs&lt;%- partial('../../partials/widget.ejs') %&gt; 关于EJS模板 在ejs中，模板的标签就以下3种： &lt;%= %&gt;: 转义输出 &lt;%- %&gt;: 不转义输出 &lt;% %&gt;: 里面直接写js代码 models文件夹 全局访问 services文件夹 全局访问 responses文件夹 里面的方法都会挂载到controller的req对象上","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"},{"name":"sails","slug":"sails","permalink":"https://xxxxxmiss.github.io/tags/sails/"}]},{"title":"JS中变量提升","slug":"variable-hoist","date":"2017-04-05T15:05:04.000Z","updated":"2017-06-11T12:20:00.000Z","comments":true,"path":"2017/04/05/variable-hoist/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/05/variable-hoist/","excerpt":"","text":"变量的生命周期 声明阶段：这一阶段在作用域中注册一个变量。 初始化阶段：这一阶段分配了内存并在作用域中让内存与变量建立了一个绑定。这一步变量自动被初始化为undefined。 赋值阶段：这一阶段为初始化的变量分配一个具体的值。 var变量生命周期 当 JavaScript 遇到了一个函数作用域，其中包含了 var variable 的语句。则在任何语句执行之前，这个变量在作用域的开头就通过了声明阶段并马上来到了初始化阶段（步骤一）。 同时 var variable 在函数作用域中的位置并不会影响它的声明和初始化阶段的进行。 在声明和初始化阶段之后，赋值阶段之前，变量的值便是 undefined 并已经可以被使用了。 在赋值阶段 variable = &#39;value&#39; 语句使变量接受了它的初始化值（步骤二）。 这里的变量提升严格的说是指变量在函数作用域的开始位置就完成了声明和初始化阶段。在这里这两个阶段之间并没有任何的间隙。 1234567(function()&#123; // 在这之前，就已经完成了变量的提升（经过了声明和初始化阶段，此时变量已经可以使用了，并且值为undefined） console.log(a) // undefined var a a = 10 // 赋值 console.log(a) // 10&#125;)() 函数声明的生命周期 声明、初始化和赋值阶段在封闭的函数作用域的开头便立刻进行（只有一步）。 funName()可以在作用域中的任意位置被调用，这与其声明语句所在的位置无关（它甚至可以被放在程序的最底部）。 123456(function sumArray(array) &#123; return array.reduce(sum) //9 function sum(a, b) &#123; return a + b &#125;&#125;)([1, 3, 5]) let变量的生命周期 let 变量的处理方式不同于 var, 它的主要区分点在于声明和初始化阶段是分开的。当解释器进入了一个包含 let variable语句的块级作用域中。这个变量立即通过了声明阶段，并在作用域内注册了它的名称（步骤一）。 然后解释器继续逐行解析块语句。 在这个阶段尝试访问 variable，JavaScript 将会抛出 ReferenceError: variable is not defined。因为这个变量的状态依然是未初始化的。 此时 variable 处于临时死区(从块的开始到声明这段)中。 当解释器到达语句 let variable时，此时变量通过了初始化阶段（步骤二）。现在变量状态是初始化的并且访问它的值是 undefined。 同时变量在此时也离开了临时死区。 之后当到达赋值语句 variable = &#39;value&#39; 时，变量通过了赋值阶段（步骤三）。 如果 JavaScript 遇到这样的语句 let variable = &#39;value&#39; ，那么变量会在这一条语句中同时经过初始化和赋值阶段。12345678910let condition = true;if (condition) &#123; // 一但进入if块作用域中，number变量立即通过了声明阶段，此时number变量处于暂存死区中 // 此时试图访问该变量会抛出 ReferenceError: number is not defined. // console.log(number); // =&gt; Throws ReferenceError let number; console.log(number); // =&gt; undefined number = 5; console.log(number); // =&gt; 5&#125; 例子123456(function()&#123; const a = 5 console.log(a) let a console.log(a)&#125;)() 上面的例子不会有任何的输出，会抛出Identifier &#39;a&#39; has already been declared。抛出了这个错误是由于已经用const定义了一个变量a, 再次用let声明变量a抛出的错误。但是这个错误也说明了使用let声明的变量会存在变量提升 let,var比较 let var 定义变量 ✅ ✅ 可被释放 ✅ ✅ 可被提升(hoist) ✅(注意暂存死区) ✅ 重复定义检查 ✅ ❎ 可被用于块状作用域 ✅ ❎ 12345678(function()&#123; var i = 1 console.log(i) // 会提升到var语句下面，但是由于已经声明了变量i // 所以抛出Identifier 'i' has already been declared let i = 1 console.log(i)&#125;)() 循环定义中的let作用域 循环体中是可以引用在for声明时用let定义的变量，尽管let不是出现在大括号之间. 1234var i = 0;for (let i = i; i &lt; 10; i++) &#123; console.log(i); // 抛出`ReferenceError: i is not defined`。&#125; 域作用规则1for (let expr1; expr2; expr3) statement 在for循环中，expr1, expr2, expr3, statement都被包含在一个隐藏的块作用域中。所以上面的例子推荐写成如下： 1234var i = 0; for (let l = i; l &lt; 10; l++) &#123; console.log(l); &#125;","categories":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xxxxxmiss.github.io/tags/js/"}]},{"title":"深入理解z-index","slug":"z-index","date":"2017-04-05T06:25:57.000Z","updated":"2017-11-13T09:47:33.000Z","comments":true,"path":"2017/04/05/z-index/","link":"","permalink":"https://xxxxxmiss.github.io/2017/04/05/z-index/","excerpt":"","text":"z-index基本规则 如果定位元素z-index没有发生嵌套（就是说一个定位元素的子元素的position都是static）,那么此时遵守的规则为： 后来居上的准则 哪个大，哪个上 如果定位元素发生了嵌套 祖先优先原则（z-index的值非auto） 如果z-index: auto,那么就不遵守祖先优先的原则了 12345678// z-index的值非auto&lt;div style=\"position: relative; z-index: 1\"&gt; &lt;img src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" style=\"position: absolute; z-index: 2\"&gt; // z-index: 2&lt;/div&gt;&lt;div style=\"position: relative; z-index: 1\"&gt; &lt;img src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" style=\"position: absolute; left: 100px; z-index: 1\"&gt; // z-index: 1&lt;/div&gt; 上面的例子，虽然第一个图片的z-index:2，第二个图片的z-index: 1，但是由于发生了嵌套，祖先元素都是z-index: 1，所以第二个图片覆盖在第一个图片上面。 12345678// z-index的值为auto&lt;div style=\"position: relative; z-index: auto\"&gt; &lt;img src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" style=\"position: absolute; z-index: 2\"&gt; // z-index: 2&lt;/div&gt;&lt;div style=\"position: relative; z-index: 1\"&gt; &lt;img src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" style=\"position: absolute; left: 100px; z-index: 1\"&gt; // z-index: 1&lt;/div&gt; 上面的例子，同第一个例子一样，唯一不同的地方就是第一个图片祖先元素的z-index:auto, 那么此时第一个图片在覆盖第二个图片。解释：z-index: auto当前层叠上下文生成的盒子层叠水平是0。盒子（除非是根元素）不会创建一个新的层叠上下文。 z-index中涉及到的重要概念 层叠上下文（stacking context）：html中元素在z轴上的堆叠顺序。 页面根元素（可以理解为html或者为body）天生具有层叠上下文，称之为”根层叠上下文“。 z-index为数值的定位元素具有层叠上下文。 一些其他属性的元素 层叠水平（stacking level）：层叠上下文中的每个元素都有一个层叠水平，层叠水平决定了同一个层叠上下文中的元素在z轴上的堆叠顺序。 层叠顺序（stacking order）：元素发生层叠时有着特定的垂直显示顺序。 层叠上下文的几个特性 层叠上下文可以嵌套，组合成一个分层次的层叠上下文。 每个层叠上下文和兄弟元素独立：当进行层叠变化或者渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的：当元素的内容被层叠后，整个元素被认为是在父层的层叠顺序中。 7阶层叠水平(stacking level) 为什么层叠顺序是这样的？ 可以这样理解：background,border等主要用来装饰元素，block盒子float元素主要用来布局，而inline, inline-block主要用来展示内容，而内容是页面中最重要的实体，所以应该让其层叠水平更高。 123456789101112131415161718192021.block, .inline-block&#123; height: 200px;&#125;.block&#123; width: 300px; background-color: rgba(37,148,233, .4); margin-top: -13px;&#125;.inline-block&#123; display: inline-block; width: 200px; background-color: #ff8200;&#125;&lt;div class=\"inline-block\"&gt; display: inline-block&lt;/div&gt;&lt;div class=\"block\"&gt; display: block&lt;/div&gt; 上面的例子: inline-block的元素会覆盖在block元素的上面，但是block元素中的文字并没有被覆盖。因为文字是属于inline元素，对照7阶层叠上下文可以知道inline的堆叠顺序和inline-block是一个等级的，并且block元素出现在inline-block元素的后面，按照后来居上的规则，inline-block元素并不会覆盖block元素中的文字。 z-index元层叠上下文的关系 定位元素默认z-index:auto可以看成是z-index: 0。 z-index不为auto的定位元素创建层叠上下文。 z-index层叠顺序的比较止步于父级层叠上下文。 123456789101112131415161718.box&#123; position: absolute; background-color: blue; /*z-index: 0;*/ width: 200px; height: 100px; display: inline-block;&#125;.img&#123; position: relative; margin-left: -100px; z-index: -1; width: 200px;&#125;&lt;div class=\"box\"&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt; &lt;/div&gt; 上面的例子，如果box不加上z-index:0,那么此时的层叠上下文就是body元素，那么z-index:-1的元素会处于body元素的下面，所以box元素覆盖图片。但是如果box元素加上z-index:0, 那么此次层叠上下文就变成了box元素，那么按照7阶层叠水平, background是处于最底层的，所以z-index:-1的图片会覆盖背景。 12345678910111213141516171819202122232425.box1&#123; position: relative; z-index: 0;&#125;.box1 img&#123; position: absolute; z-index: 99999;&#125;.box2&#123; position: relative; z-index: 1;&#125;.box2 img&#123; position: absolute; left: 250px; z-index: -1;&#125;&lt;div class=\"box1\"&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt;&lt;/div&gt;&lt;div class=\"box2\"&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt;&lt;/div&gt; 上面的例子，虽然box1中的img图片的z-index:99999很大，但是其父元素的z-index: 0没有第二个图片的父元素box2的z-index:1大，所以依然是第二个图片覆盖第一个图片。 其他参与层叠上下文的属性 z-index值不为auto的flex项（父元素display:flex|inline-flex）123456789101112131415161718// 设置为flex的父元素，可以改变子元素z-index不为auto的元素参数参与堆叠上下文.box&#123; /*display: flex;*/ background-color: blue;&#125;.box &gt; div &#123; z-index: 1;&#125;.box &gt; div &gt; img&#123; position: relative; z-index: -1;&#125;&lt;div class=\"box\"&gt; &lt;div&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 当没有为box设置display: flex时，此时层叠上下文为根元素（html或者body），所以img设置为z-index:-1会堆叠在根元素下面，也就是背景会覆盖图片。但如果设置box为display: flex,那么此时display:flex的子元素z-index不为auto的元素参与堆叠顺序，那么按照7阶堆叠顺序，z-index为负值的会堆叠在background上面。 opacity != 1123456789101112.box&#123; background-color: blue; /*opacity: .9;*/&#125;.box &gt; img&#123; position: relative; z-index: -1;&#125;&lt;div class=\"box\"&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt;&lt;/div&gt; 当没有给box元素设置opacity:.9时，那么此时box为非层叠上下文元素，那么img会层叠到根层叠上下文元素的下面，所以box会覆盖img。一旦设置了box的opacity: .9是，此时层叠上下文为box元素，那么按照7阶堆叠顺序, 负的z-index会覆盖在background的上面。 剩下的transform != none, mix-blend-mode != normal, filter != none, isolation: isolation, position: fixed, will-change: 任意支持过渡的元素, -webkit-overflow-scrolling: touch同理。 非定位元素层叠上下文和z-index的关系 不依赖z-index的层叠上下文元素的层叠顺序均是z-index:auto级别。（可以查看上面的”其他属性创建层叠上下文的图“, 需要注意的是flex, 他是依赖z-index的） 依赖z-index的层叠上下文元素的层叠顺序取决于z-index的值。123456789101112131415161718.a&#123; position: absolute; z-index: 1; top: 10px; left: 40px;&#125;.box&#123; display: flex; /*普通元素*/ background-color: blue;&#125;.box &gt; img&#123; z-index: 1; /*flex项是层叠上下文元素*/&#125;&lt;img class=\"a\" class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt;&lt;div class=\"box\"&gt; &lt;img class=\"img\" src=\"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png\" alt=\"\"&gt;&lt;/div&gt;","categories":[{"name":"css","slug":"css","permalink":"https://xxxxxmiss.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://xxxxxmiss.github.io/tags/css/"}]},{"title":"shell运算符","slug":"shell-operation","date":"2017-03-30T13:10:24.000Z","updated":"2017-04-19T17:31:41.000Z","comments":true,"path":"2017/03/30/shell-operation/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/30/shell-operation/","excerpt":"","text":"表达式 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。一个完整的表达式需要用反引号(`)包裹, 在mac系统中，求值表达式也可以这样$(($a + $b))。表达式和运算符之间必须有空格，如2+2是不对的，必须写成2 + 2。乘号（*）在表达式中必须转义 expr $a \\* $b,否则抛出syntax error 条件表达式 条件表达式必须放在方括号内，并且之间要有空格 123# 方括号的前后也必须含有空格,可以有多个空格[ $a == $b ] // right[$a==$b] // error 布尔运算符 运算符 说明 ！ 非运算 -o 或运算, 记忆：or(-o) -a 与运算, 记忆：and(-a) 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字 运算符 说明 -eq equal, 是否相等 -ne not equal, 不相等 -gt greater than, 大于 -lt less than, 小于 -ge greater equal, 大于等于 -le less equal, 小于等于 字符串运算符 假设a=”abc”, b=”efg” 运算符 说明 举例 = 检测2个字符串是否相等， 相等返回true [ $a = $b ], false != …., 不相等返回true [ $a != $b ], true -z 字符串的长度为0，返回true. 记忆: zero [ -z $a ], false -n …..不为0，返回true. 记忆: not [ -n $a ], true str 字符串不为空，返回true [ $a ], true","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"shell传递参数","slug":"shell-params","date":"2017-03-30T12:31:56.000Z","updated":"2017-04-19T17:31:21.000Z","comments":true,"path":"2017/03/30/shell-params/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/30/shell-params/","excerpt":"","text":"脚本获取参数格式$n n为从0开始的数字，$0：获取执行的脚本名称；$1获取第一个参数，$2获取第二个参数,以此类推。。。 几个特殊的字符用来处理参数 这些特殊的字符也可以用在shell函数中 字符 描述 $# 传递到脚本的个数 $* 以“$1 $2 … $n”的形式输出所有传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程ID号 $@ 以“$1” “$2” “$n”的形式输出所有参数 $- 显示shell使用的当前选项，与set命令功能相同 $? 显示最后命令退出的状态。 0表示没有错误，其他任何值表明有错误","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"shell变量","slug":"shell-variable","date":"2017-03-29T16:21:20.000Z","updated":"2017-04-19T17:30:55.000Z","comments":true,"path":"2017/03/30/shell-variable/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/30/shell-variable/","excerpt":"","text":"变量的定义1your_name=\"rou\" 变量名只能有字母和下划线_组成，且不能使用bash里的关键字 变量名和等号之间不能有空格 使用变量123your_name=\"rou\"echo $your_nameecho $&#123;your_name&#125; // 推荐使用这种方式 只读变量1readonly myUrl=\"www.baidu.com\" 删除变量1unset varibale_name 变量被删除后不能再次使用。unset命令不能删除只读变量 Shell字符串 shell中字符串即可用单引号包裹，也可以用双引号包裹 当引号中包裹的字符中照原样输出 双引号包裹的字符串可以包含变量 获取字符串的长度12my_str=\"this is a test string\"$&#123;#my_str&#125; 提取字符串12str=\"my name is test\"$&#123;str:1:4&#125; // 从第2个位置开始截取4个字符串（下标索引从0开始） Shell数组1234567array_name=(value1 value2 valu3...)或者array_name=( value1 value2 value3) 获取数组中所有的元素12array=(a b c)$&#123;array[@]&#125; 或者 $&#123;array[*]&#125; 获取数组的长度 和获取字符的长度语法是一致的 123456# 获取数组的长度$&#123;#array[@]&#125; 或者 $&#123;#array[*]&#125;# 获取数组中某个元素的长度$&#123;#array[n]&#125; // 下标n从0开始`","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"shell基本知识","slug":"shell-overview","date":"2017-03-29T15:54:33.000Z","updated":"2017-04-19T17:31:32.000Z","comments":true,"path":"2017/03/29/shell-overview/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/29/shell-overview/","excerpt":"","text":"常见Linux Shell种类 Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root (/sbin/sh) 第一个Shell脚本12#!/bin/shecho 'Hello World !' “#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell 运行Shell脚本的2种方法 作为可执行程序 123// 将上面的脚本保存为test.shchmod +x ./test.sh // 使脚本具有可执行的权限./test.sh // 执行脚本 作为解释器参数 12/bin/sh test.sh/bin/php test.php 这种方式运行的脚本，不需要再第一行指定解释器的信息，即使指定了也没用","categories":[{"name":"linux","slug":"linux","permalink":"https://xxxxxmiss.github.io/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxxxxmiss.github.io/tags/shell/"}]},{"title":"webpack2-server","slug":"webpack2-server","date":"2017-03-22T03:00:47.000Z","updated":"2017-04-24T11:31:51.000Z","comments":true,"path":"2017/03/22/webpack2-server/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-server/","excerpt":"","text":"devServer 12345678// webpack.server.jsvar config = require('./webpack.config')var webpack = require('webpack')var WebpackDevServer = require('webpack-dev-server')var compiler = webpack(config)var server = new WebpackDevServer(compiler, devServer) devServer.clientLogLevelstring Default: info,可选值有none, error, warning, info指定终端输出日志信息的等级, 设置为none, 表示什么日志都不输出。 devServer.compressboolean 放到服务器上的文件全部使用gzip压缩 devServer.contentBaseboolean string array 将哪些文件放到服务器上，默认使用当前工作目录。你可以像下面这样修改文件目录 1234contentBase: path.join(__dirname, 'public')// 或则contentBase: [path.join(__dirname, 'public'), path.join(__dirname, 'assets')] devServer.filenamestring 模块的编译默认是处于lazy模式，就是每次请求的时候才会编译。通过该选项，可以配置每次请求的时候编译某个具体的文件，而不是编译所有的文件。 12lazy: true,filename: 'bundle.js' 注意：该选项只有在lazy: true时才有效 devServer.noInfoboolean 除了错误信息和警告信息，其他的信息都不在输出。 devServer.quietboolean 不在输出任何信息，包括错误信息和警告信息。 devServer.statsstring object 这个选项可以让你精确的控制在编译的过程中哪些信息应该显示在终端。就相当于可以局部的控制应该显示哪些编译信息，而不是总体的设置。如果激活了quiet, noInfo选项，那么该选项就失效了 具体有哪些选项可以使用，可以参看这里 devServer.watchContentBaseboolan 监听contentBase下的文件变动情况，一旦有文件发生了改动，就立即重新编译并刷新页面。 devServer.watchOptionsobject 配置文件监听的相关选项。 watchOptions.aggregateTimeoutnumber Default: 300（毫秒数）在这个300内发生的多次改动，不会重新编译，而是汇聚到一起做一次编译。 watchOptions.ignored 忽略对某些文件的监听，因为监听一个很大的文件夹是很浪费内存和消耗CPU 支持正则和通配符使用ignored: /node_modules/ ignored: &#39;files/**/*.js&#39; watchOptions.pollboolean number 在某些文件系统，比如NFS中，监听如果不能正常工作，可以开启该选项。 poll: true 12// 每隔1000ms检查一次文件是否改动poll: 1000","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-resolve","slug":"webpack2-resolve","date":"2017-03-22T03:00:15.000Z","updated":"2017-04-24T11:31:37.000Z","comments":true,"path":"2017/03/22/webpack2-resolve/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-resolve/","excerpt":"","text":"[TOC] resolve 配置模块解析策略。比如，import lodash, 可以通过配置resolve.modules来指定当解析lodash是，去哪个路径下去寻找lodash。 resolve.aliasobject 配置模块的别名,这样当使用import或者require就可以使用别名来代替冗长的相对路径。比如你import某一路径下的一个js文件:import ../../src/js/index.js如果没有配置别名，那么你每次引入src/js这个路径下的某个js,都需要写很长的路径,通过配置别名，你可以简化书写。 12345678module.exports = &#123; resolve: &#123; alias: &#123; js: path.resolve(__dirname, 'src/js'), css: path.resolve(__dirname, 'src/css') &#125; &#125;&#125; 没有配置别名之前import { getData } from &#39;../../src/js/fetData&#39;配置别名后import { getData } from &#39;js/fetData&#39; 在配置别名，关于填写文件路径的各种写法，可以移步这里 resolve.aliasFieldsstring 指定某些属性，用来配置别名所指定的js文件解析的环境。 aliasFields: [&#39;browser&#39;] 直接这么一句话，很难理解什么意思，详细的意思可以参阅这里 resolve.descriptionFilesarry 指定用哪个json文件作为描述文件。一般情况下使用默认值即可，不需要显式的配置。 descriptionFiles: [&#39;package.json&#39;] resolve.enforceExtensionsboolean 指定是否必须使用扩展名。比如一般情况下，我们会像这样引入某个js, import &#39;lodash&#39;, 但是如果你指定了enforceExtensions: true，那么你就必须这样引入import &#39;lodash.js&#39; resolve.extensions 自动解析文件扩展名，默认值[‘.js’, ‘.json’]。意思就是比如你import _ from &#39;../path/file&#39;, 会先去path下寻找file.js文件，没有找到，那么继续寻找file.json文件，都没找找到抛出Module not found: Error: Can&#39;t resolve &#39;xx&#39; in &#39;xxx&#39;错误。NOTE: 一旦你配置了该选项，那就意味着webpack不在使用默认的解析机制。比如你配置为extensions: [&#39;.txt&#39;], 那么webpack就只会去寻找xx.txt,并不会去寻找xx.js,xx.json,即使你指定的文件夹下有xx.js,xx.json，因为默认的选项已经被你重写了，只会按照你配置的选项来解析。node包寻找机制 resolve.mainFields 当你引入某一个包时，使用包下面的哪一个文件。配置: mainFields: [&#39;module&#39;, &#39;browser&#39;, &#39;main&#39;]，具体看例子解释。 1import * as D3 from 'd3' 在d3这个package.json中，有这几个选项123\"main\": \"build/d3.node.js\", // 适用node环境\"browser\": \"build/d3.js\", // 适用浏览器环境\"module\": \"index\" // 都支持 以上的几个选项可以分别支持不同的环境，你应该选择你需要的环境选项，通过该选项的配置，可以满足你的需求。 resolve.mainFiles 当解析到的文件是一个目录是，如何处理该目录。默认：mainFiles: [&#39;index&#39;]。关于该选项的具体含义，只要理解了node中包的寻找机制，就能明白该选项的含义。node包寻找机制 这里举例简单说明：index.js1import * as fns from './js' //js是一个文件夹 webpack.config.js123resolve: &#123; mainFields: ['canvas', 'utils']&#125; 当webpack解析到js是一个文件夹时，如果你的mainFields配置如上，那么webpack会去js文件夹下寻找canvas.js，如果没有找到,那么继续寻找js文件夹下的utils.js，如果还没有找到，抛出错误Module not found: Error: &#39;xx&#39; in &#39;xx&#39; resolve.modulesarray 默认配置：modules: [‘node_modules’]告诉webpack在解析模块的时候，去哪些目录搜索这些即将被解析的模块。既可以传入一个相对路径，也可以传入一个绝对路径。但是你要知道的是，他们之间是有一些区别的。相对路径：比如你传入一个./node_modules, webpack会在当前路径下的node_modules下寻找，如果没有找到，会继续搜寻当前目录的父目录下的node_modules,如果还没有找到，依次类推，继续向上搜寻，直至跟目录结束。绝对路径：只会在传入的路径中搜索。 如果你想优先搜索你指定的目录，而不是默认的node_modules, 那么你可以将这个路径插入到默认路径的前面，就像下面这样的modules: [path.resolve(__dirname, &#39;src&#39;), &#39;node_modules&#39;] resolve.unsafeCacheregexp array boolean 开启缓存，但不是那么的安全（现在还不太明白怎么个不安全法） 如果你想缓存所有的解析模块，那么可以这样设置unsafeCache: true 你也可以传入正则表达式或这则表达式的数组来缓存某些解析的模块unsafeCache: /src\\/utils/ resolve.plugins 添加目录命名的一些额外的插件列表。 123resolve: &#123; plugins: [new DirectoryNamedWebpackPlugin()]&#125; resolveLoader[prop]object 这个选项拥有的属性配置和上面的resolve是一样的，不过他只能用来配置webpack的loader包，默认值如下 resolveLoader.moduleExtensions 用来配置loader的扩展名，默认是一个空数组。比如你使用loader的时候，想省去后缀-loader,那么你可以如下配置 123resolveLoader: &#123; moduleExtensions: ['-loader']&#125; NOTE: 在webpack1.x，可以省去-loader后缀，webpack默认会加上。但是在webpack2.x，必须通过上面的这个配置才可以省去。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-module","slug":"webpack2-module","date":"2017-03-22T02:59:48.000Z","updated":"2017-04-24T11:32:08.000Z","comments":true,"path":"2017/03/22/webpack2-module/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-module/","excerpt":"","text":"本章节主要介绍module常用配置项一个工程中的各种modules应该如何被webpack处理。 module.noParseRegExp 让webpack不解析匹配到正则的模块，比如一些第三方库或者辅助模块，我们不需要解析的，那么就可以通过该选项来配置，这样可以节省编译的时间。 noParse: /jquery|backbone/ 这章讲解的内容配置起来是最简单的，但是用文字描述起来并不简单，直接通过配置例子来说明。 webpack1.x常用配置1234567891011module: &#123; loaders: [ &#123; test: /^$/, loader: '', include: [], exclude: [], query: &#123;&#125; &#125; ]&#125; webpack2.x常用配置12345678910111213141516171819202122module: &#123; rules: [ &#123; test: /^$/, // 一定要注意：当使用多个loader解析一个文件时，一定要注意loader的添加顺序，他是【从右往左】依次使用每个loader来解析文件的 use: [ &#123; loader: '', options: &#123;&#125; &#125;, &#123; loader: '' &#125; ], include: [], exclude: [], and: [], or: [], not: '' &#125; ]&#125; webpack2.x常用配置（更常用）1234567891011121314151617module: &#123; rules: [ // 每个对象称之为一个`rule` &#123; test: /^$/, // 使用该选项，当需要几个loader解析一个文件时，可以连写：css!style!sass // 如果替换为use, 那么就不能这么写了，必须写成[&#123;&#125;,&#123;&#125;]的形式 loader: '', include: [condition], // 包括这些 exclude: [condition], // 排condition除这些 and: [condition], // 所有的都包括 or: [condition], // 至少包括一个 not: 'condition', // 不包括 options: &#123;&#125;, // 传入到loader中的选项 //... &#125; ]&#125; 关于rules中每个对象的属性的值，也就是test,loader,include等，都是支持以下几种类型的： 字符串：必须完整的匹配该字符串，比如一个文件或者文件夹的绝对路径 正则：正则匹配 函数：必须有匹配的返回值 数组：至少一个条件被匹配 对象：所有的属性都应该被匹配，每个属性定义一种行为 关于rule中的condition的说明：condition中会存在2中输入： 资源(resource): 请求文件的绝对路径，依据resolve选项进行解析的 发布者(issuer): 包含请求文件的文件的绝对路径。 以上的2句话很难理解，直接看例子，比如在app.js中有一句导入css语句：app.js1import './style.css' 资源就是/path/to/style.css发布者就是/path/to/app.js 在一个rule中，test,include,resource等都是用来处理资源的，而issuer是用来处理发布者的。 考虑到兼容性，很多属性都是可以相互替换的。如rules|loaders, query|options等。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-output","slug":"webpack2-output","date":"2017-03-22T02:59:12.000Z","updated":"2017-04-26T16:23:37.000Z","comments":true,"path":"2017/03/22/webpack2-output/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-output/","excerpt":"","text":"本章节主要介绍output常用配置项 output.filenamestring 用来指定打包生成的文件的名称。默认值是[name].js,该默认值的含义并不是说你可以不指定该选项就使用默认的[name].js ，他的含义是当entry配置为单入口时（单个字符串或者字符串数组），就是[name]会被替换为mian；多入口时，[name]会被替换为对象的key值。 单入口的时候，我们可以静态的指定一个输出模块名称 filename: bundle.js 多入口的时候，可以通过下面的形式来指定输出模块名称 12// 使用entry中指定的keyfilename: '[name].bundle.js' 12// 使用内部生成的idfilename: '[id].bundle.js' 12# 使用每次编译自动生成的hash值filename: '[name].[hash].bundle.js' 12// 使用基于模块内容生成的chunkhashfilename: '[chunkhash].bundle.js' 虽然该选项叫filename, 但是可以指定一个输出目录, 就像这样的js/[name]/bundle.js。当使用了[hash]或者[chunkhash]占位符时，可以指定占位符的长度，默认是20位。 12345678output: &#123; filename: '[hash:10]' //局部指定hash的长度 &#125;或者output: &#123; hashDigestLength: 15 // 全局指定hash的长度&#125; 占位符 描述 hash 基于文件名进行hash chunkhash 基于文件内容进行hash output.chunkFilenamestring 这个选项主要用来指定动态加载生成的模块名称。该名字在运行中生成，就是当你去请求某一个chunk时，这时候才会去生成chunk的名称。 我们已经知道，在require.ensure(dependencies, callback, chunkName)中可以指定一个chunkName参数 如果指定了这个参数，那么在output中就可以这样来取得123456module.exports = &#123; output: &#123; filename: '[chunkhash].[name].js', chunkFilename: '[chunkhash].[name].js' &#125;&#125; 上面[name]占位符就是你在require.ensure(dependencies, callback, chunkName)中指定的那个chunkName。 如果在require.ensure(dependencies, callback, chunkName)中省略了这个chunkName参数，那么统一使用output.chunkFilename中指定的名称 如果output中也没有指定chunkFilename选项，那么会使用output.filename中除了[name]占位符以外的占位符+[id]占位符作为模块名。1234567module.export = function()&#123; return &#123; output: &#123; filename: '[chunkhash].[name].js' &#125; &#125;&#125; 如上output配置，那么此时动态分割出来的模块名就是[chunkhash].[id].js。 output.path 指定编译后的模块输出目录, 既可以是相对路径，也可以是绝对路径 12345// 相对路径path: './dist'// 绝对路径path: path.resolve(__dirname, 'dist/assets') output.hashDigest 指定hash算法返回的字符编码。默认hex。nodejs中的hash.digest([enconding])支持的编码，此处都支持。enconding支持的有hex,latin1,base64。 output.pathinfoboolean Default: false在编译的代码中创建一些注释信息，在开发中，当你想阅读编译后的源代码，这就显得非常的有用。在生产环境中不要开启该选项。 output.publicPathstring Default: “”这是一个非常重要的选项，主要用在动态加载，加载外部资源，比如加载外部资源（图片,css,js），如果指定了一个错误的值，那么将会得到404的错误。 output.sourceMapFilenamestring Default: ‘[file].map’只有指定了devtool选项，该选项才会生效。用来指定生成的sourcemap文件的名称。当为一个模块生成sourcemap时，可以指定以下占位符[name], [id], [hash], [chunkhash], [file]。一般情况下使用默认值即可，不需要显式地配置，因为用其他的值，当模块不存在时，就出问题了。 output.sourcePrefixstringsourcePrefix: &quot;\\t&quot; 指定生成的sourcemap文件每一行开头的前缀。默认情况下使用空字符串，使用该选项的作用仅仅是使sourcemap中的代码看起来要美观一些。不要使用多行前缀，否则引起问题。一般情况下完全没有必要显式的配置该选项。 剔除无用的模块？ 解决无序引入模块？ 抽取公共模块？","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack-library","slug":"webpack2-library","date":"2017-03-22T02:58:40.000Z","updated":"2017-04-24T11:32:20.000Z","comments":true,"path":"2017/03/22/webpack2-library/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-library/","excerpt":"","text":"[TOC] 本章节主要介绍如何利用webpack来构建自己编写的js库，原文链接可以点击这里 假如我们要实现的一个数字和单词之间的互转(1 &lt;=&gt; one)123456789101112131415\\\\ src/index.jsimport _ from 'lodash'import numRef from './ref.json'export function numToWord(num) &#123; return _.reduce(numRef, (accum, ref) =&gt; &#123; return ref.num === num ? ref.word : accum &#125;, '')&#125;;export function wordToNum(word) &#123; return _.reduce(numRef, (accum, ref) =&gt; &#123; return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num : accum &#125;, -1);&#125; 然后我们可能用下面的这几种方式来使用这个库12345678910111213141516171819202122232425262728// ES2015 modulesimport * as webpackNumbers from 'webpack-numbers';...webpackNumbers.wordToNum('Two') // output is 2...// CommonJS modulesvar webpackNumbers = require('webpack-numbers');...webpackNumbers.numToWord(3); // output is Three...// As a script tag&lt;html&gt;...&lt;script src=\"https://unpkg.com/webpack-numbers\"&gt;&lt;/script&gt;&lt;script&gt; ... /* webpackNumbers is available as a global variable */ webpackNumbers.wordToNum('Five') //output is 5 ...&lt;/script&gt;&lt;/html&gt; 下面来编写webpack配置文件1234567891011121314151617module.exports = function()&#123; return &#123; entry: './src/index.js', output: &#123; filename: 'webpack-numbers.js', path: './dist' &#125;, module: &#123; rules: [ &#123; test: /.json$/, use: 'json-loader' &#125; ] &#125; &#125;&#125; 如果利用上面的配置进行编译，我们会发现lodash.js也会被编译到webpack-numbers.js中。我们自己编写的这个webpack-numbers.js库依赖lodash.js，但是我们不希望lodash的源代码被编译到我们这个库中，而是希望他们分开，在用户下载我们的这个webpack-numbers.js库的同时也将依赖的库lodash.js下载下来。要实现这个需求，我们可以按如下修改配置文件1234567891011121314module.exports = function()&#123; return &#123; ... externals: &#123; 'lodash': &#123; commonjs: 'lodash', commonjs2: 'lodash', amd: 'lodash', root: '_' &#125; &#125; ... &#125;&#125; output.library, output.libraryTarget 因为我们的库可能需要运行在不同的环境下，如CommonJS, AMD, Node.js ,作为一个全局变量，为了让我们编写的库可以运行在不同的环境下，那么我们就需要做相应的配置。 output.library 导出的全局变量的名称 output.libraryTargetstring Default: ‘var’，可选的值有umd, amd, commonjs, commonjs2, commonjs-module, this, var这些值指明了导出的环境, 下面我们依次来看看在各种环境下导出的代码是什么样的 假如我们的配置文件是这样的 12345678910111213141516171819module.exports = function()&#123; return &#123; entry: './ab.js', output: &#123; filename: 'webpack-lib', path: './dist', library: 'abConvert', libraryTarget: 'var' // 当为默认值的时候，可以不指定该属性 &#125;, externals: &#123; 'zepto': &#123; commonjs: 'zepto', commonjs2: 'zepto', amd: 'zepto', root: '$' &#125; &#125; &#125;&#125; 那么各种取值下导出的代码会是这个样子的12345\\\\varvar abConvert = (function(modules)&#123; return ... &#125;)() 123456789101112\\\\umd(function webpackUniversalModuleDefinition(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(require(\"zepto\")); else if(typeof define === 'function' &amp;&amp; define.amd) define([\"zepto\"], factory); else if(typeof exports === 'object') exports[\"abConvert\"] = factory(require(\"zepto\")); else root[\"abConvert\"] = factory(root[\"$\"]);&#125;)() 123\\\\ amddefine('abConvert', ['zepto'], function()&#123;&#125;) 12345\\\\ commonjsexports['abConvert'] = (function(modules)&#123; return ...&#125;)() 12345\\\\ commonjs2module.exports = (function(modules)&#123; return ...&#125;)() 1234567\\\\ commonjs-modulemodule.exports = (function(modules)&#123; return ...&#125;)()Object.defineProperty(module.exports, \"__esModule\", &#123; value: true &#125;) 如果libraryTarget指定为commonjs-module, 那么此时module.exports上会被定义一个__esModule, 表明此时采用的是es2015模块化方式定义的，并且此时的library属性会被忽略。 12345\\\\ thisthis['abConvert'] = (function(modules)&#123; &#125;)() 当指定为this时，代表的是由运行环境决定。比如运行在浏览器中，此时this代表window，如果运行在nodejs环境，那么此时this代表global。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-ensure","slug":"webpack2-ensure","date":"2017-03-22T02:58:05.000Z","updated":"2017-04-24T11:32:32.000Z","comments":true,"path":"2017/03/22/webpack2-ensure/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-ensure/","excerpt":"","text":"[TOC] 懒加载在开发中，经常会遇到这样的需求：比如在React,Vue中的路由加载组件，如果在首次加载的时候，就将一堆的组件全部加载，毫无疑问在打开首页的时候会非常的慢，影响用户体验。为了实现第一次快速的加载，优化用户体验，可以通过动态路由。就是第一次只会加载一些必须的组件，剩下的组件等到需要的时候再去加载。使用webpack提供的require.ensure()可以轻松实现这一要求。 语法require.ensure(dependencies: String[], callback: function(require), chunkName: String) 参数解释 dependencies: 一个字符串数组，在callback中的代码执行之前需要加载的依赖模块 callback: 当dependencies中的模块全部加载完毕之后，执行callback中的代码。callback中会传入一个require函数，我们可以在callback中使用这个require()函数引入其他的依赖模块 chunkName（可选）: 通过require.ensure()生成的模块的名称。在不同的require.ensure()中传入相同的chunkName,可以保证依赖模块按正确的顺序引入到require.ensure()生成的模块中 假如我们有如下的目录结构123456789file structure|js --|| |-- entry.js| |-- a.js| |-- b.jswebpack.config.js|dist 123456789101112\\\\entry.jsrequire('./a')require.ensure([], function(require)&#123; require('./b')&#125;)\\\\a.jsconsole.log('I AM A')\\\\b.jsconsole.log('I AM B') 12345678910\\\\webpack.config.jsmodule.exports = function()&#123; return &#123; entry: './js/entry.js', output: &#123; filename: 'bundle.js', path: './dist' &#125; &#125;&#125; 编译后，我们发现dist下有bundle.js和0.bundle.js。entry.js 和 a.js被编译到bundle.js。b.js被编译到0.bundle.js。 关于require.ensure()需要注意的点 空数组作为参数123require.ensure([], function(require)&#123; require('./a.js')&#125;) 上面的代码，webpack会创建一个模块，并且a.js被分割到这个模块中 依赖作为参数 123require.ensure(['./a.js'], function(require)&#123; require('./b.js')&#125;) 上面的代码，a.js,b.js会被编译到一个共同的模块中，并且从entry.js中分割出来。但是只有b.js中的内容被执行，a.js中的内容并不会执行。如果需要执行a.js，那么我们必须通过像这样require(&#39;./a.js&#39;)以同步的方式来引入a.js。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"webpack2-conding-split","slug":"webpack2-coding-split","date":"2017-03-22T02:57:18.000Z","updated":"2017-04-24T11:32:42.000Z","comments":true,"path":"2017/03/22/webpack2-coding-split/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/webpack2-coding-split/","excerpt":"","text":"[TOC] 代码分割 一个应用有第三方库和程序代码组成，第三方库和程序代码最大的不同就是一般第三方库是不会轻易改动的。 在打包的时候，如果能将这些第三方库和程序代码分开打包，那么就可以利用浏览器的缓存机制来缓存这些不需要经常改动的第三方库文件，这样可以节省很多的打包时间，加快资源加载速度。实现假如在index.js中引用第三方库moment.jsindex.js12var moment = require('monent')console.log(moment().format()) 我们的webapck.config.js配置如下123456789module.exports = function()&#123; return &#123; entry: './index.js', output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125; &#125;&#125; 经过编译之后，你会发现在第三方库moment.js和你的程序代码被打包到一个文件中了。这样做的问题是： 编译后的文件很大，现在的webpack2.x对于编译后的文件很大，会在控制台输出如下的警告信息 WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).This can impact web performance.Assets: 2f22b134462399733764.main.js (443 kB) 每当程序代码只要改动一点点，都会重新编译整个文件，浪费时间 多入口对于上面单一entry出现的问题，我们可以通过多入口来缓解这个问题。将webpack.config.js配置文件改成如下配置：123456789101112module.exports = function()&#123; return &#123; entry: &#123; index: './index.js', moment: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125; &#125;&#125; 编译之后，dist文件夹下会出现2个文件，我们查看这两个编译后文件后会发现moment.js也会被编译到[chunkhash].index.js中，这也不是我们想要的结果。为了解决这个问题，可以使用CommonsChunkPlugin插件来解决这个问题。 CommonsChunkPlugin CommonsChunkPlugin是一个相当复杂的插件，他可以将不同模块中相同的代码抽取到一个指定的公共的模块中，如果这个公共的模块不存在，那么它将自动为我们创建一个。 将上面的webpack.config.js修改为如下1234567891011121314151617module.exports = function()&#123; return &#123; entry: &#123; index: './index.js', vendor: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' // 指定抽取到哪个公共模块,必不可少的 &#125;) ] &#125;&#125; 清单文件 Manifest File 当我们修改了程序代码后编译，会发现第三库模块也会被编译，即使我们现在已经将程序代码和第三方库文件分离开了。这样，我们依然不能享受浏览器缓存带来的好处。 问题原因在于：当webpack每次编译时，会自动生成一些运行时代码，这些代码可以可以帮助webpack更好的做他的工作。这意味着这些运行时的代码代码也会被编译到公共模块，比如这个地方的vendor.js。 为了解决这个问题，我们应该将这些webpack自动生成的代码提取到单独的一个文件中（清单文件），这样每次修改程序代码时重新编译的只会是程序代码和清单文件，第三方库文件不会重新编译。webpack.config.js配置文件修改如下1234567891011121314151617module.exports = function()&#123; return &#123; entry: &#123; index: './index.js', vendor: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: '.dist' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'] &#125;) ] &#125;&#125;","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://xxxxxmiss.github.io/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://xxxxxmiss.github.io/tags/webpack/"}]},{"title":"nodejs学习之module模块","slug":"nodejs-module","date":"2017-03-22T02:55:52.000Z","updated":"2017-04-19T17:32:11.000Z","comments":true,"path":"2017/03/22/nodejs-module/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/nodejs-module/","excerpt":"","text":"nodejs有一个简单的模块加载系统。在nodejs中，文件和模块是一对一的关系（每个文件都被视为一个模块） [TOC] 先看一个例子foo.js12const circle = require('./circle.js')console.log(`The area of a circle of radius 4 is $&#123;circle.area(4)`&#125; circle.js12345const PI = Math.PIexports.area = (r) =&gt; PI * r * rexports.circumference = (r) =&gt; 2 * PI * r 说明： circle.js导出了2个方法area(), circumference(), 导出一个模块中的方法或者对象，你可以将他们挂载到exports对象上 如果没有导出一个模块中的方法或则对象，那么他么都是私有的，因为在解析的时候，这些模块都会被一个函数包裹起来。在上面的例子中，PI变量就是私有的，因为他没有挂载到exports对象上。 如果你想导出的就是一个函数，那么重写module.exports即可。因为默认导出的是module.exports, module.exports是一个对象。 看下面的例子bar.js1234const square = require('./square.js');// 因为square.js导出的就是一个函数，所以直接调用。var mySquare = square(2); // 如果导出的是一个对象，那么此处应该这样调用square.square(2)console.log(`The area of my square is $&#123;mySquare.area()&#125;`); square.js123456// assigning to exports will not modify module, must use module.exportsmodule.exports = (width) =&gt; &#123; return &#123; area: () =&gt; width * width &#125;;&#125; 核心模块 如果一个模块中引入了核心模块，那么核心模块总是被优先加载。例如，require(http), 总是会加载nodejs的http模块，即使你有一个模块也叫http // 始终返回核心模块的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445exports.builtinLibs = [ 'assert', 'buffer', 'child_process', 'cluster', 'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'net', 'os', 'path', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib'];function addBuiltinLibsToObject(object) &#123; // Make built-in modules available directly (loaded lazily). exports.builtinLibs.forEach((name) =&gt; &#123; // Goals of this mechanism are: // - Lazy loading of built-in modules // - Having all built-in modules available as non-enumerable properties // - Allowing the user to re-assign these variables as if there were no // pre-existing globals with the same name. const setReal = (val) =&gt; &#123; // Deleting the property before re-assigning it disables the // getter/setter mechanism. delete object[name]; object[name] = val; &#125;; Object.defineProperty(object, name, &#123; get: () =&gt; &#123; const lib = require(name); // Disable the current getter/setter and set up a new // non-enumerable property. delete object[name]; Object.defineProperty(object, name, &#123; get: () =&gt; lib, set: setReal, configurable: true, enumerable: false &#125;); return lib; &#125;, set: setReal, configurable: true, enumerable: false &#125;); &#125;);&#125; 循环加载 指的是一个模块a依赖模块b,而模块b又依赖模块a。 下面通过nodejs官方文档的例子来说明nodejs是如何处理模块的循环加载 a.js123456console.log('a starting');exports.done = false;const b = require('./b.js'); // ①console.log('in a, b.done = %j', b.done);exports.done = true;console.log('a done'); b.js123456console.log('b starting');exports.done = false;const a = require('./a.js'); // ②console.log('in b, a.done = %j', a.done);exports.done = true;console.log('b done'); main.js1234console.log('main starting');const a = require('./a.js');const b = require('./b.js');console.log('in main, a.done=%j, b.done=%j', a.done, b.done); 说明： main.js加载a.js, 进入a.js, 执行到require(&#39;./b.js&#39;)，进入b.js, 执行到require(&#39;./a.js&#39;) 此时发生了循环加载，为了阻止这种无限的循环，nodejs会将a.js中执行过的部分生成一个副本模块返回给b.js 相当于执行a.js执行到①这个地方暂停了，此时a.js中导出的exports.done = false 等到b.js全部执行完毕，在从①暂停的地方继续执行a.js, 此时b.js中exports.done = true 最后执行main.js中为执行的部分 所以最终输出的结果如下12345678index startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done = true, b.done = true nodejs(CommonJS)模块循环加载 VS ES2015模块循环加载","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"}]},{"title":"nodejs学习之path模块","slug":"nodejs-path","date":"2017-03-22T02:28:35.000Z","updated":"2017-04-19T17:32:04.000Z","comments":true,"path":"2017/03/22/nodejs-path/","link":"","permalink":"https://xxxxxmiss.github.io/2017/03/22/nodejs-path/","excerpt":"","text":"nodejs提供了一个path模块来处理文件和目录的路径，通过const path = require(‘path’)来引入该模块。以下介绍的这些方法参数全部为字符串类型，如果不是，会抛出一个TypeError异常 关于POSIX [TOC] path.basename(path[, ext]) 该方法返回一个路径的最后部分，类似于Unix中的basename命令。如果指定了ext部分，那么返回的文件名不带扩展名 path: String ext: String 可选的文件扩展名 Returns: String For example123456path.basename('/foo/bar/baz/afs/quux.html')// Returns: 'quux.html'path.basename('/foo/bar/baz/afs/quux.html', '.html')// Returns: 'quux' path.delimiter 根据系统类型，返回系统的路径分隔符 : POSIX系统 ; Windows系统 For example, on POSIX:12345console.log(process.env.PATH)// Prints: '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'process.env.PATH.split(path.delimiter)// Returns: ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin'] On Windows:12345console.log(process.env.PATH)// Prints: 'C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\node\\'process.env.PATH.split(path.delimiter)// Returns: ['C:\\\\Windows\\\\system32', 'C:\\\\Windows', 'C:\\\\Program Files\\\\node\\\\'] path.dirname(path) 返回一个路径的文件夹部分，类似于Unix中的dirname命令 For example123456path.dirname('/foo/bar/baz/asdf/quux')// Returns: 'foo/bar/baz/asdf'// 路径中的最后一个/会被忽略path.dirname('/foo/bar/baz/asdf/quux/')// Returns: 'foo/bar/baz/asdf' path.extname(path) 返回一个路径中的文件扩展名。如果一个路径字符串的最后部分都不包含该., 或者basename的首个字符是.,那么返回一个空字符串。 For example1234567891011121314path.extname('index.html')// Returns: '.html'path.extname('index.coffee.md')// Returns: '.md'path.extname('index.')// Returns: '.'path.extname('index')// Returns: ''path.extname('.index')// Returns: '' path.join([…paths]) 使用指定平台的路径分隔符将参数中的路径的各个部分连接起来，并规范化连接的结果，使之是一个合法的路径。参数中长度为0的字符串会被忽略。如果连接的结果也是一个长度为0的字符串，那么会返回一个.， 代表当前的工作目录。 需要注意的是，这里多次提到长度为0的字符串&#39;&#39;.length // 0, 空字符串&#39; &#39;.length // 2, 2个空白字符串For example12345678910111213// .. 代表它的上一级目录path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')// Returns: '/foo/bar/baz/asdf'// ../..代表它的上一级目录的上一级path.join('/foo', 'bar', ' ', 'baz/asdf', 'quux', '../..')// Returns: '/foo/bar/ /baz'path.join('foo', &#123;&#125;, 'bar')// throws TypeError: Arguments to path.join must be stringspath.join('/foo', 'bar', ' ', 'baz/asdf', 'quux')// Returns: '/foo/bar/ /baz/asdf/quux' path.normalize(path) 返回一个规范化的路径，会解析.., .这些特殊字符。当路径中出现多个平台分隔符(/on POSIX, \\ on windows), 那么会用当个平台分隔符替换。这个方法会保留路径结尾部分的/, 如果被解析路径的尾部包含., ..，那么解析出来的路径最后的/会被忽略 For exampleon POSIX1234567891011path.normalize('/foo/bar//baz/asdf/quux/..')// Returns: '/foo/bar/baz/asdf'path.normalize('/foo/bar//baz/asdf/quux/.')// Returns: '/foo/bar/baz/asdf/quux'path.normalize('/foo/bar//baz/../asdf/quux/.')// Returns: '/foo/bar/asdf/quux'path.normalize('/foo/bar//baz/asdf/quux/')// Returns: '/foo/bar/baz/asdf/quux/' on Windows12path.normalize('C:\\\\temp\\\\\\\\foo\\\\bar\\\\..\\\\');// Returns: 'C:\\\\temp\\\\foo\\\\' path.resolve([…paths]) 该方法将路径序列或者一个路径序列的各个部分解析到一个绝对路径。该方法解析路径序列是从右往左解析的，直到解析到一个绝对路径。解析到一个绝对路径后就停止解析，并返回这个绝对路径如果所有部分都解析完毕了，依然没有得到一个绝对路径，那么返回就返回当前的工作路径。这个返回的结果路径是被规范化的，并且结尾的/会被移除，除非它是一个跟路径在解析的过程中，长度为0的部分会被忽略如果没有传入任何参数，那么该方法会返回一个代表当前工作目录的绝对路径 For example123456789path.resolve('/foo/bar', './baz')// Returns: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/')// Returns: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')// if the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif' path.relative(from, to) 该方法返回一个从from到to的相对路径，如果from, to分别通过path.resolve解析后得到相同的结果，那么返回一个长度为0的字符串如果from, to中的任何一个传入了一个长度为0的字符串，那么在解析的过程中会使用当前的工作路径取代这个长度为0的字符串需要注意的是，如果from, to任何一部分传入一个相对路径，那么都会被path.resolve解析为一个绝对路径 For exampleon POSIX:123456789path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')// Returns: '../../impl/bbb'path.relative('/data/orandea/test/aaa', '../foo/bar/quux')// if the current working directory is /home/myself/node,// Returns: '../../../../home/myself/foo/bar/quux'path.relative('/foo/bar', '/foo/bar')// Returns: '' On Windows:12path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')// Returns: '..\\\\..\\\\impl\\\\bbb' path.sep 根据不同的平台返回指定平台的路径分隔符 \\on Windows /on POSIX For exampleon POSIX:12'foo/bar/baz'.split(path.sep)// Returns: ['foo', 'bar', 'baz'] On Windows:12'foo\\\\bar\\\\baz'.split(path.sep)// Returns: ['foo', 'bar', 'baz']","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xxxxxmiss.github.io/tags/nodejs/"}]},{"title":"","slug":"zeroclipboard/ZeroClipboard","date":"2014-12-29T01:46:14.000Z","updated":"2014-12-29T01:46:14.000Z","comments":true,"path":"2014/12/29/zeroclipboard/ZeroClipboard/","link":"","permalink":"https://xxxxxmiss.github.io/2014/12/29/zeroclipboard/ZeroClipboard/","excerpt":"","text":"/*! * ZeroClipboard * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface. * Copyright (c) 2009-2014 Jon Rohan, James M. Greene * Licensed MIT * http://zeroclipboard.org/ * v2.2.0 */ (function(window, undefined) { \"use strict\"; /** * Store references to critically important global functions that may be * overridden on certain web pages. */ var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _clearTimeout = _window.clearTimeout, _setInterval = _window.setInterval, _clearInterval = _window.clearInterval, _getComputedStyle = _window.getComputedStyle, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() { var unwrapper = function(el) { return el; }; if (typeof _window.wrap === \"function\" && typeof _window.unwrap === \"function\") { try { var div = _document.createElement(\"div\"); var unwrappedDiv = _window.unwrap(div); if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) { unwrapper = _window.unwrap; } } catch (e) {} } return unwrapper; }(); /** * Convert an `arguments` object into an Array. * * @returns The arguments as an Array * @private */ var _args = function(argumentsObj) { return _slice.call(argumentsObj, 0); }; /** * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`. * * @returns The target object, augmented * @private */ var _extend = function() { var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {}; for (i = 1, len = args.length; i < len; i++) { if ((arg = args[i]) != null) { for (prop in arg) { if (_hasOwn.call(arg, prop)) { src = target[prop]; copy = arg[prop]; if (target !== copy && copy !== undefined) { target[prop] = copy; } } } } } return target; }; /** * Return a deep copy of the source object or array. * * @returns Object or Array * @private */ var _deepCopy = function(source) { var copy, i, len, prop; if (typeof source !== \"object\" || source == null || typeof source.nodeType === \"number\") { copy = source; } else if (typeof source.length === \"number\") { copy = []; for (i = 0, len = source.length; i < len; i++) { if (_hasOwn.call(source, i)) { copy[i] = _deepCopy(source[i]); } } } else { copy = {}; for (prop in source) { if (_hasOwn.call(source, prop)) { copy[prop] = _deepCopy(source[prop]); } } } return copy; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep. * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to * be kept. * * @returns A new filtered object. * @private */ var _pick = function(obj, keys) { var newObj = {}; for (var i = 0, len = keys.length; i < len; i++) { if (keys[i] in obj) { newObj[keys[i]] = obj[keys[i]]; } } return newObj; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit. * The inverse of `_pick`. * * @returns A new filtered object. * @private */ var _omit = function(obj, keys) { var newObj = {}; for (var prop in obj) { if (keys.indexOf(prop) === -1) { newObj[prop] = obj[prop]; } } return newObj; }; /** * Remove all owned, enumerable properties from an object. * * @returns The original object without its owned, enumerable properties. * @private */ var _deleteOwnProperties = function(obj) { if (obj) { for (var prop in obj) { if (_hasOwn.call(obj, prop)) { delete obj[prop]; } } } return obj; }; /** * Determine if an element is contained within another element. * * @returns Boolean * @private */ var _containedBy = function(el, ancestorEl) { if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) { do { if (el === ancestorEl) { return true; } el = el.parentNode; } while (el); } return false; }; /** * Get the URL path's parent directory. * * @returns String or `undefined` * @private */ var _getDirPathOfUrl = function(url) { var dir; if (typeof url === \"string\" && url) { dir = url.split(\"#\")[0].split(\"?\")[0]; dir = url.slice(0, url.lastIndexOf(\"/\") + 1); } return dir; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromErrorStack = function(stack) { var url, matches; if (typeof stack === \"string\" && stack) { matches = stack.match(/^(?:|[^:@]*@|.+\\)@(?=http[s]?|file)|.+?\\s+(?: at |@)(?:[^:\\(]+ )*[\\(]?)((?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/); if (matches && matches[1]) { url = matches[1]; } else { matches = stack.match(/\\)@((?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/); if (matches && matches[1]) { url = matches[1]; } } } return url; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromError = function() { var url, err; try { throw new _Error(); } catch (e) { err = e; } if (err) { url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack); } return url; }; /** * Get the current script's URL. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrl = function() { var jsPath, scripts, i; if (_document.currentScript && (jsPath = _document.currentScript.src)) { return jsPath; } scripts = _document.getElementsByTagName(\"script\"); if (scripts.length === 1) { return scripts[0].src || undefined; } if (\"readyState\" in scripts[0]) { for (i = scripts.length; i--; ) { if (scripts[i].readyState === \"interactive\" && (jsPath = scripts[i].src)) { return jsPath; } } } if (_document.readyState === \"loading\" && (jsPath = scripts[scripts.length - 1].src)) { return jsPath; } if (jsPath = _getCurrentScriptUrlFromError()) { return jsPath; } return undefined; }; /** * Get the unanimous parent directory of ALL script tags. * If any script tags are either (a) inline or (b) from differing parent * directories, this method must return `undefined`. * * @returns String or `undefined` * @private */ var _getUnanimousScriptParentDir = function() { var i, jsDir, jsPath, scripts = _document.getElementsByTagName(\"script\"); for (i = scripts.length; i--; ) { if (!(jsPath = scripts[i].src)) { jsDir = null; break; } jsPath = _getDirPathOfUrl(jsPath); if (jsDir == null) { jsDir = jsPath; } else if (jsDir !== jsPath) { jsDir = null; break; } } return jsDir || undefined; }; /** * Get the presumed location of the \"ZeroClipboard.swf\" file, based on the location * of the executing JavaScript file (e.g. \"ZeroClipboard.js\", etc.). * * @returns String * @private */ var _getDefaultSwfPath = function() { var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || \"\"; return jsDir + \"ZeroClipboard.swf\"; }; /** * Keep track of if the page is framed (in an `iframe`). This can never change. * @private */ var _pageIsFramed = function() { return window.opener == null && (!!window.top && window != window.top || !!window.parent && window != window.parent); }(); /** * Keep track of the state of the Flash object. * @private */ var _flashState = { bridge: null, version: \"0.0.0\", pluginType: \"unknown\", disabled: null, outdated: null, sandboxed: null, unavailable: null, degraded: null, deactivated: null, overdue: null, ready: null }; /** * The minimum Flash Player version required to use ZeroClipboard completely. * @readonly * @private */ var _minimumFlashVersion = \"11.0.0\"; /** * The ZeroClipboard library version number, as reported by Flash, at the time the SWF was compiled. */ var _zcSwfVersion; /** * Keep track of all event listener registrations. * @private */ var _handlers = {}; /** * Keep track of the currently activated element. * @private */ var _currentElement; /** * Keep track of the element that was activated when a `copy` process started. * @private */ var _copyTarget; /** * Keep track of data for the pending clipboard transaction. * @private */ var _clipData = {}; /** * Keep track of data formats for the pending clipboard transaction. * @private */ var _clipDataFormatMap = null; /** * Keep track of the Flash availability check timeout. * @private */ var _flashCheckTimeout = 0; /** * Keep track of SWF network errors interval polling. * @private */ var _swfFallbackCheckInterval = 0; /** * The `message` store for events * @private */ var _eventMessages = { ready: \"Flash communication is established\", error: { \"flash-disabled\": \"Flash is disabled or not installed. May also be attempting to run Flash in a sandboxed iframe, which is impossible.\", \"flash-outdated\": \"Flash is too outdated to support ZeroClipboard\", \"flash-sandboxed\": \"Attempting to run Flash in a sandboxed iframe, which is impossible\", \"flash-unavailable\": \"Flash is unable to communicate bidirectionally with JavaScript\", \"flash-degraded\": \"Flash is unable to preserve data fidelity when communicating with JavaScript\", \"flash-deactivated\": \"Flash is too outdated for your browser and/or is configured as click-to-activate.\\nThis may also mean that the ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity.\\nMay also be attempting to run Flash in a sandboxed iframe, which is impossible.\", \"flash-overdue\": \"Flash communication was established but NOT within the acceptable time limit\", \"version-mismatch\": \"ZeroClipboard JS version number does not match ZeroClipboard SWF version number\", \"clipboard-error\": \"At least one error was thrown while ZeroClipboard was attempting to inject your data into the clipboard\", \"config-mismatch\": \"ZeroClipboard configuration does not match Flash's reality\", \"swf-not-found\": \"The ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity\" } }; /** * The `name`s of `error` events that can only occur is Flash has at least * been able to load the SWF successfully. * @private */ var _errorsThatOnlyOccurAfterFlashLoads = [ \"flash-unavailable\", \"flash-degraded\", \"flash-overdue\", \"version-mismatch\", \"config-mismatch\", \"clipboard-error\" ]; /** * The `name`s of `error` events that should likely result in the `_flashState` * variable's property values being updated. * @private */ var _flashStateErrorNames = [ \"flash-disabled\", \"flash-outdated\", \"flash-sandboxed\", \"flash-unavailable\", \"flash-degraded\", \"flash-deactivated\", \"flash-overdue\" ]; /** * A RegExp to match the `name` property of `error` events related to Flash. * @private */ var _flashStateErrorNameMatchingRegex = new RegExp(\"^flash-(\" + _flashStateErrorNames.map(function(errorName) { return errorName.replace(/^flash-/, \"\"); }).join(\"|\") + \")$\"); /** * A RegExp to match the `name` property of `error` events related to Flash, * which is enabled. * @private */ var _flashStateEnabledErrorNameMatchingRegex = new RegExp(\"^flash-(\" + _flashStateErrorNames.slice(1).map(function(errorName) { return errorName.replace(/^flash-/, \"\"); }).join(\"|\") + \")$\"); /** * ZeroClipboard configuration defaults for the Core module. * @private */ var _globalConfig = { swfPath: _getDefaultSwfPath(), trustedDomains: window.location.host ? [ window.location.host ] : [], cacheBust: true, forceEnhancedClipboard: false, flashLoadTimeout: 3e4, autoActivate: true, bubbleEvents: true, containerId: \"global-zeroclipboard-html-bridge\", containerClass: \"global-zeroclipboard-container\", swfObjectId: \"global-zeroclipboard-flash-bridge\", hoverClass: \"zeroclipboard-is-hover\", activeClass: \"zeroclipboard-is-active\", forceHandCursor: false, title: null, zIndex: 999999999 }; /** * The underlying implementation of `ZeroClipboard.config`. * @private */ var _config = function(options) { if (typeof options === \"object\" && options !== null) { for (var prop in options) { if (_hasOwn.call(options, prop)) { if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) { _globalConfig[prop] = options[prop]; } else if (_flashState.bridge == null) { if (prop === \"containerId\" || prop === \"swfObjectId\") { if (_isValidHtml4Id(options[prop])) { _globalConfig[prop] = options[prop]; } else { throw new Error(\"The specified `\" + prop + \"` value is not valid as an HTML4 Element ID\"); } } else { _globalConfig[prop] = options[prop]; } } } } } if (typeof options === \"string\" && options) { if (_hasOwn.call(_globalConfig, options)) { return _globalConfig[options]; } return; } return _deepCopy(_globalConfig); }; /** * The underlying implementation of `ZeroClipboard.state`. * @private */ var _state = function() { _detectSandbox(); return { browser: _pick(_navigator, [ \"userAgent\", \"platform\", \"appName\" ]), flash: _omit(_flashState, [ \"bridge\" ]), zeroclipboard: { version: ZeroClipboard.version, config: ZeroClipboard.config() } }; }; /** * The underlying implementation of `ZeroClipboard.isFlashUnusable`. * @private */ var _isFlashUnusable = function() { return !!(_flashState.disabled || _flashState.outdated || _flashState.sandboxed || _flashState.unavailable || _flashState.degraded || _flashState.deactivated); }; /** * The underlying implementation of `ZeroClipboard.on`. * @private */ var _on = function(eventType, listener) { var i, len, events, added = {}; if (typeof eventType === \"string\" && eventType) { events = eventType.toLowerCase().split(/\\s+/); } else if (typeof eventType === \"object\" && eventType && typeof listener === \"undefined\") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === \"string\" && i && typeof eventType[i] === \"function\") { ZeroClipboard.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, \"\"); added[eventType] = true; if (!_handlers[eventType]) { _handlers[eventType] = []; } _handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { ZeroClipboard.emit({ type: \"ready\" }); } if (added.error) { for (i = 0, len = _flashStateErrorNames.length; i < len; i++) { if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, \"\")] === true) { ZeroClipboard.emit({ type: \"error\", name: _flashStateErrorNames[i] }); break; } } if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) { ZeroClipboard.emit({ type: \"error\", name: \"version-mismatch\", jsVersion: ZeroClipboard.version, swfVersion: _zcSwfVersion }); } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.off`. * @private */ var _off = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers; if (arguments.length === 0) { events = _keys(_handlers); } else if (typeof eventType === \"string\" && eventType) { events = eventType.split(/\\s+/); } else if (typeof eventType === \"object\" && eventType && typeof listener === \"undefined\") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === \"string\" && i && typeof eventType[i] === \"function\") { ZeroClipboard.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, \"\"); perEventHandlers = _handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.handlers`. * @private */ var _listeners = function(eventType) { var copy; if (typeof eventType === \"string\" && eventType) { copy = _deepCopy(_handlers[eventType]) || null; } else { copy = _deepCopy(_handlers); } return copy; }; /** * The underlying implementation of `ZeroClipboard.emit`. * @private */ var _emit = function(event) { var eventCopy, returnVal, tmp; event = _createEvent(event); if (!event) { return; } if (_preprocessEvent(event)) { return; } if (event.type === \"ready\" && _flashState.overdue === true) { return ZeroClipboard.emit({ type: \"error\", name: \"flash-overdue\" }); } eventCopy = _extend({}, event); _dispatchCallbacks.call(this, eventCopy); if (event.type === \"copy\") { tmp = _mapClipDataToFlash(_clipData); returnVal = tmp.data; _clipDataFormatMap = tmp.formatMap; } return returnVal; }; /** * The underlying implementation of `ZeroClipboard.create`. * @private */ var _create = function() { var previousState = _flashState.sandboxed; _detectSandbox(); if (typeof _flashState.ready !== \"boolean\") { _flashState.ready = false; } if (_flashState.sandboxed !== previousState && _flashState.sandboxed === true) { _flashState.ready = false; ZeroClipboard.emit({ type: \"error\", name: \"flash-sandboxed\" }); } else if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) { var maxWait = _globalConfig.flashLoadTimeout; if (typeof maxWait === \"number\" && maxWait >= 0) { _flashCheckTimeout = _setTimeout(function() { if (typeof _flashState.deactivated !== \"boolean\") { _flashState.deactivated = true; } if (_flashState.deactivated === true) { ZeroClipboard.emit({ type: \"error\", name: \"flash-deactivated\" }); } }, maxWait); } _flashState.overdue = false; _embedSwf(); } }; /** * The underlying implementation of `ZeroClipboard.destroy`. * @private */ var _destroy = function() { ZeroClipboard.clearData(); ZeroClipboard.blur(); ZeroClipboard.emit(\"destroy\"); _unembedSwf(); ZeroClipboard.off(); }; /** * The underlying implementation of `ZeroClipboard.setData`. * @private */ var _setData = function(format, data) { var dataObj; if (typeof format === \"object\" && format && typeof data === \"undefined\") { dataObj = format; ZeroClipboard.clearData(); } else if (typeof format === \"string\" && format) { dataObj = {}; dataObj[format] = data; } else { return; } for (var dataFormat in dataObj) { if (typeof dataFormat === \"string\" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === \"string\" && dataObj[dataFormat]) { _clipData[dataFormat] = dataObj[dataFormat]; } } }; /** * The underlying implementation of `ZeroClipboard.clearData`. * @private */ var _clearData = function(format) { if (typeof format === \"undefined\") { _deleteOwnProperties(_clipData); _clipDataFormatMap = null; } else if (typeof format === \"string\" && _hasOwn.call(_clipData, format)) { delete _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.getData`. * @private */ var _getData = function(format) { if (typeof format === \"undefined\") { return _deepCopy(_clipData); } else if (typeof format === \"string\" && _hasOwn.call(_clipData, format)) { return _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`. * @private */ var _focus = function(element) { if (!(element && element.nodeType === 1)) { return; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.activeClass); if (_currentElement !== element) { _removeClass(_currentElement, _globalConfig.hoverClass); } } _currentElement = element; _addClass(element, _globalConfig.hoverClass); var newTitle = element.getAttribute(\"title\") || _globalConfig.title; if (typeof newTitle === \"string\" && newTitle) { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.setAttribute(\"title\", newTitle); } } var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, \"cursor\") === \"pointer\"; _setHandCursor(useHandCursor); _reposition(); }; /** * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`. * @private */ var _blur = function() { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.removeAttribute(\"title\"); htmlBridge.style.left = \"0px\"; htmlBridge.style.top = \"-9999px\"; htmlBridge.style.width = \"1px\"; htmlBridge.style.height = \"1px\"; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.hoverClass); _removeClass(_currentElement, _globalConfig.activeClass); _currentElement = null; } }; /** * The underlying implementation of `ZeroClipboard.activeElement`. * @private */ var _activeElement = function() { return _currentElement || null; }; /** * Check if a value is a valid HTML4 `ID` or `Name` token. * @private */ var _isValidHtml4Id = function(id) { return typeof id === \"string\" && id && /^[A-Za-z][A-Za-z0-9_:\\-\\.]*$/.test(id); }; /** * Create or update an `event` object, based on the `eventType`. * @private */ var _createEvent = function(event) { var eventType; if (typeof event === \"string\" && event) { eventType = event; event = {}; } else if (typeof event === \"object\" && event && typeof event.type === \"string\" && event.type) { eventType = event.type; } if (!eventType) { return; } eventType = eventType.toLowerCase(); if (!event.target && (/^(copy|aftercopy|_click)$/.test(eventType) || eventType === \"error\" && event.name === \"clipboard-error\")) { event.target = _copyTarget; } _extend(event, { type: eventType, target: event.target || _currentElement || null, relatedTarget: event.relatedTarget || null, currentTarget: _flashState && _flashState.bridge || null, timeStamp: event.timeStamp || _now() || null }); var msg = _eventMessages[event.type]; if (event.type === \"error\" && event.name && msg) { msg = msg[event.name]; } if (msg) { event.message = msg; } if (event.type === \"ready\") { _extend(event, { target: null, version: _flashState.version }); } if (event.type === \"error\") { if (_flashStateErrorNameMatchingRegex.test(event.name)) { _extend(event, { target: null, minimumVersion: _minimumFlashVersion }); } if (_flashStateEnabledErrorNameMatchingRegex.test(event.name)) { _extend(event, { version: _flashState.version }); } } if (event.type === \"copy\") { event.clipboardData = { setData: ZeroClipboard.setData, clearData: ZeroClipboard.clearData }; } if (event.type === \"aftercopy\") { event = _mapClipResultsFromFlash(event, _clipDataFormatMap); } if (event.target && !event.relatedTarget) { event.relatedTarget = _getRelatedTarget(event.target); } return _addMouseData(event); }; /** * Get a relatedTarget from the target's `data-clipboard-target` attribute * @private */ var _getRelatedTarget = function(targetEl) { var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute(\"data-clipboard-target\"); return relatedTargetId ? _document.getElementById(relatedTargetId) : null; }; /** * Add element and position data to `MouseEvent` instances * @private */ var _addMouseData = function(event) { if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { var srcElement = event.target; var fromElement = event.type === \"_mouseover\" && event.relatedTarget ? event.relatedTarget : undefined; var toElement = event.type === \"_mouseout\" && event.relatedTarget ? event.relatedTarget : undefined; var pos = _getElementPosition(srcElement); var screenLeft = _window.screenLeft || _window.screenX || 0; var screenTop = _window.screenTop || _window.screenY || 0; var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft; var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop; var pageX = pos.left + (typeof event._stageX === \"number\" ? event._stageX : 0); var pageY = pos.top + (typeof event._stageY === \"number\" ? event._stageY : 0); var clientX = pageX - scrollLeft; var clientY = pageY - scrollTop; var screenX = screenLeft + clientX; var screenY = screenTop + clientY; var moveX = typeof event.movementX === \"number\" ? event.movementX : 0; var moveY = typeof event.movementY === \"number\" ? event.movementY : 0; delete event._stageX; delete event._stageY; _extend(event, { srcElement: srcElement, fromElement: fromElement, toElement: toElement, screenX: screenX, screenY: screenY, pageX: pageX, pageY: pageY, clientX: clientX, clientY: clientY, x: clientX, y: clientY, movementX: moveX, movementY: moveY, offsetX: 0, offsetY: 0, layerX: 0, layerY: 0 }); } return event; }; /** * Determine if an event's registered handlers should be execute synchronously or asynchronously. * * @returns {boolean} * @private */ var _shouldPerformAsync = function(event) { var eventType = event && typeof event.type === \"string\" && event.type || \"\"; return !/^(?:(?:before)?copy|destroy)$/.test(eventType); }; /** * Control if a callback should be executed asynchronously or not. * * @returns `undefined` * @private */ var _dispatchCallback = function(func, context, args, async) { if (async) { _setTimeout(function() { func.apply(context, args); }, 0); } else { func.apply(context, args); } }; /** * Handle the actual dispatching of events to client instances. * * @returns `undefined` * @private */ var _dispatchCallbacks = function(event) { if (!(typeof event === \"object\" && event && event.type)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = _handlers[\"*\"] || []; var specificTypeHandlers = _handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === \"string\" && typeof _window[func] === \"function\") { func = _window[func]; } if (typeof func === \"object\" && func && typeof func.handleEvent === \"function\") { context = func; func = func.handleEvent; } if (typeof func === \"function\") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } return this; }; /** * Check an `error` event's `name` property to see if Flash has * already loaded, which rules out possible `iframe` sandboxing. * @private */ var _getSandboxStatusFromErrorEvent = function(event) { var isSandboxed = null; if (_pageIsFramed === false || event && event.type === \"error\" && event.name && _errorsThatOnlyOccurAfterFlashLoads.indexOf(event.name) !== -1) { isSandboxed = false; } return isSandboxed; }; /** * Preprocess any special behaviors, reactions, or state changes after receiving this event. * Executes only once per event emitted, NOT once per client. * @private */ var _preprocessEvent = function(event) { var element = event.target || _currentElement || null; var sourceIsSwf = event._source === \"swf\"; delete event._source; switch (event.type) { case \"error\": var isSandboxed = event.name === \"flash-sandboxed\" || _getSandboxStatusFromErrorEvent(event); if (typeof isSandboxed === \"boolean\") { _flashState.sandboxed = isSandboxed; } if (_flashStateErrorNames.indexOf(event.name) !== -1) { _extend(_flashState, { disabled: event.name === \"flash-disabled\", outdated: event.name === \"flash-outdated\", unavailable: event.name === \"flash-unavailable\", degraded: event.name === \"flash-degraded\", deactivated: event.name === \"flash-deactivated\", overdue: event.name === \"flash-overdue\", ready: false }); } else if (event.name === \"version-mismatch\") { _zcSwfVersion = event.swfVersion; _extend(_flashState, { disabled: false, outdated: false, unavailable: false, degraded: false, deactivated: false, overdue: false, ready: false }); } _clearTimeoutsAndPolling(); break; case \"ready\": _zcSwfVersion = event.swfVersion; var wasDeactivated = _flashState.deactivated === true; _extend(_flashState, { disabled: false, outdated: false, sandboxed: false, unavailable: false, degraded: false, deactivated: false, overdue: wasDeactivated, ready: !wasDeactivated }); _clearTimeoutsAndPolling(); break; case \"beforecopy\": _copyTarget = element; break; case \"copy\": var textContent, htmlContent, targetEl = event.relatedTarget; if (!(_clipData[\"text/html\"] || _clipData[\"text/plain\"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) { event.clipboardData.clearData(); event.clipboardData.setData(\"text/plain\", textContent); if (htmlContent !== textContent) { event.clipboardData.setData(\"text/html\", htmlContent); } } else if (!_clipData[\"text/plain\"] && event.target && (textContent = event.target.getAttribute(\"data-clipboard-text\"))) { event.clipboardData.clearData(); event.clipboardData.setData(\"text/plain\", textContent); } break; case \"aftercopy\": _queueEmitClipboardErrors(event); ZeroClipboard.clearData(); if (element && element !== _safeActiveElement() && element.focus) { element.focus(); } break; case \"_mouseover\": ZeroClipboard.focus(element); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: \"mouseenter\", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: \"mouseover\" })); } break; case \"_mouseout\": ZeroClipboard.blur(); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: \"mouseleave\", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: \"mouseout\" })); } break; case \"_mousedown\": _addClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case \"_mouseup\": _removeClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case \"_click\": _copyTarget = null; if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case \"_mousemove\": if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; } if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { return true; } }; /** * Check an \"aftercopy\" event for clipboard errors and emit a corresponding \"error\" event. * @private */ var _queueEmitClipboardErrors = function(aftercopyEvent) { if (aftercopyEvent.errors && aftercopyEvent.errors.length > 0) { var errorEvent = _deepCopy(aftercopyEvent); _extend(errorEvent, { type: \"error\", name: \"clipboard-error\" }); delete errorEvent.success; _setTimeout(function() { ZeroClipboard.emit(errorEvent); }, 0); } }; /** * Dispatch a synthetic MouseEvent. * * @returns `undefined` * @private */ var _fireMouseEvent = function(event) { if (!(event && typeof event.type === \"string\" && event)) { return; } var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = { view: doc.defaultView || _window, canBubble: true, cancelable: true, detail: event.type === \"click\" ? 1 : 0, button: typeof event.which === \"number\" ? event.which - 1 : typeof event.button === \"number\" ? event.button : doc.createEvent ? 0 : 1 }, args = _extend(defaults, event); if (!target) { return; } if (doc.createEvent && target.dispatchEvent) { args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ]; e = doc.createEvent(\"MouseEvents\"); if (e.initMouseEvent) { e.initMouseEvent.apply(e, args); e._source = \"js\"; target.dispatchEvent(e); } } }; /** * Continuously poll the DOM until either: * (a) the fallback content becomes visible, or * (b) we receive an event from SWF (handled elsewhere) * * IMPORTANT: * This is NOT a necessary check but it can result in significantly faster * detection of bad `swfPath` configuration and/or network/server issues [in * supported browsers] than waiting for the entire `flashLoadTimeout` duration * to elapse before detecting that the SWF cannot be loaded. The detection * duration can be anywhere from 10-30 times faster [in supported browsers] by * using this approach. * * @returns `undefined` * @private */ var _watchForSwfFallbackContent = function() { var maxWait = _globalConfig.flashLoadTimeout; if (typeof maxWait === \"number\" && maxWait >= 0) { var pollWait = Math.min(1e3, maxWait / 10); var fallbackContentId = _globalConfig.swfObjectId + \"_fallbackContent\"; _swfFallbackCheckInterval = _setInterval(function() { var el = _document.getElementById(fallbackContentId); if (_isElementVisible(el)) { _clearTimeoutsAndPolling(); _flashState.deactivated = null; ZeroClipboard.emit({ type: \"error\", name: \"swf-not-found\" }); } }, pollWait); } }; /** * Create the HTML bridge element to embed the Flash object into. * @private */ var _createHtmlBridge = function() { var container = _document.createElement(\"div\"); container.id = _globalConfig.containerId; container.className = _globalConfig.containerClass; container.style.position = \"absolute\"; container.style.left = \"0px\"; container.style.top = \"-9999px\"; container.style.width = \"1px\"; container.style.height = \"1px\"; container.style.zIndex = \"\" + _getSafeZIndex(_globalConfig.zIndex); return container; }; /** * Get the HTML element container that wraps the Flash bridge object/element. * @private */ var _getHtmlBridge = function(flashBridge) { var htmlBridge = flashBridge && flashBridge.parentNode; while (htmlBridge && htmlBridge.nodeName === \"OBJECT\" && htmlBridge.parentNode) { htmlBridge = htmlBridge.parentNode; } return htmlBridge || null; }; /** * Create the SWF object. * * @returns The SWF object reference. * @private */ var _embedSwf = function() { var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge); if (!flashBridge) { var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig); var allowNetworking = allowScriptAccess === \"never\" ? \"none\" : \"all\"; var flashvars = _vars(_extend({ jsVersion: ZeroClipboard.version }, _globalConfig)); var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig); container = _createHtmlBridge(); var divToBeReplaced = _document.createElement(\"div\"); container.appendChild(divToBeReplaced); _document.body.appendChild(container); var tmpDiv = _document.createElement(\"div\"); var usingActiveX = _flashState.pluginType === \"activex\"; tmpDiv.innerHTML = ' 0) { if (element.classList) { for (c = 0, cl = classNames.length; c < cl; c++) { element.classList.add(classNames[c]); } } else if (element.hasOwnProperty(\"className\")) { className = \" \" + element.className + \" \"; for (c = 0, cl = classNames.length; c < cl; c++) { if (className.indexOf(\" \" + classNames[c] + \" \") === -1) { className += classNames[c] + \" \"; } } element.className = className.replace(/^\\s+|\\s+$/g, \"\"); } } return element; }; /** * Remove a class from an element, if it has it. * * @returns The element, with its class removed. * @private */ var _removeClass = function(element, value) { var c, cl, className, classNames = []; if (typeof value === \"string\" && value) { classNames = value.split(/\\s+/); } if (element && element.nodeType === 1 && classNames.length > 0) { if (element.classList && element.classList.length > 0) { for (c = 0, cl = classNames.length; c < cl; c++) { element.classList.remove(classNames[c]); } } else if (element.className) { className = (\" \" + element.className + \" \").replace(/[\\r\\n\\t]/g, \" \"); for (c = 0, cl = classNames.length; c < cl; c++) { className = className.replace(\" \" + classNames[c] + \" \", \" \"); } element.className = className.replace(/^\\s+|\\s+$/g, \"\"); } } return element; }; /** * Attempt to interpret the element's CSS styling. If `prop` is `\"cursor\"`, * then we assume that it should be a hand (\"pointer\") cursor if the element * is an anchor element (\"a\" tag). * * @returns The computed style property. * @private */ var _getStyle = function(el, prop) { var value = _getComputedStyle(el, null).getPropertyValue(prop); if (prop === \"cursor\") { if (!value || value === \"auto\") { if (el.nodeName === \"A\") { return \"pointer\"; } } } return value; }; /** * Get the absolutely positioned coordinates of a DOM element. * * @returns Object containing the element's position, width, and height. * @private */ var _getElementPosition = function(el) { var pos = { left: 0, top: 0, width: 0, height: 0 }; if (el.getBoundingClientRect) { var elRect = el.getBoundingClientRect(); var pageXOffset = _window.pageXOffset; var pageYOffset = _window.pageYOffset; var leftBorderWidth = _document.documentElement.clientLeft || 0; var topBorderWidth = _document.documentElement.clientTop || 0; var leftBodyOffset = 0; var topBodyOffset = 0; if (_getStyle(_document.body, \"position\") === \"relative\") { var bodyRect = _document.body.getBoundingClientRect(); var htmlRect = _document.documentElement.getBoundingClientRect(); leftBodyOffset = bodyRect.left - htmlRect.left || 0; topBodyOffset = bodyRect.top - htmlRect.top || 0; } pos.left = elRect.left + pageXOffset - leftBorderWidth - leftBodyOffset; pos.top = elRect.top + pageYOffset - topBorderWidth - topBodyOffset; pos.width = \"width\" in elRect ? elRect.width : elRect.right - elRect.left; pos.height = \"height\" in elRect ? elRect.height : elRect.bottom - elRect.top; } return pos; }; /** * Determine is an element is visible somewhere within the document (page). * * @returns Boolean * @private */ var _isElementVisible = function(el) { if (!el) { return false; } var styles = _getComputedStyle(el, null); var hasCssHeight = _parseFloat(styles.height) > 0; var hasCssWidth = _parseFloat(styles.width) > 0; var hasCssTop = _parseFloat(styles.top) >= 0; var hasCssLeft = _parseFloat(styles.left) >= 0; var cssKnows = hasCssHeight && hasCssWidth && hasCssTop && hasCssLeft; var rect = cssKnows ? null : _getElementPosition(el); var isVisible = styles.display !== \"none\" && styles.visibility !== \"collapse\" && (cssKnows || !!rect && (hasCssHeight || rect.height > 0) && (hasCssWidth || rect.width > 0) && (hasCssTop || rect.top >= 0) && (hasCssLeft || rect.left >= 0)); return isVisible; }; /** * Clear all existing timeouts and interval polling delegates. * * @returns `undefined` * @private */ var _clearTimeoutsAndPolling = function() { _clearTimeout(_flashCheckTimeout); _flashCheckTimeout = 0; _clearInterval(_swfFallbackCheckInterval); _swfFallbackCheckInterval = 0; }; /** * Reposition the Flash object to cover the currently activated element. * * @returns `undefined` * @private */ var _reposition = function() { var htmlBridge; if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) { var pos = _getElementPosition(_currentElement); _extend(htmlBridge.style, { width: pos.width + \"px\", height: pos.height + \"px\", top: pos.top + \"px\", left: pos.left + \"px\", zIndex: \"\" + _getSafeZIndex(_globalConfig.zIndex) }); } }; /** * Sends a signal to the Flash object to display the hand cursor if `true`. * * @returns `undefined` * @private */ var _setHandCursor = function(enabled) { if (_flashState.ready === true) { if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === \"function\") { _flashState.bridge.setHandCursor(enabled); } else { _flashState.ready = false; } } }; /** * Get a safe value for `zIndex` * * @returns an integer, or \"auto\" * @private */ var _getSafeZIndex = function(val) { if (/^(?:auto|inherit)$/.test(val)) { return val; } var zIndex; if (typeof val === \"number\" && !_isNaN(val)) { zIndex = val; } else if (typeof val === \"string\") { zIndex = _getSafeZIndex(_parseInt(val, 10)); } return typeof zIndex === \"number\" ? zIndex : \"auto\"; }; /** * Attempt to detect if ZeroClipboard is executing inside of a sandboxed iframe. * If it is, Flash Player cannot be used, so ZeroClipboard is dead in the water. * * @see {@link http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Dec/0002.html} * @see {@link https://github.com/zeroclipboard/zeroclipboard/issues/511} * @see {@link http://zeroclipboard.org/test-iframes.html} * * @returns `true` (is sandboxed), `false` (is not sandboxed), or `null` (uncertain) * @private */ var _detectSandbox = function(doNotReassessFlashSupport) { var effectiveScriptOrigin, frame, frameError, previousState = _flashState.sandboxed, isSandboxed = null; doNotReassessFlashSupport = doNotReassessFlashSupport === true; if (_pageIsFramed === false) { isSandboxed = false; } else { try { frame = window.frameElement || null; } catch (e) { frameError = { name: e.name, message: e.message }; } if (frame && frame.nodeType === 1 && frame.nodeName === \"IFRAME\") { try { isSandboxed = frame.hasAttribute(\"sandbox\"); } catch (e) { isSandboxed = null; } } else { try { effectiveScriptOrigin = document.domain || null; } catch (e) { effectiveScriptOrigin = null; } if (effectiveScriptOrigin === null || frameError && frameError.name === \"SecurityError\" && /(^|[\\s\\(\\[@])sandbox(es|ed|ing|[\\s\\.,!\\)\\]@]|$)/.test(frameError.message.toLowerCase())) { isSandboxed = true; } } } _flashState.sandboxed = isSandboxed; if (previousState !== isSandboxed && !doNotReassessFlashSupport) { _detectFlashSupport(_ActiveXObject); } return isSandboxed; }; /** * Detect the Flash Player status, version, and plugin type. * * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code} * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript} * * @returns `undefined` * @private */ var _detectFlashSupport = function(ActiveXObject) { var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = \"\"; /** * Derived from Apple's suggested sniffer. * @param {String} desc e.g. \"Shockwave Flash 7.0 r61\" * @returns {String} \"7.0.61\" * @private */ function parseFlashVersion(desc) { var matches = desc.match(/[\\d]+/g); matches.length = 3; return matches.join(\".\"); } function isPepperFlash(flashPlayerFileName) { return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\\.dll|libpepflashplayer\\.so|pepperflashplayer\\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === \"chrome.plugin\"); } function inspectPlugin(plugin) { if (plugin) { hasFlash = true; if (plugin.version) { flashVersion = parseFlashVersion(plugin.version); } if (!flashVersion && plugin.description) { flashVersion = parseFlashVersion(plugin.description); } if (plugin.filename) { isPPAPI = isPepperFlash(plugin.filename); } } } if (_navigator.plugins && _navigator.plugins.length) { plugin = _navigator.plugins[\"Shockwave Flash\"]; inspectPlugin(plugin); if (_navigator.plugins[\"Shockwave Flash 2.0\"]) { hasFlash = true; flashVersion = \"2.0.0.11\"; } } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) { mimeType = _navigator.mimeTypes[\"application/x-shockwave-flash\"]; plugin = mimeType && mimeType.enabledPlugin; inspectPlugin(plugin); } else if (typeof ActiveXObject !== \"undefined\") { isActiveX = true; try { ax = new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash.7\"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable(\"$version\")); } catch (e1) { try { ax = new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash.6\"); hasFlash = true; flashVersion = \"6.0.21\"; } catch (e2) { try { ax = new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable(\"$version\")); } catch (e3) { isActiveX = false; } } } } _flashState.disabled = hasFlash !== true; _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion); _flashState.version = flashVersion || \"0.0.0\"; _flashState.pluginType = isPPAPI ? \"pepper\" : isActiveX ? \"activex\" : hasFlash ? \"netscape\" : \"unknown\"; }; /** * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later. */ _detectFlashSupport(_ActiveXObject); /** * Always assess the `sandboxed` state of the page at important Flash-related moments. */ _detectSandbox(true); /** * A shell constructor for `ZeroClipboard` client instances. * * @constructor */ var ZeroClipboard = function() { if (!(this instanceof ZeroClipboard)) { return new ZeroClipboard(); } if (typeof ZeroClipboard._createClient === \"function\") { ZeroClipboard._createClient.apply(this, _args(arguments)); } }; /** * The ZeroClipboard library's version number. * * @static * @readonly * @property {string} */ _defineProperty(ZeroClipboard, \"version\", { value: \"2.2.0\", writable: false, configurable: true, enumerable: true }); /** * Update or get a copy of the ZeroClipboard global configuration. * Returns a copy of the current/updated configuration. * * @returns Object * @static */ ZeroClipboard.config = function() { return _config.apply(this, _args(arguments)); }; /** * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard. * * @returns Object * @static */ ZeroClipboard.state = function() { return _state.apply(this, _args(arguments)); }; /** * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc. * * @returns Boolean * @static */ ZeroClipboard.isFlashUnusable = function() { return _isFlashUnusable.apply(this, _args(arguments)); }; /** * Register an event listener. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.on = function() { return _on.apply(this, _args(arguments)); }; /** * Unregister an event listener. * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`. * If no `eventType` is provided, it will unregister all listeners for every event type. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.off = function() { return _off.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType`. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.handlers = function() { return _listeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners. * * @returns For the \"copy\" event, returns the Flash-friendly \"clipData\" object; otherwise `undefined`. * @static */ ZeroClipboard.emit = function() { return _emit.apply(this, _args(arguments)); }; /** * Create and embed the Flash object. * * @returns The Flash object * @static */ ZeroClipboard.create = function() { return _create.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything, including the embedded Flash object. * * @returns `undefined` * @static */ ZeroClipboard.destroy = function() { return _destroy.apply(this, _args(arguments)); }; /** * Set the pending data for clipboard injection. * * @returns `undefined` * @static */ ZeroClipboard.setData = function() { return _setData.apply(this, _args(arguments)); }; /** * Clear the pending data for clipboard injection. * If no `format` is provided, all pending data formats will be cleared. * * @returns `undefined` * @static */ ZeroClipboard.clearData = function() { return _clearData.apply(this, _args(arguments)); }; /** * Get a copy of the pending data for clipboard injection. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` * @static */ ZeroClipboard.getData = function() { return _getData.apply(this, _args(arguments)); }; /** * Sets the current HTML object that the Flash object should overlay. This will put the global * Flash object on top of the current element; depending on the setup, this may also set the * pending clipboard text data as well as the Flash object's wrapping element's title attribute * based on the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.focus = ZeroClipboard.activate = function() { return _focus.apply(this, _args(arguments)); }; /** * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on * the setup, this may also unset the Flash object's wrapping element's title attribute based on * the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.blur = ZeroClipboard.deactivate = function() { return _blur.apply(this, _args(arguments)); }; /** * Returns the currently focused/\"activated\" HTML element that the Flash object is wrapping. * * @returns `HTMLElement` or `null` * @static */ ZeroClipboard.activeElement = function() { return _activeElement.apply(this, _args(arguments)); }; /** * Keep track of the ZeroClipboard client instance counter. */ var _clientIdCounter = 0; /** * Keep track of the state of the client instances. * * Entry structure: * _clientMeta[client.id] = { * instance: client, * elements: [], * handlers: {} * }; */ var _clientMeta = {}; /** * Keep track of the ZeroClipboard clipped elements counter. */ var _elementIdCounter = 0; /** * Keep track of the state of the clipped element relationships to clients. * * Entry structure: * _elementMeta[element.zcClippingId] = [client1.id, client2.id]; */ var _elementMeta = {}; /** * Keep track of the state of the mouse event handlers for clipped elements. * * Entry structure: * _mouseHandlers[element.zcClippingId] = { * mouseover: function(event) {}, * mouseout: function(event) {}, * mouseenter: function(event) {}, * mouseleave: function(event) {}, * mousemove: function(event) {} * }; */ var _mouseHandlers = {}; /** * Extending the ZeroClipboard configuration defaults for the Client module. */ _extend(_globalConfig, { autoActivate: true }); /** * The real constructor for `ZeroClipboard` client instances. * @private */ var _clientConstructor = function(elements) { var client = this; client.id = \"\" + _clientIdCounter++; _clientMeta[client.id] = { instance: client, elements: [], handlers: {} }; if (elements) { client.clip(elements); } ZeroClipboard.on(\"*\", function(event) { return client.emit(event); }); ZeroClipboard.on(\"destroy\", function() { client.destroy(); }); ZeroClipboard.create(); }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.on`. * @private */ var _clientOn = function(eventType, listener) { var i, len, events, added = {}, meta = _clientMeta[this.id], handlers = meta && meta.handlers; if (!meta) { throw new Error(\"Attempted to add new listener(s) to a destroyed ZeroClipboard client instance\"); } if (typeof eventType === \"string\" && eventType) { events = eventType.toLowerCase().split(/\\s+/); } else if (typeof eventType === \"object\" && eventType && typeof listener === \"undefined\") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === \"string\" && i && typeof eventType[i] === \"function\") { this.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, \"\"); added[eventType] = true; if (!handlers[eventType]) { handlers[eventType] = []; } handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { this.emit({ type: \"ready\", client: this }); } if (added.error) { for (i = 0, len = _flashStateErrorNames.length; i < len; i++) { if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, \"\")]) { this.emit({ type: \"error\", name: _flashStateErrorNames[i], client: this }); break; } } if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) { this.emit({ type: \"error\", name: \"version-mismatch\", jsVersion: ZeroClipboard.version, swfVersion: _zcSwfVersion }); } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.off`. * @private */ var _clientOff = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers, meta = _clientMeta[this.id], handlers = meta && meta.handlers; if (!handlers) { return this; } if (arguments.length === 0) { events = _keys(handlers); } else if (typeof eventType === \"string\" && eventType) { events = eventType.split(/\\s+/); } else if (typeof eventType === \"object\" && eventType && typeof listener === \"undefined\") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === \"string\" && i && typeof eventType[i] === \"function\") { this.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, \"\"); perEventHandlers = handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`. * @private */ var _clientListeners = function(eventType) { var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers; if (handlers) { if (typeof eventType === \"string\" && eventType) { copy = handlers[eventType] ? handlers[eventType].slice(0) : []; } else { copy = _deepCopy(handlers); } } return copy; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.emit`. * @private */ var _clientEmit = function(event) { if (_clientShouldEmit.call(this, event)) { if (typeof event === \"object\" && event && typeof event.type === \"string\" && event.type) { event = _extend({}, event); } var eventCopy = _extend({}, _createEvent(event), { client: this }); _clientDispatchCallbacks.call(this, eventCopy); } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.clip`. * @private */ var _clientClip = function(elements) { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to clip element(s) to a destroyed ZeroClipboard client instance\"); } elements = _prepClip(elements); for (var i = 0; i < elements.length; i++) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { if (!elements[i].zcClippingId) { elements[i].zcClippingId = \"zcClippingId_\" + _elementIdCounter++; _elementMeta[elements[i].zcClippingId] = [ this.id ]; if (_globalConfig.autoActivate === true) { _addMouseHandlers(elements[i]); } } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) { _elementMeta[elements[i].zcClippingId].push(this.id); } var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements; if (clippedElements.indexOf(elements[i]) === -1) { clippedElements.push(elements[i]); } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`. * @private */ var _clientUnclip = function(elements) { var meta = _clientMeta[this.id]; if (!meta) { return this; } var clippedElements = meta.elements; var arrayIndex; if (typeof elements === \"undefined\") { elements = clippedElements.slice(0); } else { elements = _prepClip(elements); } for (var i = elements.length; i--; ) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { arrayIndex = 0; while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) { clippedElements.splice(arrayIndex, 1); } var clientIds = _elementMeta[elements[i].zcClippingId]; if (clientIds) { arrayIndex = 0; while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) { clientIds.splice(arrayIndex, 1); } if (clientIds.length === 0) { if (_globalConfig.autoActivate === true) { _removeMouseHandlers(elements[i]); } delete elements[i].zcClippingId; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.elements`. * @private */ var _clientElements = function() { var meta = _clientMeta[this.id]; return meta && meta.elements ? meta.elements.slice(0) : []; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`. * @private */ var _clientDestroy = function() { if (!_clientMeta[this.id]) { return; } this.unclip(); this.off(); delete _clientMeta[this.id]; }; /** * Inspect an Event to see if the Client (`this`) should honor it for emission. * @private */ var _clientShouldEmit = function(event) { if (!(event && event.type)) { return false; } if (event.client && event.client !== this) { return false; } var meta = _clientMeta[this.id]; var clippedEls = meta && meta.elements; var hasClippedEls = !!clippedEls && clippedEls.length > 0; var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1; var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1; var goodClient = event.client && event.client === this; if (!meta || !(goodTarget || goodRelTarget || goodClient)) { return false; } return true; }; /** * Handle the actual dispatching of events to a client instance. * * @returns `undefined` * @private */ var _clientDispatchCallbacks = function(event) { var meta = _clientMeta[this.id]; if (!(typeof event === \"object\" && event && event.type && meta)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = meta && meta.handlers[\"*\"] || []; var specificTypeHandlers = meta && meta.handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === \"string\" && typeof _window[func] === \"function\") { func = _window[func]; } if (typeof func === \"object\" && func && typeof func.handleEvent === \"function\") { context = func; func = func.handleEvent; } if (typeof func === \"function\") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } }; /** * Prepares the elements for clipping/unclipping. * * @returns An Array of elements. * @private */ var _prepClip = function(elements) { if (typeof elements === \"string\") { elements = []; } return typeof elements.length !== \"number\" ? [ elements ] : elements; }; /** * Add a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _addMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var _suppressMouseEvents = function(event) { if (!(event || (event = _window.event))) { return; } if (event._source !== \"js\") { event.stopImmediatePropagation(); event.preventDefault(); } delete event._source; }; var _elementMouseOver = function(event) { if (!(event || (event = _window.event))) { return; } _suppressMouseEvents(event); ZeroClipboard.focus(element); }; element.addEventListener(\"mouseover\", _elementMouseOver, false); element.addEventListener(\"mouseout\", _suppressMouseEvents, false); element.addEventListener(\"mouseenter\", _suppressMouseEvents, false); element.addEventListener(\"mouseleave\", _suppressMouseEvents, false); element.addEventListener(\"mousemove\", _suppressMouseEvents, false); _mouseHandlers[element.zcClippingId] = { mouseover: _elementMouseOver, mouseout: _suppressMouseEvents, mouseenter: _suppressMouseEvents, mouseleave: _suppressMouseEvents, mousemove: _suppressMouseEvents }; }; /** * Remove a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _removeMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var mouseHandlers = _mouseHandlers[element.zcClippingId]; if (!(typeof mouseHandlers === \"object\" && mouseHandlers)) { return; } var key, val, mouseEvents = [ \"move\", \"leave\", \"enter\", \"out\", \"over\" ]; for (var i = 0, len = mouseEvents.length; i < len; i++) { key = \"mouse\" + mouseEvents[i]; val = mouseHandlers[key]; if (typeof val === \"function\") { element.removeEventListener(key, val, false); } } delete _mouseHandlers[element.zcClippingId]; }; /** * Creates a new ZeroClipboard client instance. * Optionally, auto-`clip` an element or collection of elements. * * @constructor */ ZeroClipboard._createClient = function() { _clientConstructor.apply(this, _args(arguments)); }; /** * Register an event listener to the client. * * @returns `this` */ ZeroClipboard.prototype.on = function() { return _clientOn.apply(this, _args(arguments)); }; /** * Unregister an event handler from the client. * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`. * If no `eventType` is provided, it will unregister all handlers for every event type. * * @returns `this` */ ZeroClipboard.prototype.off = function() { return _clientOff.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType` from the client. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.prototype.handlers = function() { return _clientListeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object for this client's registered JavaScript event listeners. * * @returns For the \"copy\" event, returns the Flash-friendly \"clipData\" object; otherwise `undefined`. */ ZeroClipboard.prototype.emit = function() { return _clientEmit.apply(this, _args(arguments)); }; /** * Register clipboard actions for new element(s) to the client. * * @returns `this` */ ZeroClipboard.prototype.clip = function() { return _clientClip.apply(this, _args(arguments)); }; /** * Unregister the clipboard actions of previously registered element(s) on the page. * If no elements are provided, ALL registered elements will be unregistered. * * @returns `this` */ ZeroClipboard.prototype.unclip = function() { return _clientUnclip.apply(this, _args(arguments)); }; /** * Get all of the elements to which this client is clipped. * * @returns array of clipped elements */ ZeroClipboard.prototype.elements = function() { return _clientElements.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything for a single client. * This will NOT destroy the embedded Flash object. * * @returns `undefined` */ ZeroClipboard.prototype.destroy = function() { return _clientDestroy.apply(this, _args(arguments)); }; /** * Stores the pending plain text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setText = function(text) { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance\"); } ZeroClipboard.setData(\"text/plain\", text); return this; }; /** * Stores the pending HTML text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setHtml = function(html) { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance\"); } ZeroClipboard.setData(\"text/html\", html); return this; }; /** * Stores the pending rich text (RTF) to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setRichText = function(richText) { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance\"); } ZeroClipboard.setData(\"application/rtf\", richText); return this; }; /** * Stores the pending data to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setData = function() { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance\"); } ZeroClipboard.setData.apply(this, _args(arguments)); return this; }; /** * Clears the pending data to inject into the clipboard. * If no `format` is provided, all pending data formats will be cleared. * * @returns `this` */ ZeroClipboard.prototype.clearData = function() { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to clear pending clipboard data from a destroyed ZeroClipboard client instance\"); } ZeroClipboard.clearData.apply(this, _args(arguments)); return this; }; /** * Gets a copy of the pending data to inject into the clipboard. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` */ ZeroClipboard.prototype.getData = function() { if (!_clientMeta[this.id]) { throw new Error(\"Attempted to get pending clipboard data from a destroyed ZeroClipboard client instance\"); } return ZeroClipboard.getData.apply(this, _args(arguments)); }; if (typeof define === \"function\" && define.amd) { define(function() { return ZeroClipboard; }); } else if (typeof module === \"object\" && module && typeof module.exports === \"object\" && module.exports) { module.exports = ZeroClipboard; } else { window.ZeroClipboard = ZeroClipboard; } })(function() { return this || window; }());","categories":[],"tags":[]}]}