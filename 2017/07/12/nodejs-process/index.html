<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>nodejs-process | 青史成灰 | Every journey begins with the first step</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="nodejs">
    <meta name="description" content="Process Events(进程事件)
process对象是EventEmitter的一个实例

beforeExit
当Node清空事件队列并且没有额外的任务加入到事件队列中，触发该事件。通常情况下，当没有额外的任务加入到事件队列中时，Node进程会自动退出。但是如果’beforeExit’事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。
pro">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs-process">
<meta property="og:url" content="https://xxxxxmiss.github.io/2017/07/12/nodejs-process/index.html">
<meta property="og:site_name" content="青史成灰">
<meta property="og:description" content="Process Events(进程事件)
process对象是EventEmitter的一个实例

beforeExit
当Node清空事件队列并且没有额外的任务加入到事件队列中，触发该事件。通常情况下，当没有额外的任务加入到事件队列中时，Node进程会自动退出。但是如果’beforeExit’事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。
pro">
<meta property="og:updated_time" content="2017-07-16T12:19:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodejs-process">
<meta name="twitter:description" content="Process Events(进程事件)
process对象是EventEmitter的一个实例

beforeExit
当Node清空事件队列并且没有额外的任务加入到事件队列中，触发该事件。通常情况下，当没有额外的任务加入到事件队列中时，Node进程会自动退出。但是如果’beforeExit’事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。
pro">
    
        <link rel="alternate" type="application/atom+xml" title="青史成灰" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">xxxxxMiss</h5>
          <a href="mailto:634206017@qq.com" title="634206017@qq.com" class="mail">634206017@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/yscoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/ysweb" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">nodejs-process</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">nodejs-process</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-12T15:00:05.000Z" itemprop="datePublished" class="page-time">
  2017-07-12
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/nodejs/">nodejs</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Process-Events-进程事件"><span class="post-toc-number">1.</span> <span class="post-toc-text">Process Events(进程事件)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#beforeExit"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">beforeExit</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#disconnect"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">disconnect</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#exit"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">exit</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#message"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">message</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#uncaughtException"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">uncaughtException</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Signal-Events（信号事件）"><span class="post-toc-number">2.</span> <span class="post-toc-text">Signal Events（信号事件）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-abort"><span class="post-toc-number">3.</span> <span class="post-toc-text">process.abort()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#prcess-arch-architecture"><span class="post-toc-number">4.</span> <span class="post-toc-text">prcess.arch(architecture)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-argv"><span class="post-toc-number">5.</span> <span class="post-toc-text">process.argv</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-execPath"><span class="post-toc-number">6.</span> <span class="post-toc-text">process.execPath</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-argv0"><span class="post-toc-number">7.</span> <span class="post-toc-text">process.argv0</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-channel"><span class="post-toc-number">8.</span> <span class="post-toc-text">process.channel</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-chdir-directory"><span class="post-toc-number">9.</span> <span class="post-toc-text">process.chdir(directory)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-connected"><span class="post-toc-number">10.</span> <span class="post-toc-text">process.connected</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-cpuUsage-previousValue"><span class="post-toc-number">11.</span> <span class="post-toc-text">process.cpuUsage([previousValue])</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-cwd"><span class="post-toc-number">12.</span> <span class="post-toc-text">process.cwd()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#prcess-disconnect"><span class="post-toc-number">13.</span> <span class="post-toc-text">prcess.disconnect()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-env"><span class="post-toc-number">14.</span> <span class="post-toc-text">process.env</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-execArgv"><span class="post-toc-number">15.</span> <span class="post-toc-text">process.execArgv</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-exit-code"><span class="post-toc-number">16.</span> <span class="post-toc-text">process.exit([code])</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-exitCode"><span class="post-toc-number">17.</span> <span class="post-toc-text">process.exitCode</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-kill-pid-signal"><span class="post-toc-number">18.</span> <span class="post-toc-text">process.kill(pid[,signal])</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-memoryUsage"><span class="post-toc-number">19.</span> <span class="post-toc-text">process.memoryUsage()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-nextTick-callback-…args"><span class="post-toc-number">20.</span> <span class="post-toc-text">process.nextTick(callback[,…args])</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-pid"><span class="post-toc-number">21.</span> <span class="post-toc-text">process.pid</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-platform"><span class="post-toc-number">22.</span> <span class="post-toc-text">process.platform</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#prcess-send-message-sendHandle-options-callback"><span class="post-toc-number">23.</span> <span class="post-toc-text">prcess.send(message[, sendHandle[, options]][,callback])</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-stderr"><span class="post-toc-number">24.</span> <span class="post-toc-text">process.stderr</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-stdin"><span class="post-toc-number">25.</span> <span class="post-toc-text">process.stdin</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-stdout"><span class="post-toc-number">26.</span> <span class="post-toc-text">process.stdout</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关于process-I-O需要注意以下几点："><span class="post-toc-number">26.1.</span> <span class="post-toc-text">关于process I/O需要注意以下几点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-uptime"><span class="post-toc-number">27.</span> <span class="post-toc-text">process.uptime()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#process-version"><span class="post-toc-number">28.</span> <span class="post-toc-text">process.version</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Exit-Codes-退出码"><span class="post-toc-number">29.</span> <span class="post-toc-text">Exit Codes(退出码)</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-nodejs-process"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">nodejs-process</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-12 23:00:05" datetime="2017-07-12T15:00:05.000Z"  itemprop="datePublished">2017-07-12</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/nodejs/">nodejs</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Process-Events-进程事件"><a href="#Process-Events-进程事件" class="headerlink" title="Process Events(进程事件)"></a>Process Events(进程事件)</h2><blockquote>
<p><code>process</code>对象是<code>EventEmitter</code>的一个实例</p>
</blockquote>
<h3 id="beforeExit"><a href="#beforeExit" class="headerlink" title="beforeExit"></a>beforeExit</h3><blockquote>
<p>当Node清空事件队列并且没有额外的任务加入到事件队列中，触发该事件。通常情况下，当没有额外的任务加入到事件队列中时，Node进程会自动退出。<br>但是如果’beforeExit’事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。</p>
<p>process.exitCode 作为唯一的参数值传递给’beforeExit’事件监听器的回调函数。</p>
<p>如果进程由于显式的原因而将要终止，例如直接调用process.exit()或抛出未捕获的异常，’beforeExit’事件不会被触发。</p>
<p>除非本意就是需要添加额外的工作(比如通过监听器进行异步调用)到事件循环数组，否则不应该用’beforeExit’事件替代’exit’事件。</p>
</blockquote>
<h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><blockquote>
<p>如果一个进程是通过<code>IPC</code>信道的方式spawned出来的，那么当<code>IPC</code>信道关闭的时候触发该事件。</p>
</blockquote>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><blockquote>
<p>当Node进程是由于以下2中情况之一导致退出的时候，会触发该事件：</p>
</blockquote>
<ul>
<li>显示的调用<code>process.exit()</code></li>
<li>事件循环队列中不再有额外的任务去做的时候</li>
</ul>
<blockquote>
<p>一旦到达Node进程即将退出这个点的时候，是没有办法去阻止进程退出的。当<code>exit</code>事件上所有的监听器都执行完毕的时候，进程就会自动退出。<br>该事件的监听器会接受唯一的一个参数, 该参数来自<code>process.exitCode</code>或者来自传入到<code>process.exit()</code>中的code</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'exit'</span>, code =&gt; &#123;</div><div class="line">    console.log(`About to <span class="keyword">exit</span> with code: <span class="variable">$&#123;code&#125;</span>`)    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>因为一旦到达Node进程即将退出这个点，是没有办法阻止进程退出的。所有该事件的监听器中所做的操作都应该是<strong>同步</strong>的操作，任何在事件循环中排队的工作都会被强制丢弃。例如在下例中，timeout操作永远不会被执行(因为不是同步操作)。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 异步任务是不会被执行的</span></div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'This will not run'</span>)    </div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><blockquote>
<p>当一个Node进程是通过<code>IPC</code>信道的方式spawned出来的，那么当父进程通过<code>childprocess.send()</code>方法发送信息到该子进程的时候，就会触发该事件。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">process.<span class="literal">on</span>(<span class="string">'message'</span>, <span class="function"><span class="params">(message, sendHandle)</span> =&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure>
<p>回调会接受2个参数：</p>
<ul>
<li>message：一个解析过的JSON对象或者一个原始值</li>
<li>sendHandle： net.Socket或者net.Server或者undefined</li>
</ul>
<h3 id="uncaughtException"><a href="#uncaughtException" class="headerlink" title="uncaughtException"></a>uncaughtException</h3><blockquote>
<p>当事件队列在循环的过程中，遇到一个未能捕获的JS异常的时候，沿着代码调用路径反向传递回event loop，就会触发该事件。<br>默认情况下，Node处理这样的异常是将追踪栈中的信息打印到标准的错误流中，然后退出。<br>如果给该事件添加了自己的监听器，那么会改写默认行为。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调接受唯一的一个Error对象</span></div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    fs.writeSync(<span class="number">1</span>, <span class="string">`Caught Exception: <span class="subst">$&#123;err&#125;</span>\n`</span>)    </div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'This will still run'</span>)</div><div class="line">&#125;, <span class="number">500</span>)</div><div class="line"></div><div class="line">nonexistentFun()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'This will not run'</span>)</div></pre></td></tr></table></figure>
<p>Warning: 正确的使用<code>uncaughtException</code>事件</p>
<blockquote>
<p>该事件一般仅用着处理异常的最后的手段，因为它处理异常的机制是非常粗糙的。<br> 此事件不应该当作出了<code>错误就恢复让它继续</code>的等价机制。 未处理异常本身就意味着应用已经处于了未定义的状态。如果基于这种状态，尝试恢复应用正常进行，可能会造成未知或不可预测的问题。<br><br><br>此事件的监听器回调函数中抛出的异常，不会被捕获。为了避免出现无限循环的情况，进程会以非<code>0</code>的状态码结束，并打印堆栈信息。<br><br><br>正确的使用<code>uncaughtException</code>应该是在进程关闭之前做一些相关的资源清理工作（比如文件描述符，句柄等），而不应该是出现了<code>uncaughtException</code>异常之后做一些让应用恢复工作的事情，因为这样是不安全的。</p>
<p>想让一个已经崩溃的应用正常运行，更可靠的方式应该是启动另外一个进程来监测/探测应用是否出错， 无论uncaughtException事件是否被触发，如果监测到应用出错，则恢复或重启应用。</p>
</blockquote>
<h2 id="Signal-Events（信号事件）"><a href="#Signal-Events（信号事件）" class="headerlink" title="Signal Events（信号事件）"></a>Signal Events（信号事件）</h2><blockquote>
<p>当Node进程接受到信号时，就会触发相应的信号事件。<br>每个事件名称，以信号名称的大写表示 (比如事件’SIGINT’ 对应信号 SIGINT).</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.stdin.resume()</div><div class="line"></div><div class="line">process.<span class="literal">on</span>(<span class="string">'SIGINT'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Received SIGINT.  Press Control-D to exit.'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>在大多数的终端上发出<code>SIGINT</code>信号最简单的方式就是按下<code>Ctrl+C</code>键。<br>所以上面的例子中，当你按下<code>Ctrl+C</code>后，就会触发<code>SIGINT</code>事件，输出’Received SIGINT.  Press Control-D to exit.’，当你在按下<code>Ctrl+D</code>时，进程退出。</p>
</blockquote>
<p>以下有很重要的几点需要牢记：</p>
<ul>
<li><code>SIGUSR1</code>是Node用来启动debugger程序的。可以为此事件绑定一个监听器，但是即使这样做也不会阻止调试器的启动。<br><br></li>
<li><code>SIGTERM</code>和<code>SIGINT</code>在非windows平台上，有默认的监听器，这样进程在携带<code>128 + signal number</code>退出码退出之前，可以重置终端模式。如果给他们添加了自己的监听器，那么默认行为就会被移除。（Node进程不会退出）<br><br></li>
<li><code>SIGPIPE</code>默认是被忽略的，但是你也可以给它添加监听程序。<br><br></li>
<li><code>SIGHUP</code>,在windows平台上，当console窗口被关闭时，触发该事件。在其他平台上有着不同的行为，可以参看<a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="external">这里</a>。可以对该信号添加监听器，及时添加了监听器，在windows平台上，大约10秒之后Node会无条件的终止。在非windows平台上个，<code>SIGHUP</code>信号默认行为是终止Node,如果添加了自己的监听器，那么默认行为就会被移除。<br><br></li>
<li><code>SIGTERM</code>,windows平台不支持，可以给其添加监听器。<br><br></li>
<li><code>SIGINT</code>,所有的平台都支持。一般情况下按下<code>Ctrl+C</code>（当然你可以配置成其他快捷方式是）就会发出该信号。但是如果终端的raw模式被激活，那么就不会发出该信号。<br><br></li>
<li><code>SIGBREAK</code>,在windows平台上按下<code>Ctrl+Break</code>就会传递该信号。在非windows平台上，可以对其添加监听器，但是没有方式触发或发送此事件。<br><br></li>
<li><code>SIGWINCH</code>,当console窗口大小发生改变的时候，就会触发该信号。在windows平台上，仅仅发生在当在console有写入并且光标发生移动的时候才会触发该信号，或者一个可读tty被用在raw模式。<br><br></li>
<li><code>SIGKILL</code>，无法对其添加监听器，在所有的平台上，他都会无条件终止Node。<br><br></li>
<li><code>SIGTOP</code>，无法对其添加监听器。<br></li>
</ul>
<p>Note:<br>windows平台不支持发射信号，但是Node通过<code>process.kill()</code>,<code>ChildProcess.kill()</code>提供了某些模拟机制。</p>
<ul>
<li>发射信号<code>0</code>可以用来测试一个进程的存在与否。</li>
<li>发射<code>SIGINT</code>,<code>SIGTERM</code>,<code>SIGKILL</code>可以无条件的终止目标进程。</li>
</ul>
<h2 id="process-abort"><a href="#process-abort" class="headerlink" title="process.abort()"></a>process.abort()</h2><blockquote>
<p>该方法可以迅速的终止Node进程，并且产生一个core file</p>
</blockquote>
<h2 id="prcess-arch-architecture"><a href="#prcess-arch-architecture" class="headerlink" title="prcess.arch(architecture)"></a>prcess.arch(architecture)</h2><p>return: &lt;string&gt;</p>
<blockquote>
<p>该属性返回当前正在运行的Node进程的处理器结构标识，如<code>arm</code>,<code>ia32</code>,<code>x64</code></p>
</blockquote>
<h2 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h2><p>return: &lt;Array&gt;</p>
<blockquote>
<p>返回当Node进程启动的时候在命令行传入的参数的数组。<br>数组的第一个元素就是<code>process.execPath</code>的值。<br>数组的第二个元素是被执行的文件的绝对路径。<br>余下的参数就是传入命令的其他的参数。</p>
</blockquote>
<p>process-args.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.argv.forEach(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;val&#125;</span>`</span>)    </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样启动：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node <span class="built_in">process</span>-args.js <span class="literal">one</span> <span class="literal">two</span>=<span class="literal">three</span> <span class="literal">four</span></div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>: /usr/<span class="built_in">local</span>/bin/node</div><div class="line"><span class="number">1</span>: /Users/qsch/workspace/tools/<span class="built_in">process</span>-args.js</div><div class="line"><span class="number">2</span>: <span class="literal">one</span></div><div class="line"><span class="number">3</span>: <span class="literal">two</span>=<span class="literal">three</span></div><div class="line"><span class="number">4</span>: <span class="literal">four</span></div></pre></td></tr></table></figure></p>
<h2 id="process-execPath"><a href="#process-execPath" class="headerlink" title="process.execPath"></a>process.execPath</h2><blockquote>
<p>返回启动Node进程的可执行程序的绝对路径, <code>&#39;/usr/local/bin/node&#39;</code></p>
</blockquote>
<h2 id="process-argv0"><a href="#process-argv0" class="headerlink" title="process.argv0"></a>process.argv0</h2><p>return: &lt;string&gt;</p>
<h2 id="process-channel"><a href="#process-channel" class="headerlink" title="process.channel"></a>process.channel</h2><blockquote>
<p>如果一个进程是通过<code>IPC</code>spawned出来的，那么<code>process.channel</code>属性返回IPC信道的引用。如果没有IPC信道存在，那么返回undefined。</p>
</blockquote>
<h2 id="process-chdir-directory"><a href="#process-chdir-directory" class="headerlink" title="process.chdir(directory)"></a>process.chdir(directory)</h2><p>directory: &lt;string&gt;</p>
<blockquote>
<p><code>process.chdir()</code>方法改变当前Node进程所在的工作目录。<br>如果操作失败（如指定的<code>directory</code>不存在），那么抛出一个异常。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">`Starting directory: <span class="subst">$&#123;process.cwd()&#125;</span>`</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  process.chdir(<span class="string">'/tmp'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`New directory: <span class="subst">$&#123;process.cwd()&#125;</span>`</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">`chdir: <span class="subst">$&#123;err&#125;</span>`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="process-connected"><a href="#process-connected" class="headerlink" title="process.connected"></a>process.connected</h2><p>return: &lt;boolean&gt;</p>
<blockquote>
<p>如果一个Node进程是通过IPC信道spawned出来的，那么只要主进程和spawned出来的进程的IPC信道是链接的，那么返回true。如果调用<code>process.disconnect()</code>那么该属性就返回false.<br>一旦<code>process.connected</code>返回false，那么就不能再通过<code>process.send()</code>基于IPC信道发送消息。</p>
</blockquote>
<h2 id="process-cpuUsage-previousValue"><a href="#process-cpuUsage-previousValue" class="headerlink" title="process.cpuUsage([previousValue])"></a>process.cpuUsage([previousValue])</h2><p>previousValue: 上一次调用此方法<code>process.cpuUsage()</code>的返回值<br>return: &lt;Object&gt;</p>
<ul>
<li>user: &lt;integer&gt;</li>
<li>system: &lt;integer&gt;<blockquote>
<p><code>process.cpuUsage()</code>方法返回包含当前进程的用户CPU时间和系统CPU时间的对象。此对象包含user和system属性，属性值的单位都是微秒(百万分之一秒)。 user和system属性值分别计算了执行用户程序和系统程序的时间，如果此进程在执行任务时是基于多核CPU，值可能比实际花费的时间要大。</p>
</blockquote>
</li>
</ul>
<p>上一次调用process.cpuUsage()方法的结果，可以作为参数值传递给此方法，得到的结果是与上一次的差值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> startUsage = process.cpuUsage();</div><div class="line"><span class="comment">// &#123; user: 38579, system: 6986 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// spin the CPU for 500 milliseconds</span></div><div class="line"><span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</div><div class="line"><span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(process.cpuUsage(startUsage));</div><div class="line"><span class="comment">// &#123; user: 514883, system: 11226 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h2><blockquote>
<p>返回当前Node进程所在的工作目录。</p>
</blockquote>
<h2 id="prcess-disconnect"><a href="#prcess-disconnect" class="headerlink" title="prcess.disconnect()"></a>prcess.disconnect()</h2><blockquote>
<p>如果一个Node进程是通过IPC信道spawned出来的，那么该方法会关闭该进程和父进程之间的IPC信道。当没有更多的链接时，当前子进程就会优雅的退出。<br>调用当前进程的<code>process.disconnect()</code>方法和调用父进程的<code>ChildProcess.disconnect()</code>起到的想过是一样的。<br><br><br>如果某个进程不是通过IPC信道spawned出来的，那么<code>process.disconnect</code>属性是undefined。</p>
</blockquote>
<h2 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h2><p>return: &lt;Object&gt;</p>
<blockquote>
<p>返回一个包含当前用户环境的对象</p>
</blockquote>
<p>这个对象的形式看起来可能如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">TERM</span>: <span class="string">'xterm-256color'</span>,</div><div class="line">  <span class="attribute">SHELL</span>: <span class="string">'/usr/local/bin/bash'</span>,</div><div class="line">  <span class="attribute">USER</span>: <span class="string">'maciej'</span>,</div><div class="line">  <span class="attribute">PATH</span>: <span class="string">'~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'</span>,</div><div class="line">  <span class="attribute">PWD</span>: <span class="string">'/Users/maciej'</span>,</div><div class="line">  <span class="attribute">EDITOR</span>: <span class="string">'vim'</span>,</div><div class="line">  <span class="attribute">SHLVL</span>: <span class="string">'1'</span>,</div><div class="line">  <span class="attribute">HOME</span>: <span class="string">'/Users/maciej'</span>,</div><div class="line">  <span class="attribute">LOGNAME</span>: <span class="string">'maciej'</span>,</div><div class="line">  <span class="attribute">_</span>: <span class="string">'/usr/local/bin/node'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note:<br>分配到<code>process.env</code>上的任何属性都会隐式的转化为字符串。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process<span class="selector-class">.env</span><span class="selector-class">.test</span> = null</div><div class="line">console.log(process<span class="selector-class">.env</span><span class="selector-class">.test</span>) <span class="comment">// 'null'</span></div><div class="line"></div><div class="line">process<span class="selector-class">.env</span><span class="selector-class">.test</span> = undefined</div><div class="line">console.log(typeof process<span class="selector-class">.env</span><span class="selector-class">.test</span>) <span class="comment">// 'string'</span></div></pre></td></tr></table></figure>
<p>可以通过<code>delete</code>操作符来删除<code>process.env</code>上的属性：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process<span class="selector-class">.env</span><span class="selector-class">.TEST</span> = <span class="number">1</span></div><div class="line">delete process<span class="selector-class">.env</span><span class="selector-class">.TEST</span></div><div class="line">console.log(process<span class="selector-class">.env</span><span class="selector-class">.TEST</span>) <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>在windows平台上，环境变量大小写不敏感：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">process<span class="selector-class">.env</span><span class="selector-class">.TEST</span> = <span class="number">1</span></div><div class="line">console.log(process<span class="selector-class">.env</span><span class="selector-class">.test</span>) <span class="comment">// '1'</span></div></pre></td></tr></table></figure></p>
<h2 id="process-execArgv"><a href="#process-execArgv" class="headerlink" title="process.execArgv"></a>process.execArgv</h2><p>return: &lt;Object&gt;</p>
<blockquote>
<p>返回当Node进程启动的时候传入到命令行中的Node.js特定的命令行选项。这些特定选项不会出现在<code>process.argv</code>属性返回的数组中。<code>process.execArgv</code>返回的数组不包括Node可执行程序，执行当前脚本的名称和跟随在脚本名称后面的选项。<br>这些选项非常的有用，当spawned一个进程的时候，可以通过它保证spawned出来的子进程和父进程保持一致的环境。</p>
</blockquote>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">node</span> <span class="title">--harmony</span> script.js --<span class="keyword">version</span></div></pre></td></tr></table></figure>
<p>那么process.execArgv返回：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">'--harmony</span>']</div></pre></td></tr></table></figure></p>
<p>而process.argv返回：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">'/usr/local/bin/node</span>', <span class="symbol">'script.js</span>', <span class="symbol">'--version</span>']</div></pre></td></tr></table></figure></p>
<h2 id="process-exit-code"><a href="#process-exit-code" class="headerlink" title="process.exit([code])"></a>process.exit([code])</h2><p>code: &lt;integer&gt; ,退出码，默认为0</p>
<blockquote>
<p>该方法告诉Node同步的终止进程并且携带一个退出码。如果没有传入code参数，那么默认使用代表成功的code<code>0</code>，或者使用<code>process.exitCode</code>(如果你曾经设置过)。当<code>exit</code>上的监听器全部执行完毕后，Node终止。</p>
</blockquote>
<p>Note: 调用<code>process.exit()</code>强制进程尽可能快的退出，即使有一些异步的工作还没有完全执行完毕，包括<code>process.stdout</code>, <code>process.stderr</code>的I/O操作。<br><br></p>
<p>在大多数的时候，，没有必要显示的调用<code>process.exit()</code>。Node进程会自动退出，当事件循环中没有更多的工作加入。可以通过设置<code>process.exitCode</code>来告诉进程当优雅的退出时使用什么样的状态码。<br><br></p>
<p>如下面的<code>process.exit()</code>错误用法演示了可能导致输出到标准输出的数据被切断和丢失：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someConditionNotMet()) &#123;</div><div class="line">  printUsageToStdout();</div><div class="line">  process.<span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的用法有问题的原因就是：写入数据到<code>process.stdout</code>中的操作有可能是异步的操作，调用<code>process.exit()</code>会强制进程在这些异步完成之前就退出了。<br><br></p>
<p>不应该直接调用<code>process.exit()</code>方法，正确的做法应该是设置<code>process.exitCode</code>,这样就可以进程自然的退出，避免在安排一些额外的工作进入到事件循环中。</p>
<p>正确的做法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">if</span> (someConditionNotMet()) &#123;</div><div class="line">  printUsageToStdout();</div><div class="line">  <span class="built_in">process</span>.exitCode = <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果因为发生了错误，抛出一个未捕获的错误，需要退出进程，通过设置<code>process.exitCode</code>要比直接调用<code>process.exit()</code>安全的多。</p>
<h2 id="process-exitCode"><a href="#process-exitCode" class="headerlink" title="process.exitCode"></a>process.exitCode</h2><p>return: &lt;integer&gt;</p>
<blockquote>
<p>进程退出的时携带的状态码。<br>调用<code>process.exit()</code>时指定了退出码，那么该退出码会覆盖之前通过<code>process.exitCode</code>设置的值。那么此时通过<code>process.exitCode</code>获取到的值就是<code>process.exit(code)</code>中指定的code。</p>
</blockquote>
<h2 id="process-kill-pid-signal"><a href="#process-kill-pid-signal" class="headerlink" title="process.kill(pid[,signal])"></a>process.kill(pid[,signal])</h2><p>pid: &lt;number&gt;,进程ID<br>signal: &lt;string&gt;|&lt;number&gt;,发射的信号，既可以是字符串，也可以是数字值，默认值是<code>SIGTERM</code>。</p>
<blockquote>
<p>该方法发送一个为<code>signal</code>的信号到<code>pid</code>的进程。</p>
</blockquote>
<p>如果<code>pid</code>不存在，那么该方法抛出一个错误。作为一种特殊情况，信号<code>0</code>可以被用来测试进程的存在性与否。在windows平台，如果<code>pid</code>被用来杀死一个进程组，那么会抛出一个错误。</p>
<p>Note: 尽管该方法的名字叫<code>kill</code>,但事实上它仅仅是一个信号发射器。发射信号的目的是去做一些事情，而不是杀死目标进程。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'SIGHUP'</span>, () =&gt; &#123;</div><div class="line">    console.log(<span class="string">'Got SIGHUP signal'</span>)    </div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">    console.log(<span class="string">'Exiting'</span>)    </div><div class="line">    process.<span class="keyword">exit</span>(<span class="number">0</span>)</div><div class="line">&#125;, <span class="number">100</span>)</div><div class="line"></div><div class="line">process.kill(process.pid, <span class="string">'SIGHUP'</span>)</div></pre></td></tr></table></figure>
<p>Note: 当Node进程接收到一个<code>SIGUSR1</code>信号时，Node就会启动调试程序。</p>
<h2 id="process-memoryUsage"><a href="#process-memoryUsage" class="headerlink" title="process.memoryUsage()"></a>process.memoryUsage()</h2><p>return: &lt;Object&gt;</p>
<ul>
<li>rss: &lt;integer&gt;</li>
<li>heapTotal: &lt;integer&gt;</li>
<li>heapUsed: &lt;integer&gt;</li>
<li>external: &lt;integer&gt;<blockquote>
<p>方法返回一个对象，描述了Node使用内存的情况。</p>
</blockquote>
</li>
</ul>
<p>如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">process</span><span class="selector-class">.memoryUsage</span>())</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">rss</span>: <span class="number">4935680</span>,</div><div class="line">  heapTotal: <span class="number">1826816</span>,</div><div class="line">  heapUsed: <span class="number">650472</span>,</div><div class="line">  external: <span class="number">49879</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>heapTotal</code>,<code>heapUsed</code>指向V8的内存的使用情况。<br><code>external</code>指向被V8管理的绑定到JS对象上的C++对象的内存使用情况。</p>
<h2 id="process-nextTick-callback-…args"><a href="#process-nextTick-callback-…args" class="headerlink" title="process.nextTick(callback[,…args])"></a>process.nextTick(callback[,…args])</h2><p>callback: &lt;Function&gt;<br>..args: 当调用callback时传入的额外参数。</p>
<blockquote>
<p>该方法将<code>callback</code>添加到当前<code>microtask</code>循环的下一个轮次，一旦本轮的<code>microtask</code>循环结束，立马执行下一轮<code>microtask</code>中所有<code>callback</code>。<br><code>process.nextTick</code>不是<code>setTimeout(fn, 0)</code>的别名，它更加的高效，他在一下轮<code>macrotask</code>之前执行。</p>
</blockquote>
<p>关于<code>microtask</code>和<code>macrotask</code>，请参看<a href="https://xxxxxmiss.github.io/2017/07/14/event-loop/">这里</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)    </div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick callback'</span>)    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'scheduled'</span>)</div><div class="line"></div><div class="line"><span class="comment">// start</span></div><div class="line"><span class="comment">// scheduled</span></div><div class="line"><span class="comment">// nextTick callback</span></div><div class="line"><span class="comment">// setTimeout</span></div></pre></td></tr></table></figure>
<p>当你在开发API时，你想给用户一个机会去添加事件处理器在对象被构造以后，在任何的I/O发生以前，这个方法就显得尤为重要。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyThing</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.setupOptions(options)</div><div class="line"></div><div class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span>f &#123;</div><div class="line">        <span class="keyword">this</span>.startDoingStuff()    </div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> MyThing()</div><div class="line">thing.getReadyForStuff()</div><div class="line"></div><div class="line"><span class="comment">// thing.startDoingStuff() gets called now, not before.</span></div><div class="line"><span class="comment">// thing.startDoingStuff()在thing.getReadyForStuff()之后才执行。</span></div></pre></td></tr></table></figure>
<p>当不确定一个方法时100%同步还是100%异步的时候，<code>process.nextTick</code>可以起到很重要的流程控制。<br>如：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// WARNING!  <span class="keyword">DO</span> <span class="keyword">NOT</span> <span class="keyword">USE</span>!  BAD UNSAFE HAZARD!</div><div class="line"><span class="keyword">function</span> <span class="title">maybeSync</span>(arg, cb) &#123;</div><div class="line">  if (arg) &#123;</div><div class="line">    cb();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  fs.stat(<span class="symbol">'file</span>', cb);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的<code>maybeSync</code>是一个非常不靠谱的API，因为可能出现如下情况：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maybeTrue = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>;</div><div class="line"></div><div class="line">maybeSync(maybeTrue, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  foo();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>此次你并不清楚<code>foo()</code>,<code>bar()</code>那个先执行，如果<code>maybeTrue</code>为<code>true</code>,那么<code>foo()</code>先执行，否则<code>bar()</code>先执行。</p>
<p>如果改写为如下写法，那么就可以明确知道谁先执行了：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">definitelyAsync</span><span class="params">(arg, cb)</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">arg</span>) &#123;</div><div class="line">    process.nextTick(cb);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  fs.stat(<span class="string">'file'</span>, cb);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，一定是<code>bar()</code>先执行，因为<code>process.nextTick</code>会将<code>cb</code>放到当前<code>microtask</code>的下一个轮次。</p>
<h2 id="process-pid"><a href="#process-pid" class="headerlink" title="process.pid"></a>process.pid</h2><p>return: &lt;integer&gt;</p>
<blockquote>
<p>返回当前进程的pid</p>
</blockquote>
<h2 id="process-platform"><a href="#process-platform" class="headerlink" title="process.platform"></a>process.platform</h2><p>return: &lt;string&gt;</p>
<blockquote>
<p>返回当前Node进程运行在那个操作系统的平台上。<br>如： <code>&#39;darwin&#39;</code>, <code>&#39;freebsd&#39;</code>, <code>&#39;linux&#39;</code>, <code>&#39;sunos&#39;</code> or <code>&#39;win32&#39;</code></p>
</blockquote>
<h2 id="prcess-send-message-sendHandle-options-callback"><a href="#prcess-send-message-sendHandle-options-callback" class="headerlink" title="prcess.send(message[, sendHandle[, options]][,callback])"></a>prcess.send(message[, sendHandle[, options]][,callback])</h2><p>message: &lt;Object&gt;<br>sendHandle: &lt;Handle object&gt;<br>options: &lt;Object&gt;<br>callback: &lt;Function&gt;<br>return: &lt;boolean&gt;</p>
<blockquote>
<p>如果一个进程是通过IPC信道spawned出来的，那么该进程可以通过<code>prcess.send()</code>方法发送信息到父进程。父进程可以通过<code>ChildProcess</code>来监听<code>message</code>事从而接收来自子进程的消息。<br>如果某个进程不是通过IPC信道spawned出来的，那么<code>process.send</code>属性为undefined。</p>
</blockquote>
<p>Note: 该方法内部使用<code>JSON.stringify()</code>来序列化<code>message</code>。</p>
<h2 id="process-stderr"><a href="#process-stderr" class="headerlink" title="process.stderr"></a>process.stderr</h2><p>return: &lg;Stream&gt;</p>
<blockquote>
<p>该方法返回一个连接到标准错误<code>stderr</code>(文件描述符为2)的流对象。<br>该流是一个<code>net.Socket</code>（这是一个双工流），当文件描述符<code>2</code>指向一个文件时，此时他是一个可写流。</p>
</blockquote>
<h2 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a>process.stdin</h2><p>return: &lg;Stream&gt;</p>
<blockquote>
<p>该方法返回一个连接到标注输入<code>stdin</code>(文件描述符为0)的流对象。<br>该流是一个<code>net.Socket</code>（这是一个双工流），当文件描述符<code>0</code>指向一个文件时，此时他是一个可读流。</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">process<span class="selector-class">.stdin</span><span class="selector-class">.setEncoding</span>(<span class="string">'utf8'</span>)</div><div class="line"></div><div class="line">process<span class="selector-class">.stdin</span><span class="selector-class">.on</span>(<span class="string">'readable'</span>, () =&gt; &#123;</div><div class="line">    const chunk = process<span class="selector-class">.stdin</span><span class="selector-class">.read</span>()    </div><div class="line"></div><div class="line">    <span class="keyword">if</span>(chunk !== null)&#123;</div><div class="line">        process<span class="selector-class">.stdout</span><span class="selector-class">.write</span>(`data: $&#123;chunk&#125;`)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">process<span class="selector-class">.stdin</span><span class="selector-class">.on</span>(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">    process<span class="selector-class">.stdout</span><span class="selector-class">.write</span>(<span class="string">'end'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a>process.stdout</h2><p>return: &lt;Stream&gt;</p>
<blockquote>
<p>该方法返回一个连接到标注输出<code>stdout</code>(文件描述符为1)的流对象。<br>该流是一个<code>net.Socket</code>（这是一个双工流），当文件描述符<code>1</code>指向一个文件时，此时他是一个可写流。</p>
</blockquote>
<p>如：拷贝process.stdin到process.stdout<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">process</span>.<span class="keyword">stdin</span>.pipe(<span class="built_in">process</span>.<span class="keyword">stdout</span>)</div></pre></td></tr></table></figure></p>
<h3 id="关于process-I-O需要注意以下几点："><a href="#关于process-I-O需要注意以下几点：" class="headerlink" title="关于process I/O需要注意以下几点："></a>关于process I/O需要注意以下几点：</h3><blockquote>
<p><code>process.stdout</code>和<code>process.stderr</code>区别于Node中其他的流有以下几点：</p>
</blockquote>
<p>1, 他们分别被用于<code>console.log()</code>和<code>console.error()</code>内部<br>2, 他们不能被关闭<br>3, 他们不会触发<code>finish</code>事件<br>4, 写入有可能是同步的，取决于他们连接到哪里以及在哪个平台上：</p>
<ul>
<li>Files: 在windows和Linux平台上都是同步的</li>
<li>TTYs(Terminals): 在windows上异步，在Unix上同步</li>
<li>Pipes以及sockets: 在windows上同步，在Unix上异步</li>
</ul>
<p>之所以有这些因为，都是因为一些历史原因，但是又不能轻易的改变他们。<br><br></p>
<p>同步的写入可以避免一些问题，比如<code>console.log()</code>,<code>console.error()</code>, 我们知道当使用<code>process.exit()</code>会立马终止进程，如果是异步写入，那么就可能导致还没写完进程就终止了，导致数据写入不全。</p>
<p>Warning: ….</p>
<h2 id="process-uptime"><a href="#process-uptime" class="headerlink" title="process.uptime()"></a>process.uptime()</h2><p>return: &lt;number&gt;</p>
<blockquote>
<p>返回当前Node进程运行的秒数。<br>需要注意的是，这个秒数包括小数部分。</p>
</blockquote>
<h2 id="process-version"><a href="#process-version" class="headerlink" title="process.version"></a>process.version</h2><p>return: &lt;string&gt;</p>
<blockquote>
<p>返回当前Node的版本</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">process</span>.<span class="built_in">version</span><span class="comment"></span></div><div class="line">// v7.5.0</div></pre></td></tr></table></figure>
<h2 id="Exit-Codes-退出码"><a href="#Exit-Codes-退出码" class="headerlink" title="Exit Codes(退出码)"></a>Exit Codes(退出码)</h2><p><a href="https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_exit_codes" target="_blank" rel="external">具体参看这里</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-07-16T12:19:25.000Z" itemprop="dateUpdated">2017-07-16 20:19:25</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/07/12/nodejs-process/" target="_blank" rel="external">https://xxxxxmiss.github.io/2017/07/12/nodejs-process/</a>
        
    </div>
    <footer>
        <a href="https://xxxxxmiss.github.io">
            <img src="/img/avatar.jpg" alt="xxxxxMiss">
            xxxxxMiss
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&title=《nodejs-process》 — 青史成灰&pic=https://xxxxxmiss.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&title=《nodejs-process》 — 青史成灰&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《nodejs-process》 — 青史成灰&url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&via=https://xxxxxmiss.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/07/14/event-loop/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">event-loop(事件循环)</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/06/05/RegExp/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">RegExp</h4>
      </a>
    </div>
  
</nav>



    











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>xxxxxMiss &copy; 2015 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&title=《nodejs-process》 — 青史成灰&pic=https://xxxxxmiss.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&title=《nodejs-process》 — 青史成灰&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《nodejs-process》 — 青史成灰&url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/&via=https://xxxxxmiss.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xxxxxmiss.github.io/2017/07/12/nodejs-process/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3a226DQAxF0f7/T9PXSBHTfWyoNJ7NUwRJYKWS69vPDz6uj+P7zOd5cvX7nXd3efiQIUPGtoxreZD33N2Y8O7uxd8vQ4aMcxgkFJKrffD6vrfnZciQIQOQSEq3TgTXwVeGDBkyUgYpaEn5KkOGDBmcwQtL/hC1VO/1WlyGDBkbMnjX/f9fvzLfkCFDxlaMKzxqid06BD/wVDJkyBjN4AEuHTrykrXTtpMhQ8Y5jM6qFlnOeLYMbuWzMmTI2JbRabGtv4GHyP5wQoYMGVMZtYWwWrJISmLOa/0GMmTI2JBRGxB2WnW86fbYmoUMGTI2Z9RKyhRMzvMhhAwZMk5j8Mfii1+1UWgagv+YxMqQIWMEIw1zfHlrDas144KuoQwZMgYxeDqY5mDrb66NPIO/gwwZMgYx0uEiT+x4idspd2XIkHEaIy1WayVo3ErDzUEZMmRMZaTtsFqY5qPQ9LNBxipDhozNGbVkLi1H3xtCyJAhYzaDr1z0x5m14FssYmXIkDGUQQaW5Gp/tJneV4YMGecwajeurVCQtl38b0CGDBkHMGrLE2kCR4JssTEnQ4aMoYwrPGqk2spFQJUhQ8ZoRv+rn0ouyU/QXzuTIUPGvgweZNN1Cp50pp9CGa4MGTLGMUig5GExXTXrL3nIkCFDBs8ua+cJFVXkMmTIkNFI7Phia21FQ4YMGScw0mFAuiqRjidfbLfJkCFjQwYvHXkhyq9yZH84KkOGjA0Zv5zmdHLH9cGMAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
